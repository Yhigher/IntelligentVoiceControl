###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               29/Apr/2024  11:26:06
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f C:\Users\Ñî\AppData\Local\Temp\EW5F3A.tmp
#        (D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
#        -D xNWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D
#        xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\EndDeviceEB\List
#        -lA
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x520
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=TRUE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\Source\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\osal\mcu\ccsoc\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\EndDeviceEB\List\ZDSecMgr.lst
#    Object file        =  
#        D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Projects\zstack\Samples\GenericApp_project\CC2530DB\EndDeviceEB\Obj\ZDSecMgr.r51
#
###############################################################################

D:\qtfile\ZStack-CC2530-2.4.0-1.4.0\ZStack-CC2530-2.4.0-1.4.0\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2010-08-20 16:29:19 -0700 (Fri, 20 Aug 2010) $
      4            Revision:       $Revision: 23466 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          // Total number of preconfigured trust center link key
     93          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     94            #define ZDSECMGR_TC_DEVICE_MAX 1
     95          #endif
     96            
     97          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     98            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     99          #endif
    100            
    101          #define ZDSECMGR_CTRL_NONE       0
    102          #define ZDSECMGR_CTRL_INIT       1
    103          #define ZDSECMGR_CTRL_TK_MASTER  2
    104          #define ZDSECMGR_CTRL_SKKE_INIT  3
    105          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    106          #define ZDSECMGR_CTRL_SKKE_DONE  5
    107          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    108          #define ZDSECMGR_CTRL_TK_NWK     7
    109          
    110          #define ZDSECMGR_CTRL_BASE_CNTR      1
    111          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    112          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    113          
    114          // set SKA slot maximum
    115          #define ZDSECMGR_SKA_SLOT_MAX 1
    116          
    117          // APSME Stub Implementations
    118          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    119          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    120          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    121          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    122          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    123          
    124          /******************************************************************************
    125           * TYPEDEFS
    126           */
    127          typedef struct
    128          {
    129            uint8 extAddr[Z_EXTADDR_LEN];
    130            uint8 key[SEC_KEY_LEN];
    131          } ZDSecMgrPreConfigData_t;
    132          
    133          typedef struct
    134          {
    135            uint16 ami;
    136            uint8  key[SEC_KEY_LEN];
    137          } ZDSecMgrMasterKeyData_t;
    138          
    139          typedef struct
    140          {
    141            uint16            ami;
    142            uint16            keyNvId;   // index to the Link Key table in NV
    143            ZDSecMgr_Authentication_Option authenticateOption;
    144          } ZDSecMgrEntry_t;
    145          
    146          typedef struct
    147          {
    148            ZDSecMgrEntry_t* entry;
    149            uint16           parentAddr;
    150            uint8            secure;
    151            uint8            state;
    152            uint8            cntr;
    153          } ZDSecMgrCtrl_t;
    154          
    155          typedef struct
    156          {
    157            uint16          nwkAddr;
    158            uint8*          extAddr;
    159            uint16          parentAddr;
    160            uint8           secure;
    161            uint8           devStatus;
    162            ZDSecMgrCtrl_t* ctrl;
    163          } ZDSecMgrDevice_t;
    164          
    165          /******************************************************************************
    166           * LOCAL VARIABLES
    167           */
    168          #if 0 // Taken out because the following functionality is only used for test
    169                // purpose. A more efficient (above) way is used. It can be put
    170                // back in if customers request for a white/black list feature.
    171          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    172          {
    173            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    174            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    175            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    176          };
    177          #endif
    178          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    180            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    181          
    182          // Key data is put in CONST area for security reasons

   \                                 In  segment CODE_C, align 1
    183          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   00           DB 0
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   89           DB 137
   \   000009   67           DB 103
   \   00000A   45           DB 69
   \   00000B   23           DB 35
   \   00000C   01           DB 1
   \   00000D   EF           DB 239
   \   00000E   CD           DB 205
   \   00000F   AB           DB 171
    184            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    185             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    186          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    187          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    189          
    190          //devtag.pro.security - remove this
    191          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    192          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    193          {
    194            //---------------------------------------------------------------------------
    195            // DEVICE A
    196            //---------------------------------------------------------------------------
    197            {
    198              // extAddr
    199              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    200          
    201              // key
    202              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    203               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    204            },
    205            //---------------------------------------------------------------------------
    206            // DEVICE B
    207            //---------------------------------------------------------------------------
    208            {
    209              // extAddr
    210              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    211          
    212              // key
    213              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    214               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    215            },
    216            //---------------------------------------------------------------------------
    217            // DEVICE C
    218            //---------------------------------------------------------------------------
    219            {
    220              // extAddr
    221              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    222          
    223              // key
    224              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    225               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    226            },
    227          };
    228          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    229          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    230          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    231          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    232          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    233          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    234          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    236          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    237          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    238          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    239          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    241          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    242          
    243          /******************************************************************************
    244           * PRIVATE FUNCTIONS
    245           *
    246           *   ZDSecMgrMasterKeyInit
    247           *   ZDSecMgrAddrStore
    248           *   ZDSecMgrExtAddrStore
    249           *   ZDSecMgrExtAddrLookup
    250           *   ZDSecMgrMasterKeyLookup
    251           *   ZDSecMgrMasterKeyStore
    252           *   ZDSecMgrEntryInit
    253           *   ZDSecMgrEntryLookup
    254           *   ZDSecMgrEntryLookupAMI
    255           *   ZDSecMgrEntryLookupExt
    256           *   ZDSecMgrEntryLookupExtGetIndex
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           *   APSME_TCLinkKeyInit
    290           *   APSME_IsDefaultTCLK
    291           */
    292          //-----------------------------------------------------------------------------
    293          // master key data
    294          //-----------------------------------------------------------------------------
    295          void ZDSecMgrMasterKeyInit( void );
    296          
    297          //-----------------------------------------------------------------------------
    298          // address management
    299          //-----------------------------------------------------------------------------
    300          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    302          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    303          
    304          //-----------------------------------------------------------------------------
    305          // MASTER key data
    306          //-----------------------------------------------------------------------------
    307          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    308          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    309          
    310          //-----------------------------------------------------------------------------
    311          // entry data
    312          //-----------------------------------------------------------------------------
    313          void ZDSecMgrEntryInit(uint8 state);
    314          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    315          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    316          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    318          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    319          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    320          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    321          void ZDSecMgrApsLinkKeyInit(void);
    322          #if defined NV_RESTORE
    323          static void ZDSecMgrWriteNV(void);
    324          static void ZDSecMgrRestoreFromNV(void);
    325          #endif
    326          
    327          //-----------------------------------------------------------------------------
    328          // control data
    329          //-----------------------------------------------------------------------------
    330          void ZDSecMgrCtrlInit( void );
    331          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    332          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    333          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    334                                ZDSecMgrEntry_t*  entry,
    335                                ZDSecMgrCtrl_t*   ctrl );
    336          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    337          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    338          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    339                                       ZDSecMgrEntry_t*  entry );
    340          
    341          //-----------------------------------------------------------------------------
    342          // key support
    343          //-----------------------------------------------------------------------------
    344          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    345          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    346                                       uint8*  initExtAddr,
    347                                       uint16  partNwkAddr,
    348                                       uint8*  partExtAddr,
    349                                       uint8** key,
    350                                       uint8*  keyType );
    351          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    352          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    353          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    354          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    355          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    356          
    357          //-----------------------------------------------------------------------------
    358          // device entry
    359          //-----------------------------------------------------------------------------
    360          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    361          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    362          
    363          //-----------------------------------------------------------------------------
    364          // device control
    365          //-----------------------------------------------------------------------------
    366          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    367          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    368          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    369          
    370          //-----------------------------------------------------------------------------
    371          // device management
    372          //-----------------------------------------------------------------------------
    373          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    374          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    375          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    376          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    377          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    382          
    383          //-----------------------------------------------------------------------------
    384          // association management
    385          //-----------------------------------------------------------------------------
    386          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    387          
    388          //-----------------------------------------------------------------------------
    389          // authentication management
    390          //-----------------------------------------------------------------------------
    391          void ZDSecMgrAuthInitiate( uint8* responder );
    392          void ZDSecMgrAuthNwkKey( void );
    393          
    394          //-----------------------------------------------------------------------------
    395          // APSME function
    396          //-----------------------------------------------------------------------------
    397          void APSME_TCLinkKeyInit( uint8 setDefault );
    398          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    399          
    400          /******************************************************************************
    401           * @fn          ZDSecMgrMasterKeyInit                     ]
    402           *
    403           * @brief       Initialize master key data in NV
    404           *
    405           * @param       none
    406           *
    407           * @return      none
    408           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    409          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    410          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    411            uint16 index;
    412            ZDSecMgrMasterKeyData_t   masterKeyData;
    413          
    414            masterKeyData.ami = INVALID_NODE_ADDR;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   74FE         MOV       A,#-0x2
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    415          
    416            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   000016                ; Setup parameters for call to function osal_memset
   \   000016   7C10         MOV       R4,#0x10
   \   000018   7D00         MOV       R5,#0x0
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   AA82         MOV       R2,DPL
   \   000023   AB83         MOV       R3,DPH
   \   000025   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    417          
    418            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   000028   7E00         MOV       R6,#0x0
   \   00002A   7F00         MOV       R7,#0x0
    419            {
    420              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index), 
    421                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   00002C                ; Setup parameters for call to function osal_nv_item_init
   \   00002C   A8..         MOV       R0,?XSP + 0
   \   00002E   A9..         MOV       R1,?XSP + 1
   \   000030   88..         MOV       ?V0,R0
   \   000032   89..         MOV       ?V1,R1
   \   000034   78..         MOV       R0,#?V0
   \   000036   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000039   7C12         MOV       R4,#0x12
   \   00003B   12....       LCALL     ??Subroutine76_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00003E   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000041   7402         MOV       A,#0x2
   \   000043   12....       LCALL     ?DEALLOC_XSTACK8
   \   000046   E9           MOV       A,R1
   \   000047   701B         JNZ       ??ZDSecMgrMasterKeyInit_1
    422              {
    423                // the item already exists in NV just needs to be set to default values
    424                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    425                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000049                ; Setup parameters for call to function osal_nv_write
   \   000049   78..         MOV       R0,#?V0
   \   00004B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004E   75..12       MOV       ?V0,#0x12
   \   000051   75..00       MOV       ?V1,#0x0
   \   000054   78..         MOV       R0,#?V0
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000059   12....       LCALL     ?Subroutine29 & 0xFFFF
    426              }
    427            }
   \                     ??CrossCallReturnLabel_105:
   \   00005C   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005F   7404         MOV       A,#0x4
   \   000061   12....       LCALL     ?DEALLOC_XSTACK8
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000064   0E           INC       R6
   \   000065   EE           MOV       A,R6
   \   000066   7001         JNZ       ??ZDSecMgrMasterKeyInit_2
   \   000068   0F           INC       R7
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   000069   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00006C   40BE         JC        ??ZDSecMgrMasterKeyInit_0
    428          }
   \   00006E   7412         MOV       A,#0x12
   \   000070   02....       LJMP      ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   7C00         MOV       R4,#0x0
   \   000002                REQUIRE ??Subroutine76_0
   \   000002                ; // Fall through to label ??Subroutine76_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine76_0:
   \   000000   7D00         MOV       R5,#0x0
   \   000002   EE           MOV       A,R6
   \   000003   2401         ADD       A,#0x1
   \   000005   FA           MOV       R2,A
   \   000006   EF           MOV       A,R7
   \   000007   3403         ADDC      A,#0x3
   \   000009   FB           MOV       R3,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine86_0
   \   000003                ; // Fall through to label ??Subroutine86_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   C3           CLR       C
   \   000001   9403         SUBB      A,#0x3
   \   000003   EF           MOV       A,R7
   \   000004   9400         SUBB      A,#0x0
   \   000006   22           RET
    429          
    430          /******************************************************************************
    431           * @fn          ZDSecMgrAddrStore
    432           *
    433           * @brief       Store device addresses.
    434           *
    435           * @param       nwkAddr - [in] NWK address
    436           * @param       extAddr - [in] EXT address
    437           * @param       ami     - [out] Address Manager index
    438           *
    439           * @return      ZStatus_t
    440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    441          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    442          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    443            ZStatus_t      status;
    444            AddrMgrEntry_t entry;
    445          
    446          
    447            // add entry
    448            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    449            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ??Subroutine95_0 & 0xFFFF
    450            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_207:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV       A,#0x3
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV       A,#0x16
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   12....       LCALL     ?Subroutine49 & 0xFFFF
    451          
    452            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_51:
   \   00002E   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000031   E9           MOV       A,R1
   \   000032   6401         XRL       A,#0x1
   \   000034   700A         JNZ       ??ZDSecMgrAddrStore_0
    453            {
    454              // return successful results
    455              *ami   = entry.index;
   \   000036   740B         MOV       A,#0xb
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   12....       LCALL     ?Subroutine13 & 0xFFFF
    456              status = ZSuccess;
    457            }
   \                     ??CrossCallReturnLabel_98:
   \   00003E   8008         SJMP      ??CrossCallReturnLabel_19
    458            else
    459            {
    460              // return failed results
    461              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000040   740B         MOV       A,#0xb
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   12....       LCALL     ?Subroutine24 & 0xFFFF
    462              status = ZNwkUnknownDevice;
    463            }
    464          
    465            return status;
   \                     ??CrossCallReturnLabel_19:
   \   000048   02....       LJMP      ?Subroutine7 & 0xFFFF
    466          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003                REQUIRE ??Subroutine74_0
   \   000003                ; // Fall through to label ??Subroutine74_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine74_0:
   \   000000   F9           MOV       R1,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005                REQUIRE ??Subroutine75_0
   \   000005                ; // Fall through to label ??Subroutine75_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine75_0:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   7900         MOV       R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000005   AA..         MOV       R2,?XSP + 0
   \   000007   AB..         MOV       R3,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000003   8E82         MOV       DPL,R6
   \   000005   8F83         MOV       DPH,R7
   \   000007   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00000A   79C8         MOV       R1,#-0x38
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   740D         MOV       A,#0xd
   \   000002   02....       LJMP      ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine93_0
   \   000003                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   000003   F9           MOV       R1,A
   \   000004   22           RET
    467          
    468          /******************************************************************************
    469           * @fn          ZDSecMgrExtAddrStore
    470           *
    471           * @brief       Store EXT address.
    472           *
    473           * @param       extAddr - [in] EXT address
    474           * @param       ami     - [out] Address Manager index
    475           *
    476           * @return      ZStatus_t
    477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    478          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    479          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    480            ZStatus_t      status;
    481            AddrMgrEntry_t entry;
    482          
    483          
    484            // add entry
    485            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   7402         MOV       A,#0x2
   \   000012   F0           MOVX      @DPTR,A
    486            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC       A
   \   000014   12....       LCALL     ?XSTACK_DISP0_8
   \   000017   12....       LCALL     ??Subroutine95_0 & 0xFFFF
    487            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_208:
   \   00001A                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001A   7403         MOV       A,#0x3
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   AA82         MOV       R2,DPL
   \   000021   AB83         MOV       R3,DPH
   \   000023   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000026   7416         MOV       A,#0x16
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   12....       LCALL     ?Subroutine49 & 0xFFFF
    488          
    489            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_52:
   \   00002E   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000031   E9           MOV       A,R1
   \   000032   6401         XRL       A,#0x1
   \   000034   700A         JNZ       ??ZDSecMgrExtAddrStore_0
    490            {
    491              // return successful results
    492              *ami   = entry.index;
   \   000036   740B         MOV       A,#0xb
   \   000038   12....       LCALL     ?XSTACK_DISP0_8
   \   00003B   12....       LCALL     ?Subroutine13 & 0xFFFF
    493              status = ZSuccess;
    494            }
   \                     ??CrossCallReturnLabel_99:
   \   00003E   8008         SJMP      ??CrossCallReturnLabel_20
    495            else
    496            {
    497              // return failed results
    498              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000040   740B         MOV       A,#0xb
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   12....       LCALL     ?Subroutine24 & 0xFFFF
    499              status = ZNwkUnknownDevice;
    500            }
    501          
    502            return status;
   \                     ??CrossCallReturnLabel_20:
   \   000048   80..         SJMP      ?Subroutine7
    503          }
    504          
    505          /******************************************************************************
    506           * @fn          ZDSecMgrExtAddrLookup
    507           *
    508           * @brief       Lookup index for specified EXT address.
    509           *
    510           * @param       extAddr - [in] EXT address
    511           * @param       ami     - [out] Address Manager index
    512           *
    513           * @return      ZStatus_t
    514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    515          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    516          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    517            ZStatus_t      status;
    518            AddrMgrEntry_t entry;
    519          
    520          
    521            // lookup entry
    522            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    523            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV       A,R2
   \   000018   FC           MOV       R4,A
   \   000019   EB           MOV       A,R3
   \   00001A   FD           MOV       R5,A
   \   00001B   7403         MOV       A,#0x3
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   AA82         MOV       R2,DPL
   \   000022   AB83         MOV       R3,DPH
   \   000024   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    524          
    525            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV       R2,?XSP + 0
   \   000029   AB..         MOV       R3,?XSP + 1
   \   00002B   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV       A,R1
   \   00002F   6401         XRL       A,#0x1
   \   000031   700A         JNZ       ??ZDSecMgrExtAddrLookup_0
    526            {
    527              // return successful results
    528              *ami   = entry.index;
   \   000033   740B         MOV       A,#0xb
   \   000035   12....       LCALL     ?XSTACK_DISP0_8
   \   000038   12....       LCALL     ?Subroutine13 & 0xFFFF
    529              status = ZSuccess;
    530            }
   \                     ??CrossCallReturnLabel_100:
   \   00003B   8008         SJMP      ??CrossCallReturnLabel_21
    531            else
    532            {
    533              // return failed results
    534              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV       A,#0xb
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ?Subroutine24 & 0xFFFF
    535              status = ZNwkUnknownDevice;
    536            }
    537          
    538            return status;
   \                     ??CrossCallReturnLabel_21:
   \   000045                REQUIRE ?Subroutine7
   \   000045                ; // Fall through to label ?Subroutine7
    539          }
    540          
    541          /******************************************************************************
    542           * @fn          ZDSecMgrMasterKeyLookup
    543           *
    544           * @brief       Lookup MASTER key for specified address index.
    545           *
    546           * @param       ami - [in] Address Manager index
    547           * @param       pKeyNvId - [out] MASTER key NV ID
    548           *
    549           * @return      ZStatus_t
    550           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    551          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    552          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
    553            uint16 index;
    554            ZDSecMgrMasterKeyData_t masterKeyData;
    555          
    556            
    557            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7E00         MOV       R6,#0x0
   \   000014   7F00         MOV       R7,#0x0
    558            {  
    559              // Read entry index of the Master key table from NV
    560              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    561                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000016                ; Setup parameters for call to function osal_nv_read
   \   000016   A8..         MOV       R0,?XSP + 0
   \   000018   A9..         MOV       R1,?XSP + 1
   \   00001A   88..         MOV       ?V4,R0
   \   00001C   89..         MOV       ?V5,R1
   \   00001E   78..         MOV       R0,#?V4
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   75..12       MOV       ?V4,#0x12
   \   000026   75..00       MOV       ?V5,#0x0
   \   000029   78..         MOV       R0,#?V4
   \   00002B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002E   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000031   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000034   7404         MOV       A,#0x4
   \   000036   12....       LCALL     ?DEALLOC_XSTACK8
    562              
    563              if ( masterKeyData.ami == ami )
   \   000039   85..82       MOV       DPL,?XSP + 0
   \   00003C   85..83       MOV       DPH,?XSP + 1
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   65..         XRL       A,?V2
   \   000042   7004         JNZ       ??ZDSecMgrMasterKeyLookup_1
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   65..         XRL       A,?V3
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000048   7022         JNZ       ??ZDSecMgrMasterKeyLookup_2
    564              {
    565                // return successful results
    566                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   00004A   EE           MOV       A,R6
   \   00004B   2401         ADD       A,#0x1
   \   00004D   F8           MOV       R0,A
   \   00004E   EF           MOV       A,R7
   \   00004F   3403         ADDC      A,#0x3
   \   000051   F9           MOV       R1,A
   \   000052   85..82       MOV       DPL,?V0
   \   000055   85..83       MOV       DPH,?V1
   \   000058   12....       LCALL     ??Subroutine84_0 & 0xFFFF
    567                
    568                // clear copy of key in RAM
    569                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \                     ??CrossCallReturnLabel_136:
   \   00005B                ; Setup parameters for call to function osal_memset
   \   00005B   7C12         MOV       R4,#0x12
   \   00005D   7D00         MOV       R5,#0x0
   \   00005F   7900         MOV       R1,#0x0
   \   000061   AA..         MOV       R2,?XSP + 0
   \   000063   AB..         MOV       R3,?XSP + 1
   \   000065   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    570                
    571                return ZSuccess;
   \   000068   7900         MOV       R1,#0x0
   \   00006A   8021         SJMP      ??ZDSecMgrMasterKeyLookup_3
    572              }
    573            }
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   00006C   0E           INC       R6
   \   00006D   EE           MOV       A,R6
   \   00006E   7001         JNZ       ??ZDSecMgrMasterKeyLookup_4
   \   000070   0F           INC       R7
   \                     ??ZDSecMgrMasterKeyLookup_4:
   \   000071   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000074   40A0         JC        ??ZDSecMgrMasterKeyLookup_0
    574            
    575            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \   000076   85..82       MOV       DPL,?V0
   \   000079   85..83       MOV       DPH,?V1
   \   00007C   E4           CLR       A
   \   00007D   F0           MOVX      @DPTR,A
   \   00007E   A3           INC       DPTR
   \   00007F   F0           MOVX      @DPTR,A
    576          
    577            // clear copy of key in RAM
    578            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000080                ; Setup parameters for call to function osal_memset
   \   000080   7C12         MOV       R4,#0x12
   \   000082   FD           MOV       R5,A
   \   000083   F9           MOV       R1,A
   \   000084   AA..         MOV       R2,?XSP + 0
   \   000086   AB..         MOV       R3,?XSP + 1
   \   000088   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    579          
    580            return ZNwkUnknownDevice;
   \   00008B   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   00008D   02....       LJMP      ?Subroutine2 & 0xFFFF
    581          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7412         MOV       A,#0x12
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005                REQUIRE ??Subroutine79_0
   \   000005                ; // Fall through to label ??Subroutine79_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine79_0:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   22           RET
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrMasterKeyStore
    585           *
    586           * @brief       Store MASTER key for specified address index.
    587           *
    588           * @param       ami - [in] Address Manager index
    589           * @param       key - [in] valid key to store
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
    595            uint16    index;
    596            ZDSecMgrMasterKeyData_t   masterKeyData;
    597            
    598          
    599            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7E00         MOV       R6,#0x0
   \   000014   7F00         MOV       R7,#0x0
    600            {
    601              // Read entry index of the Master key table from NV
    602              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    603                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000016                ; Setup parameters for call to function osal_nv_read
   \   000016   A8..         MOV       R0,?XSP + 0
   \   000018   A9..         MOV       R1,?XSP + 1
   \   00001A   88..         MOV       ?V4,R0
   \   00001C   89..         MOV       ?V5,R1
   \   00001E   78..         MOV       R0,#?V4
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   75..12       MOV       ?V4,#0x12
   \   000026   75..00       MOV       ?V5,#0x0
   \   000029   78..         MOV       R0,#?V4
   \   00002B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002E   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000031   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000034   7404         MOV       A,#0x4
   \   000036   12....       LCALL     ?DEALLOC_XSTACK8
    604          
    605              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \   000039   85..82       MOV       DPL,?XSP + 0
   \   00003C   85..83       MOV       DPH,?XSP + 1
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   64FE         XRL       A,#0xfe
   \   000042   7003         JNZ       ??ZDSecMgrMasterKeyStore_1
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   F4           CPL       A
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000047   7078         JNZ       ??ZDSecMgrMasterKeyStore_2
    606              {
    607                // store EXT address index
    608                masterKeyData.ami = ami;
   \   000049   85..82       MOV       DPL,?XSP + 0
   \   00004C   85..83       MOV       DPH,?XSP + 1
   \   00004F   E5..         MOV       A,?V2
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   E5..         MOV       A,?V3
   \   000055   F0           MOVX      @DPTR,A
    609          
    610                if ( key != NULL )
   \   000056   E5..         MOV       A,?V0
   \   000058   45..         ORL       A,?V1
   \   00005A   601F         JZ        ??ZDSecMgrMasterKeyStore_3
    611                {
    612                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   00005C                ; Setup parameters for call to function osal_memcpy
   \   00005C   75..00       MOV       ?V2,#0x0
   \   00005F   78..         MOV       R0,#?V0
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000064   7C10         MOV       R4,#0x10
   \   000066   7D00         MOV       R5,#0x0
   \   000068   7405         MOV       A,#0x5
   \   00006A   12....       LCALL     ?XSTACK_DISP0_8
   \   00006D   AA82         MOV       R2,DPL
   \   00006F   AB83         MOV       R3,DPH
   \   000071   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000074   7403         MOV       A,#0x3
   \   000076   12....       LCALL     ?DEALLOC_XSTACK8
   \   000079   8012         SJMP      ??ZDSecMgrMasterKeyStore_4
    613                }
    614                else
    615                {
    616                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00007B                ; Setup parameters for call to function osal_memset
   \   00007B   7C10         MOV       R4,#0x10
   \   00007D   7D00         MOV       R5,#0x0
   \   00007F   7900         MOV       R1,#0x0
   \   000081   7402         MOV       A,#0x2
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   AA82         MOV       R2,DPL
   \   000088   AB83         MOV       R3,DPH
   \   00008A   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    617                }
    618          
    619                // set new values in NV      
    620                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0, 
    621                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   00008D                ; Setup parameters for call to function osal_nv_write
   \   00008D   A8..         MOV       R0,?XSP + 0
   \   00008F   A9..         MOV       R1,?XSP + 1
   \   000091   88..         MOV       ?V0,R0
   \   000093   89..         MOV       ?V1,R1
   \   000095   78..         MOV       R0,#?V0
   \   000097   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00009A   75..12       MOV       ?V0,#0x12
   \   00009D   75..00       MOV       ?V1,#0x0
   \   0000A0   78..         MOV       R0,#?V0
   \   0000A2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A5   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   0000A8   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000AB   7404         MOV       A,#0x4
   \   0000AD   12....       LCALL     ?DEALLOC_XSTACK8
    622                 
    623                // clear copy of key in RAM
    624                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000B0                ; Setup parameters for call to function osal_memset
   \   0000B0   7C12         MOV       R4,#0x12
   \   0000B2   7D00         MOV       R5,#0x0
   \   0000B4   7900         MOV       R1,#0x0
   \   0000B6   AA..         MOV       R2,?XSP + 0
   \   0000B8   AB..         MOV       R3,?XSP + 1
   \   0000BA   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    625          
    626                // return successful results
    627                return ZSuccess;
   \   0000BD   7900         MOV       R1,#0x0
   \   0000BF   801C         SJMP      ??ZDSecMgrMasterKeyStore_5
    628              }
    629            }
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   0000C1   0E           INC       R6
   \   0000C2   EE           MOV       A,R6
   \   0000C3   7001         JNZ       ??ZDSecMgrMasterKeyStore_6
   \   0000C5   0F           INC       R7
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   0000C6   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000C9   5003         JNC       $+5
   \   0000CB   02....       LJMP      ??ZDSecMgrMasterKeyStore_0 & 0xFFFF
    630            
    631            // clear copy of key in RAM
    632            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   0000CE                ; Setup parameters for call to function osal_memset
   \   0000CE   7C12         MOV       R4,#0x12
   \   0000D0   7D00         MOV       R5,#0x0
   \   0000D2   7900         MOV       R1,#0x0
   \   0000D4   AA..         MOV       R2,?XSP + 0
   \   0000D6   AB..         MOV       R3,?XSP + 1
   \   0000D8   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    633            
    634            return ZNwkUnknownDevice;
   \   0000DB   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   0000DD   02....       LJMP      ?Subroutine2 & 0xFFFF
    635          }
    636          
    637          /******************************************************************************
    638           * @fn          ZDSecMgrEntryInit
    639           *
    640           * @brief       Initialize entry sub module
    641           *
    642           * @param       state - device initialization state
    643           *
    644           * @return      none
    645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    646          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    647          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    648            if (ZDSecMgrEntries == NULL)
   \   000004   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000007   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   00000A   7038         JNZ       ??ZDSecMgrEntryInit_0
    649            {
    650              uint16 index;
    651          
    652              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   00000C                ; Setup parameters for call to function osal_mem_alloc
   \   00000C   7A0F         MOV       R2,#0xf
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   EA           MOV       A,R2
   \   000017   F0           MOVX      @DPTR,A
   \   000018   A3           INC       DPTR
   \   000019   EB           MOV       A,R3
   \   00001A   12....       LCALL     ??Subroutine77_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   00001D   6025         JZ        ??ZDSecMgrEntryInit_0
    653              {
    654                return;
    655              }
    656          
    657              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00001F   7800         MOV       R0,#0x0
   \   000021   7900         MOV       R1,#0x0
    658              {
    659                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000023   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000026   8A82         MOV       DPL,R2
   \   000028   8B83         MOV       DPH,R3
   \   00002A   74FE         MOV       A,#-0x2
   \   00002C   F0           MOVX      @DPTR,A
   \   00002D   A3           INC       DPTR
   \   00002E   04           INC       A
   \   00002F   F0           MOVX      @DPTR,A
    660                
    661                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   000030   8A82         MOV       DPL,R2
   \   000032   8B83         MOV       DPH,R3
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   E4           CLR       A
   \   000037   F0           MOVX      @DPTR,A
   \   000038   A3           INC       DPTR
   \   000039   F0           MOVX      @DPTR,A
    662              }
   \   00003A   08           INC       R0
   \   00003B   E8           MOV       A,R0
   \   00003C   7001         JNZ       ??ZDSecMgrEntryInit_2
   \   00003E   09           INC       R1
   \                     ??ZDSecMgrEntryInit_2:
   \   00003F   12....       LCALL     ?Subroutine30 & 0xFFFF
    663            }
   \                     ??CrossCallReturnLabel_114:
   \   000042   40DF         JC        ??ZDSecMgrEntryInit_1
    664          
    665          #if defined NV_RESTORE
    666            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    667            {
    668              ZDSecMgrRestoreFromNV();
    669            }
    670          #else
    671            (void)state;
    672          #endif
    673          }
   \                     ??ZDSecMgrEntryInit_0:
   \   000044   02....       LJMP      ??Subroutine90_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine77_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000004   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000007   E8           MOV       A,R0
   \   000008   49           ORL       A,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E8           MOV       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   E9           MOV       A,R1
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   75F005       MOV       B,#0x5
   \   000008   A4           MUL       AB
   \   000009   FA           MOV       R2,A
   \   00000A   ACF0         MOV       R4,B
   \   00000C   75F005       MOV       B,#0x5
   \   00000F   EB           MOV       A,R3
   \   000010   A4           MUL       AB
   \   000011   2C           ADD       A,R4
   \   000012   FB           MOV       R3,A
   \   000013   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX      A,@DPTR
   \   000017   2A           ADD       A,R2
   \   000018   FA           MOV       R2,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   3B           ADDC      A,R3
   \   00001C   FB           MOV       R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   C3           CLR       C
   \   000001                REQUIRE ??Subroutine78_0
   \   000001                ; // Fall through to label ??Subroutine78_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine78_0:
   \   000000   9403         SUBB      A,#0x3
   \   000002   E9           MOV       A,R1
   \   000003   9400         SUBB      A,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET
    674          
    675          /******************************************************************************
    676           * @fn          ZDSecMgrEntryLookup
    677           *
    678           * @brief       Lookup entry index using specified NWK address.
    679           *
    680           * @param       nwkAddr - [in] NWK address
    681           * @param       entry   - [out] valid entry
    682           *
    683           * @return      ZStatus_t
    684           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    685          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    686          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    687            ZStatus_t      status;
    688            uint16         index;
    689            AddrMgrEntry_t addrMgrEntry;
    690          
    691          
    692            // initialize results
    693            *entry = NULL;
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   12....       LCALL     ?Subroutine12 & 0xFFFF
    694            status = ZNwkUnknownDevice;
    695          
    696            // verify data is available
    697            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_109:
   \   000015   6059         JZ        ??ZDSecMgrEntryLookup_0
    698            {
    699              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV       DPL,?XSP + 0
   \   00001A   85..83       MOV       DPH,?XSP + 1
   \   00001D   7402         MOV       A,#0x2
   \   00001F   F0           MOVX      @DPTR,A
    700              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC       A
   \   000021   12....       LCALL     ?XSTACK_DISP0_8
   \   000024   EA           MOV       A,R2
   \   000025   F0           MOVX      @DPTR,A
   \   000026   A3           INC       DPTR
   \   000027   EB           MOV       A,R3
   \   000028   12....       LCALL     ??Subroutine98_0 & 0xFFFF
    701          
    702              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_243:
   \   00002B   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00002E   E9           MOV       A,R1
   \   00002F   6401         XRL       A,#0x1
   \   000031   703D         JNZ       ??ZDSecMgrEntryLookup_0
    703              {
    704                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000033   7800         MOV       R0,#0x0
   \   000035   7900         MOV       R1,#0x0
    705                {
    706                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000037   740B         MOV       A,#0xb
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   E0           MOVX      A,@DPTR
   \   00003D   FC           MOV       R4,A
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   FD           MOV       R5,A
   \   000041   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000044   6C           XRL       A,R4
   \   000045   7003         JNZ       ??ZDSecMgrEntryLookup_2
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   6D           XRL       A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   00004A   701A         JNZ       ??ZDSecMgrEntryLookup_3
    707                  {
    708                    // return successful results
    709                    *entry = &ZDSecMgrEntries[index];
   \   00004C   E8           MOV       A,R0
   \   00004D   75F005       MOV       B,#0x5
   \   000050   A4           MUL       AB
   \   000051   F8           MOV       R0,A
   \   000052   AAF0         MOV       R2,B
   \   000054   75F005       MOV       B,#0x5
   \   000057   E9           MOV       A,R1
   \   000058   A4           MUL       AB
   \   000059   2A           ADD       A,R2
   \   00005A   F9           MOV       R1,A
   \   00005B   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00005E   12....       LCALL     ?Subroutine68 & 0xFFFF
    710                    status = ZSuccess;
    711          
    712                    // break from loop
    713                    return status;
    714                  }
    715                }
   \                     ??CrossCallReturnLabel_89:
   \   000061   12....       LCALL     ??Subroutine74_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000064   800C         SJMP      ??ZDSecMgrEntryLookup_4
   \                     ??ZDSecMgrEntryLookup_3:
   \   000066   08           INC       R0
   \   000067   E8           MOV       A,R0
   \   000068   7001         JNZ       ??ZDSecMgrEntryLookup_5
   \   00006A   09           INC       R1
   \                     ??ZDSecMgrEntryLookup_5:
   \   00006B   12....       LCALL     ?Subroutine30 & 0xFFFF
    716              }
    717            }
   \                     ??CrossCallReturnLabel_115:
   \   00006E   40C7         JC        ??ZDSecMgrEntryLookup_1
    718          
    719            return status;
   \                     ??ZDSecMgrEntryLookup_0:
   \   000070   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   000072   02....       LJMP      ?Subroutine7 & 0xFFFF
    720          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine77_0
   \   000003                ; // Fall through to label ??Subroutine77_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   E8           MOV       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   E9           MOV       A,R1
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   75F005       MOV       B,#0x5
   \   000008   A4           MUL       AB
   \   000009   FA           MOV       R2,A
   \   00000A   85F0..       MOV       ?V0,B
   \   00000D   75F005       MOV       B,#0x5
   \   000010   EB           MOV       A,R3
   \   000011   A4           MUL       AB
   \   000012   25..         ADD       A,?V0
   \   000014   FB           MOV       R3,A
   \   000015   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000018   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   F8           MOV       R0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   39           ADDC      A,R1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   F5..         MOV       ?V0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   3B           ADDC      A,R3
   \   000007   85..82       MOV       DPL,?V0
   \   00000A   F583         MOV       DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001   AA..         MOV       R2,?XSP + 0
   \   000003   AB..         MOV       R3,?XSP + 1
   \   000005   22           RET
    721          
    722          /******************************************************************************
    723           * @fn          ZDSecMgrEntryLookupAMI
    724           *
    725           * @brief       Lookup entry using specified address index
    726           *
    727           * @param       ami   - [in] Address Manager index
    728           * @param       entry - [out] valid entry
    729           *
    730           * @return      ZStatus_t
    731           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    732          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    733          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    734            ZStatus_t status;
    735            uint16    index;
    736          
    737          
    738            // initialize results
    739            *entry = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   12....       LCALL     ?Subroutine12 & 0xFFFF
    740            status = ZNwkUnknownDevice;
    741          
    742            // verify data is available
    743            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_110:
   \   000010   6033         JZ        ??ZDSecMgrEntryLookupAMI_0
    744            {
    745              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000012   7800         MOV       R0,#0x0
   \   000014   7900         MOV       R1,#0x0
    746              {
    747                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000016   12....       LCALL     ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000019   6E           XRL       A,R6
   \   00001A   7003         JNZ       ??ZDSecMgrEntryLookupAMI_2
   \   00001C   A3           INC       DPTR
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   6F           XRL       A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   00001F   701A         JNZ       ??ZDSecMgrEntryLookupAMI_3
    748                {
    749                  // return successful results
    750                  *entry = &ZDSecMgrEntries[index];
   \   000021   E8           MOV       A,R0
   \   000022   75F005       MOV       B,#0x5
   \   000025   A4           MUL       AB
   \   000026   F8           MOV       R0,A
   \   000027   AAF0         MOV       R2,B
   \   000029   75F005       MOV       B,#0x5
   \   00002C   E9           MOV       A,R1
   \   00002D   A4           MUL       AB
   \   00002E   2A           ADD       A,R2
   \   00002F   F9           MOV       R1,A
   \   000030   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000033   12....       LCALL     ?Subroutine44 & 0xFFFF
    751                  status = ZSuccess;
    752          
    753                  // break from loop
    754                  return status;
    755                }
    756              }
   \                     ??CrossCallReturnLabel_43:
   \   000036   12....       LCALL     ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000039   800C         SJMP      ??ZDSecMgrEntryLookupAMI_4
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   00003B   08           INC       R0
   \   00003C   E8           MOV       A,R0
   \   00003D   7001         JNZ       ??ZDSecMgrEntryLookupAMI_5
   \   00003F   09           INC       R1
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   000040   12....       LCALL     ?Subroutine30 & 0xFFFF
    757            }
   \                     ??CrossCallReturnLabel_116:
   \   000043   40D1         JC        ??ZDSecMgrEntryLookupAMI_1
    758          
    759            return status;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000045   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000047   02....       LJMP      ??Subroutine93_0 & 0xFFFF
    760          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000003   F9           MOV       R1,A
   \   000004   8C82         MOV       DPL,R4
   \   000006   8D83         MOV       DPH,R5
   \   000008   22           RET
    761          
    762          /******************************************************************************
    763           * @fn          ZDSecMgrEntryLookupExt
    764           *
    765           * @brief       Lookup entry index using specified EXT address.
    766           *
    767           * @param       extAddr - [in] EXT address
    768           * @param       entry   - [out] valid entry
    769           *
    770           * @return      ZStatus_t
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    773          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    774            ZStatus_t status;
    775            uint16    ami;
    776          
    777          
    778            // initialize results
    779            *entry = NULL;
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   E4           CLR       A
   \   000013   F0           MOVX      @DPTR,A
   \   000014   A3           INC       DPTR
   \   000015   F0           MOVX      @DPTR,A
    780            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV       ?V0,#-0x38
    781          
    782            // lookup address index
    783            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   AC..         MOV       R4,?XSP + 0
   \   00001B   AD..         MOV       R5,?XSP + 1
   \   00001D   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV       A,R1
   \   000021   7009         JNZ       ??ZDSecMgrEntryLookupExt_0
    784            {
    785              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000023                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000023   12....       LCALL     ?Subroutine33 & 0xFFFF
    786            }
   \                     ??CrossCallReturnLabel_190:
   \   000026   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000029   E9           MOV       A,R1
   \   00002A   F5..         MOV       ?V0,A
    787          
    788            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00002C   02....       LJMP      ?Subroutine1 & 0xFFFF
    789          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   EE           MOV       A,R6
   \   000001   FC           MOV       R4,A
   \   000002   EF           MOV       A,R7
   \   000003   FD           MOV       R5,A
   \   000004                REQUIRE ??Subroutine87_0
   \   000004                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine88_0
   \   000006                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   A9..         MOV       R1,?V0
   \   000002                REQUIRE ??Subroutine91_0
   \   000002                ; // Fall through to label ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine92_0
   \   000002                ; // Fall through to label ??Subroutine92_0
    790          
    791          /******************************************************************************
    792           * @fn          ZDSecMgrEntryLookupExtGetIndex
    793           *
    794           * @brief       Lookup entry index using specified EXT address.
    795           *
    796           * @param       extAddr - [in] EXT address
    797           * @param       entryIndex - [out] valid index to the entry table
    798           *
    799           * @return      ZStatus_t
    800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    801          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    802          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
    803            ZStatus_t status;
    804            uint16    ami;
    805            uint16    index;
    806          
    807            // initialize results
    808            status = ZNwkUnknownDevice;
    809          
    810            // lookup address index
    811            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   7058         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_0
    812            {  
    813              // verify data is available
    814              if ( ZDSecMgrEntries != NULL )
   \   000018   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00001B   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00001E   6050         JZ        ??ZDSecMgrEntryLookupExtGetIndex_0
    815              {
    816                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7800         MOV       R0,#0x0
   \   000022   7900         MOV       R1,#0x0
    817                {
    818                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000024   E8           MOV       A,R0
   \   000025   FA           MOV       R2,A
   \   000026   E9           MOV       A,R1
   \   000027   FB           MOV       R3,A
   \   000028   EA           MOV       A,R2
   \   000029   75F005       MOV       B,#0x5
   \   00002C   A4           MUL       AB
   \   00002D   FA           MOV       R2,A
   \   00002E   ACF0         MOV       R4,B
   \   000030   75F005       MOV       B,#0x5
   \   000033   EB           MOV       A,R3
   \   000034   A4           MUL       AB
   \   000035   2C           ADD       A,R4
   \   000036   FB           MOV       R3,A
   \   000037   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00003A   12....       LCALL     ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00003D   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000040   85..82       MOV       DPL,?XSP + 0
   \   000043   85..83       MOV       DPH,?XSP + 1
   \   000046   E0           MOVX      A,@DPTR
   \   000047   6A           XRL       A,R2
   \   000048   7003         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_2
   \   00004A   A3           INC       DPTR
   \   00004B   E0           MOVX      A,@DPTR
   \   00004C   6B           XRL       A,R3
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00004D   7017         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_3
    819                  {
    820                    // return successful results
    821                    *entry = &ZDSecMgrEntries[index];
   \   00004F   12....       LCALL     ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000052   8E82         MOV       DPL,R6
   \   000054   8F83         MOV       DPH,R7
   \   000056   12....       LCALL     ??Subroutine95_0 & 0xFFFF
    822                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_209:
   \   000059   740B         MOV       A,#0xb
   \   00005B   12....       LCALL     ?XSTACK_DISP0_8
   \   00005E   12....       LCALL     ?Subroutine51 & 0xFFFF
    823                    status = ZSuccess;
    824                    
    825                    return status;
    826                  }
    827                }
   \                     ??CrossCallReturnLabel_55:
   \   000061   12....       LCALL     ??Subroutine75_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000064   800C         SJMP      ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   000066   08           INC       R0
   \   000067   E8           MOV       A,R0
   \   000068   7001         JNZ       ??ZDSecMgrEntryLookupExtGetIndex_5
   \   00006A   09           INC       R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   00006B   12....       LCALL     ?Subroutine30 & 0xFFFF
    828              }
    829            }
   \                     ??CrossCallReturnLabel_117:
   \   00006E   40B4         JC        ??ZDSecMgrEntryLookupExtGetIndex_1
    830          
    831            return status;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   000070   79C8         MOV       R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000072   02....       LJMP      ??Subroutine91_0 & 0xFFFF
    832          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   2A           ADD       A,R2
   \   000002   FC           MOV       R4,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3B           ADDC      A,R3
   \   000006   8C82         MOV       DPL,R4
   \   000008   F583         MOV       DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8A82         MOV       DPL,R2
   \   000008   22           RET
    833          
    834          /******************************************************************************
    835           * @fn          ZDSecMgrEntryFree
    836           *
    837           * @brief       Free entry.
    838           *
    839           * @param       entry - [in] valid entry
    840           *
    841           * @return      ZStatus_t
    842           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    843          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    844          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
    845            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    846            
    847            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A18         MOV       R2,#0x18
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV       ?V2,R2
   \   000012   8B..         MOV       ?V3,R3
    848          
    849            if (pApsLinkKey != NULL)
   \   000014   EA           MOV       A,R2
   \   000015   45..         ORL       A,?V3
   \   000017   6044         JZ        ??ZDSecMgrEntryFree_0
    850            {
    851              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000019                ; Setup parameters for call to function osal_memset
   \   000019   7C18         MOV       R4,#0x18
   \   00001B   7D00         MOV       R5,#0x0
   \   00001D   7900         MOV       R1,#0x0
   \   00001F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    852          
    853              // Clear the APS Link key in NV
    854              osal_nv_write( entry->keyNvId, 0,
    855                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000022   E5..         MOV       A,?V0
   \   000024   2402         ADD       A,#0x2
   \   000026   FE           MOV       R6,A
   \   000027   E4           CLR       A
   \   000028   35..         ADDC      A,?V1
   \   00002A   FF           MOV       R7,A
   \   00002B                ; Setup parameters for call to function osal_nv_write
   \   00002B   78..         MOV       R0,#?V2
   \   00002D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000030   75..18       MOV       ?V4,#0x18
   \   000033   75..00       MOV       ?V5,#0x0
   \   000036   78..         MOV       R0,#?V4
   \   000038   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003B   7C00         MOV       R4,#0x0
   \   00003D   7D00         MOV       R5,#0x0
   \   00003F   8E82         MOV       DPL,R6
   \   000041   8F83         MOV       DPH,R7
   \   000043   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000046   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000049   7404         MOV       A,#0x4
   \   00004B   12....       LCALL     ?DEALLOC_XSTACK8
    856          
    857              // set entry to invalid Key
    858              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00004E   8E82         MOV       DPL,R6
   \   000050   8F83         MOV       DPH,R7
   \   000052   E4           CLR       A
   \   000053   F0           MOVX      @DPTR,A
   \   000054   A3           INC       DPTR
   \   000055   F0           MOVX      @DPTR,A
    859              
    860              osal_mem_free(pApsLinkKey);
   \   000056                ; Setup parameters for call to function osal_mem_free
   \   000056   AA..         MOV       R2,?V2
   \   000058   AB..         MOV       R3,?V3
   \   00005A   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    861            }
    862          
    863            // marking the entry as INVALID_NODE_ADDR
    864            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   00005D   85..82       MOV       DPL,?V0
   \   000060   85..83       MOV       DPH,?V1
   \   000063   74FE         MOV       A,#-0x2
   \   000065   F0           MOVX      @DPTR,A
   \   000066   A3           INC       DPTR
   \   000067   04           INC       A
   \   000068   F0           MOVX      @DPTR,A
    865          }
   \   000069   80..         SJMP      ??Subroutine79_0
    866          
    867          /******************************************************************************
    868           * @fn          ZDSecMgrEntryNew
    869           *
    870           * @brief       Get a new entry.
    871           *
    872           * @param       entry - [out] valid entry
    873           *
    874           * @return      ZStatus_t
    875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    876          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    877          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    878            ZStatus_t status;
    879            uint16    index;
    880          
    881          
    882            // initialize results
    883            *entry = NULL;
   \   000005   8A82         MOV       DPL,R2
   \   000007   8B83         MOV       DPH,R3
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   F0           MOVX      @DPTR,A
    884            status = ZNwkUnknownDevice;
   \   00000D   7EC8         MOV       R6,#-0x38
    885          
    886            // verify data is available
    887            if ( ZDSecMgrEntries != NULL )
   \   00000F   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000012   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000015   6072         JZ        ??ZDSecMgrEntryNew_0
    888            {
    889              // find available entry
    890              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000017   7800         MOV       R0,#0x0
   \   000019   7900         MOV       R1,#0x0
    891              {
    892                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   00001B   E8           MOV       A,R0
   \   00001C   FC           MOV       R4,A
   \   00001D   E9           MOV       A,R1
   \   00001E   FD           MOV       R5,A
   \   00001F   EC           MOV       A,R4
   \   000020   75F005       MOV       B,#0x5
   \   000023   A4           MUL       AB
   \   000024   FC           MOV       R4,A
   \   000025   AFF0         MOV       R7,B
   \   000027   75F005       MOV       B,#0x5
   \   00002A   ED           MOV       A,R5
   \   00002B   A4           MUL       AB
   \   00002C   2F           ADD       A,R7
   \   00002D   FD           MOV       R5,A
   \   00002E   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000031   E0           MOVX      A,@DPTR
   \   000032   2C           ADD       A,R4
   \   000033   FF           MOV       R7,A
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   3D           ADDC      A,R5
   \   000037   8F82         MOV       DPL,R7
   \   000039   F583         MOV       DPH,A
   \   00003B   E0           MOVX      A,@DPTR
   \   00003C   64FE         XRL       A,#0xfe
   \   00003E   7003         JNZ       ??ZDSecMgrEntryNew_2
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   F4           CPL       A
   \                     ??ZDSecMgrEntryNew_2:
   \   000043   703A         JNZ       ??ZDSecMgrEntryNew_3
    893                {
    894                  // return successful result
    895                  *entry = &ZDSecMgrEntries[index];
   \   000045   E8           MOV       A,R0
   \   000046   75F005       MOV       B,#0x5
   \   000049   A4           MUL       AB
   \   00004A   F8           MOV       R0,A
   \   00004B   ACF0         MOV       R4,B
   \   00004D   75F005       MOV       B,#0x5
   \   000050   E9           MOV       A,R1
   \   000051   A4           MUL       AB
   \   000052   2C           ADD       A,R4
   \   000053   F9           MOV       R1,A
   \   000054   90....       MOV       DPTR,#ZDSecMgrEntries
   \   000057   E0           MOVX      A,@DPTR
   \   000058   28           ADD       A,R0
   \   000059   FC           MOV       R4,A
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   39           ADDC      A,R1
   \   00005D   FD           MOV       R5,A
   \   00005E   8A82         MOV       DPL,R2
   \   000060   8B83         MOV       DPH,R3
   \   000062   EC           MOV       A,R4
   \   000063   F0           MOVX      @DPTR,A
   \   000064   A3           INC       DPTR
   \   000065   ED           MOV       A,R5
   \   000066   F0           MOVX      @DPTR,A
    896                  status = ZSuccess;
   \   000067   7E00         MOV       R6,#0x0
    897          
    898                  // Set the authentication option to default
    899                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000069   90....       MOV       DPTR,#ZDSecMgrEntries
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   28           ADD       A,R0
   \   00006E   FC           MOV       R4,A
   \   00006F   A3           INC       DPTR
   \   000070   E0           MOVX      A,@DPTR
   \   000071   39           ADDC      A,R1
   \   000072   8C82         MOV       DPL,R4
   \   000074   F583         MOV       DPH,A
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   A3           INC       DPTR
   \   00007A   E4           CLR       A
   \   00007B   F0           MOVX      @DPTR,A
    900          
    901                  // break from loop
    902                  index = ZDSECMGR_ENTRY_MAX;
   \   00007C   7803         MOV       R0,#0x3
   \   00007E   F9           MOV       R1,A
    903                }
    904              }
   \                     ??ZDSecMgrEntryNew_3:
   \   00007F   08           INC       R0
   \   000080   E8           MOV       A,R0
   \   000081   7001         JNZ       ??ZDSecMgrEntryNew_4
   \   000083   09           INC       R1
   \                     ??ZDSecMgrEntryNew_4:
   \   000084   12....       LCALL     ?Subroutine30 & 0xFFFF
    905            }
   \                     ??CrossCallReturnLabel_118:
   \   000087   4092         JC        ??ZDSecMgrEntryNew_1
    906          
    907            return status;
   \                     ??ZDSecMgrEntryNew_0:
   \   000089   EE           MOV       A,R6
   \   00008A   F9           MOV       R1,A
   \   00008B   02....       LJMP      ??Subroutine93_0 & 0xFFFF
    908          }
    909          
    910          /******************************************************************************
    911           * @fn          ZDSecMgrCtrlInit
    912           *
    913           * @brief       Initialize control sub module
    914           *
    915           * @param       none
    916           *
    917           * @return      none
    918           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    919          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    920          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    921            uint16 size;
    922            uint16 index;
    923          
    924            // allocate entry data
    925            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    926          
    927            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV       R2,#0x15
   \   000006   7B00         MOV       R3,#0x0
   \   000008   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000B   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL     ??Subroutine95_0 & 0xFFFF
    928          
    929            // initialize data
    930            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_210:
   \   000011   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000017   602E         JZ        ??ZDSecMgrCtrlInit_0
    931            {
    932              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV       R0,#0x0
   \   00001B   7900         MOV       R1,#0x0
    933              {
    934                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_1:
   \   00001D   E8           MOV       A,R0
   \   00001E   FA           MOV       R2,A
   \   00001F   E9           MOV       A,R1
   \   000020   FB           MOV       R3,A
   \   000021   EA           MOV       A,R2
   \   000022   75F007       MOV       B,#0x7
   \   000025   A4           MUL       AB
   \   000026   FA           MOV       R2,A
   \   000027   ACF0         MOV       R4,B
   \   000029   75F007       MOV       B,#0x7
   \   00002C   EB           MOV       A,R3
   \   00002D   A4           MUL       AB
   \   00002E   2C           ADD       A,R4
   \   00002F   FB           MOV       R3,A
   \   000030   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000033   12....       LCALL     ?Subroutine47 & 0xFFFF
    935              }
   \                     ??CrossCallReturnLabel_48:
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   E4           CLR       A
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   08           INC       R0
   \   00003E   E8           MOV       A,R0
   \   00003F   7001         JNZ       ??ZDSecMgrCtrlInit_2
   \   000041   09           INC       R1
   \                     ??ZDSecMgrCtrlInit_2:
   \   000042   12....       LCALL     ?Subroutine30 & 0xFFFF
    936            }
   \                     ??CrossCallReturnLabel_119:
   \   000045   40D6         JC        ??ZDSecMgrCtrlInit_1
    937          }
   \                     ??ZDSecMgrCtrlInit_0:
   \   000047   02....       LJMP      ??Subroutine90_0 & 0xFFFF
    938          
    939          /******************************************************************************
    940           * @fn          ZDSecMgrCtrlRelease
    941           *
    942           * @brief       Release control data.
    943           *
    944           * @param       ctrl - [in] valid control data
    945           *
    946           * @return      none
    947           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    948          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    949          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    950            // should always be enough entry control data
    951            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
    952          }
   \   00000F   02....       LJMP      ??Subroutine90_0 & 0xFFFF
    953          
    954          /******************************************************************************
    955           * @fn          ZDSecMgrCtrlLookup
    956           *
    957           * @brief       Lookup control data.
    958           *
    959           * @param       entry - [in] valid entry data
    960           * @param       ctrl  - [out] control data - NULL if not found
    961           *
    962           * @return      none
    963           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    964          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    965          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    966            uint16 index;
    967          
    968          
    969            // initialize search results
    970            *ctrl = NULL;
   \   000009   8C82         MOV       DPL,R4
   \   00000B   8D83         MOV       DPH,R5
   \   00000D   E4           CLR       A
   \   00000E   F0           MOVX      @DPTR,A
   \   00000F   A3           INC       DPTR
   \   000010   F0           MOVX      @DPTR,A
    971          
    972            // verify data is available
    973            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000014   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000017   6043         JZ        ??ZDSecMgrCtrlLookup_0
    974            {
    975              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7800         MOV       R0,#0x0
   \   00001B   7900         MOV       R1,#0x0
    976              {
    977                // make sure control data is in use
    978                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00001D   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   602A         JZ        ??ZDSecMgrCtrlLookup_2
    979                {
    980                  // check for entry match
    981                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000028   12....       LCALL     ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   00002B   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   00002E   EE           MOV       A,R6
   \   00002F   6A           XRL       A,R2
   \   000030   7002         JNZ       ??ZDSecMgrCtrlLookup_3
   \   000032   EF           MOV       A,R7
   \   000033   6B           XRL       A,R3
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000034   701C         JNZ       ??ZDSecMgrCtrlLookup_2
    982                  {
    983                    // return this control data
    984                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000036   E8           MOV       A,R0
   \   000037   75F007       MOV       B,#0x7
   \   00003A   A4           MUL       AB
   \   00003B   F8           MOV       R0,A
   \   00003C   AAF0         MOV       R2,B
   \   00003E   75F007       MOV       B,#0x7
   \   000041   E9           MOV       A,R1
   \   000042   A4           MUL       AB
   \   000043   2A           ADD       A,R2
   \   000044   F9           MOV       R1,A
   \   000045   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000048   12....       LCALL     ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   00004B   12....       LCALL     ??Subroutine84_0 & 0xFFFF
    985          
    986                    // break from loop
    987                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_137:
   \   00004E   7803         MOV       R0,#0x3
   \   000050   7900         MOV       R1,#0x0
    988                  }
    989                }
    990              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   000052   08           INC       R0
   \   000053   E8           MOV       A,R0
   \   000054   7001         JNZ       ??ZDSecMgrCtrlLookup_4
   \   000056   09           INC       R1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000057   12....       LCALL     ?Subroutine30 & 0xFFFF
    991            }
   \                     ??CrossCallReturnLabel_120:
   \   00005A   40C1         JC        ??ZDSecMgrCtrlLookup_1
    992          }
   \                     ??ZDSecMgrCtrlLookup_0:
   \   00005C   02....       LJMP      ??Subroutine93_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E8           MOV       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   E9           MOV       A,R1
   \   000003   FB           MOV       R3,A
   \   000004   EA           MOV       A,R2
   \   000005   75F007       MOV       B,#0x7
   \   000008   A4           MUL       AB
   \   000009   FA           MOV       R2,A
   \   00000A   85F0..       MOV       ?V0,B
   \   00000D   75F007       MOV       B,#0x7
   \   000010   EB           MOV       A,R3
   \   000011   A4           MUL       AB
   \   000012   25..         ADD       A,?V0
   \   000014   FB           MOV       R3,A
   \   000015   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000018   12....       LCALL     ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00001B   22           RET
    993          
    994          /******************************************************************************
    995           * @fn          ZDSecMgrCtrlSet
    996           *
    997           * @brief       Set control data.
    998           *
    999           * @param       device - [in] valid device data
   1000           * @param       entry  - [in] valid entry data
   1001           * @param       ctrl   - [in] valid control data
   1002           *
   1003           * @return      none
   1004           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1005          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1006                                ZDSecMgrEntry_t*  entry,
   1007                                ZDSecMgrCtrl_t*   ctrl )
   1008          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV       A,#0x9
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   1009            // set control date
   1010            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_272:
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   8B83         MOV       DPH,R3
   \   000011   A3           INC       DPTR
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   A3           INC       DPTR
   \   000015   E0           MOVX      A,@DPTR
   \   000016   FE           MOV       R6,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   FF           MOV       R7,A
   \   00001A   8882         MOV       DPL,R0
   \   00001C   8983         MOV       DPH,R1
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   EE           MOV       A,R6
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   EF           MOV       A,R7
   \   000024   12....       LCALL     ?Subroutine59 & 0xFFFF
   1011            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_74:
   \   000027   E0           MOVX      A,@DPTR
   \   000028   8882         MOV       DPL,R0
   \   00002A   8983         MOV       DPH,R1
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   12....       LCALL     ?Subroutine61 & 0xFFFF
   1012            ctrl->entry      = entry;
   \                     ??CrossCallReturnLabel_76:
   \   000033   EC           MOV       A,R4
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   ED           MOV       A,R5
   \   000037   12....       LCALL     ?Subroutine23 & 0xFFFF
   1013            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \                     ??CrossCallReturnLabel_17:
   \   00003A   7401         MOV       A,#0x1
   \   00003C   12....       LCALL     ?Subroutine23 & 0xFFFF
   1014            ctrl->cntr       = 0;
   \                     ??CrossCallReturnLabel_18:
   \   00003F   A3           INC       DPTR
   \   000040   E4           CLR       A
   \   000041   12....       LCALL     ?Subroutine20 & 0xFFFF
   1015          
   1016            // set device pointer
   1017            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_13:
   \   000044   A3           INC       DPTR
   \   000045   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1018          }
   \                     ??CrossCallReturnLabel_138:
   \   000048   02....       LJMP      ??Subroutine93_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   8882         MOV       DPL,R0
   \   000003   8983         MOV       DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL     ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000003   A3           INC       DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000003   22           RET
   1019          
   1020          /******************************************************************************
   1021           * @fn          ZDSecMgrCtrlAdd
   1022           *
   1023           * @brief       Add control data.
   1024           *
   1025           * @param       device - [in] valid device data
   1026           * @param       entry  - [in] valid entry data
   1027           *
   1028           * @return      ZStatus_t
   1029           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1030          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1031          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   EC           MOV       A,R4
   \   00000A   FE           MOV       R6,A
   \   00000B   ED           MOV       A,R5
   \   00000C   FF           MOV       R7,A
   1032            ZStatus_t status;
   1033            uint16    index;
   1034          
   1035          
   1036            // initialize results
   1037            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV       R1,#-0x38
   1038          
   1039            // verify data is available
   1040            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000012   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000015   EA           MOV       A,R2
   \   000016   4B           ORL       A,R3
   \   000017   606E         JZ        ??ZDSecMgrCtrlAdd_0
   1041            {
   1042              // look for an empty slot
   1043              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7A00         MOV       R2,#0x0
   \   00001B   7B00         MOV       R3,#0x0
   1044              {
   1045                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00001D   EA           MOV       A,R2
   \   00001E   FC           MOV       R4,A
   \   00001F   EB           MOV       A,R3
   \   000020   FD           MOV       R5,A
   \   000021   EC           MOV       A,R4
   \   000022   75F007       MOV       B,#0x7
   \   000025   A4           MUL       AB
   \   000026   FC           MOV       R4,A
   \   000027   A8F0         MOV       R0,B
   \   000029   75F007       MOV       B,#0x7
   \   00002C   ED           MOV       A,R5
   \   00002D   A4           MUL       AB
   \   00002E   28           ADD       A,R0
   \   00002F   FD           MOV       R5,A
   \   000030   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000033   E0           MOVX      A,@DPTR
   \   000034   2C           ADD       A,R4
   \   000035   F8           MOV       R0,A
   \   000036   A3           INC       DPTR
   \   000037   E0           MOVX      A,@DPTR
   \   000038   3D           ADDC      A,R5
   \   000039   8882         MOV       DPL,R0
   \   00003B   F583         MOV       DPH,A
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   A3           INC       DPTR
   \   000040   A3           INC       DPTR
   \   000041   A3           INC       DPTR
   \   000042   E0           MOVX      A,@DPTR
   \   000043   7035         JNZ       ??ZDSecMgrCtrlAdd_2
   1046                {
   1047                  // return successful results
   1048                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000045                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000045   EA           MOV       A,R2
   \   000046   75F007       MOV       B,#0x7
   \   000049   A4           MUL       AB
   \   00004A   A8F0         MOV       R0,B
   \   00004C   75F007       MOV       B,#0x7
   \   00004F   EB           MOV       A,R3
   \   000050   A4           MUL       AB
   \   000051   28           ADD       A,R0
   \   000052   FB           MOV       R3,A
   \   000053   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000056   E0           MOVX      A,@DPTR
   \   000057   2C           ADD       A,R4
   \   000058   F5..         MOV       ?V2,A
   \   00005A   A3           INC       DPTR
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   3B           ADDC      A,R3
   \   00005D   F5..         MOV       ?V3,A
   \   00005F   78..         MOV       R0,#?V2
   \   000061   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000064   EE           MOV       A,R6
   \   000065   FC           MOV       R4,A
   \   000066   EF           MOV       A,R7
   \   000067   FD           MOV       R5,A
   \   000068   AA..         MOV       R2,?V0
   \   00006A   AB..         MOV       R3,?V1
   \   00006C   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   00006F   7402         MOV       A,#0x2
   \   000071   12....       LCALL     ?DEALLOC_XSTACK8
   1049          
   1050                  status = ZSuccess;
   \   000074   7900         MOV       R1,#0x0
   1051          
   1052                  // break from loop
   1053                  index = ZDSECMGR_CTRL_MAX;
   \   000076   7A03         MOV       R2,#0x3
   \   000078   7B00         MOV       R3,#0x0
   1054                }
   1055              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00007A   0A           INC       R2
   \   00007B   EA           MOV       A,R2
   \   00007C   7001         JNZ       ??ZDSecMgrCtrlAdd_3
   \   00007E   0B           INC       R3
   \                     ??ZDSecMgrCtrlAdd_3:
   \   00007F   C3           CLR       C
   \   000080   9403         SUBB      A,#0x3
   \   000082   EB           MOV       A,R3
   \   000083   9400         SUBB      A,#0x0
   \   000085   4096         JC        ??ZDSecMgrCtrlAdd_1
   1056            }
   1057          
   1058            return status;
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000087   02....       LJMP      ??Subroutine103_0 & 0xFFFF
   1059          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
   1060          
   1061          /******************************************************************************
   1062           * @fn          ZDSecMgrCtrlTerm
   1063           *
   1064           * @brief       Terminate device control.
   1065           *
   1066           * @param       entry - [in] valid entry data
   1067           *
   1068           * @return      none
   1069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1070          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1071          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   1072            ZDSecMgrCtrl_t* ctrl;
   1073          
   1074            // remove device from control data
   1075            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   AC..         MOV       R4,?XSP + 0
   \   00000B   AD..         MOV       R5,?XSP + 1
   \   00000D   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1076          
   1077            if ( ctrl != NULL )
   \   000010   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000013   6005         JZ        ??ZDSecMgrCtrlTerm_0
   1078            {
   1079              ZDSecMgrCtrlRelease ( ctrl );
   \   000015   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000018   E4           CLR       A
   \   000019   F0           MOVX      @DPTR,A
   1080            }
   1081          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00001A   7402         MOV       A,#0x2
   \   00001C   80..         SJMP      ??Subroutine81_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine81_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine90_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine96_0
   \   000006                ; // Fall through to label ??Subroutine96_0
   1082          
   1083          /******************************************************************************
   1084           * @fn          ZDSecMgrCtrlReset
   1085           *
   1086           * @brief       Reset control data.
   1087           *
   1088           * @param       device - [in] valid device data
   1089           * @param       entry  - [in] valid entry data
   1090           *
   1091           * @return      ZStatus_t
   1092           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1093          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1094          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1095            ZStatus_t       status;
   1096            ZDSecMgrCtrl_t* ctrl;
   1097          
   1098          
   1099            // initialize results
   1100            status = ZNwkUnknownDevice;
   1101          
   1102            // look for a match for the entry
   1103            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   EE           MOV       A,R6
   \   000017   FA           MOV       R2,A
   \   000018   EF           MOV       A,R7
   \   000019   FB           MOV       R3,A
   \   00001A   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1104          
   1105            if ( ctrl != NULL )
   \   00001D   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000020   601D         JZ        ??ZDSecMgrCtrlReset_0
   1106            {
   1107              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000022                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000022   85..82       MOV       DPL,?XSP + 0
   \   000025   85..83       MOV       DPH,?XSP + 1
   \   000028   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00002B   EE           MOV       A,R6
   \   00002C   FC           MOV       R4,A
   \   00002D   EF           MOV       A,R7
   \   00002E   FD           MOV       R5,A
   \   00002F   AA..         MOV       R2,?V0
   \   000031   AB..         MOV       R3,?V1
   \   000033   12....       LCALL     `??ZDSecMgrCtrlSet::?relay`; Banked call to: ZDSecMgrCtrlSet
   \   000036   7402         MOV       A,#0x2
   \   000038   12....       LCALL     ?DEALLOC_XSTACK8
   1108          
   1109              status = ZSuccess;
   \   00003B   7900         MOV       R1,#0x0
   \   00003D   800D         SJMP      ??ZDSecMgrCtrlReset_1
   1110            }
   1111            else
   1112            {
   1113              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   00003F                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   00003F   EE           MOV       A,R6
   \   000040   FC           MOV       R4,A
   \   000041   EF           MOV       A,R7
   \   000042   FD           MOV       R5,A
   \   000043   AA..         MOV       R2,?V0
   \   000045   AB..         MOV       R3,?V1
   \   000047   12....       LCALL     `??ZDSecMgrCtrlAdd::?relay`; Banked call to: ZDSecMgrCtrlAdd
   \   00004A   E9           MOV       A,R1
   \   00004B   F9           MOV       R1,A
   1114            }
   1115          
   1116            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00004C   02....       LJMP      ?Subroutine0 & 0xFFFF
   1117          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7402         MOV       A,#0x2
   \   000002                REQUIRE ??Subroutine85_0
   \   000002                ; // Fall through to label ??Subroutine85_0
   1118          
   1119          /******************************************************************************
   1120           * @fn          ZDSecMgrMasterKeyLoad
   1121           *
   1122           * @brief       Load the MASTER key for device with specified EXT
   1123           *              address.
   1124           *
   1125           * @param       extAddr - [in] EXT address of device
   1126           * @param       key     - [in] MASTER key shared with device
   1127           *
   1128           * @return      ZStatus_t
   1129           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1130          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1131          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V0,R4
   \   00000C   8D..         MOV       ?V1,R5
   1132            ZStatus_t status;
   1133            uint16 ami;
   1134            uint16 keyNvId;
   1135          
   1136          
   1137            // set status based on policy
   1138            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   FE           MOV       R6,A
   1139          
   1140            if ( status == ZSuccess )
   \   000017   7040         JNZ       ??ZDSecMgrMasterKeyLoad_0
   1141            {
   1142              // get the address NV ID
   1143              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000019   7402         MOV       A,#0x2
   \   00001B   12....       LCALL     ?XSTACK_DISP102_8
   \   00001E   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000021   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000024   E9           MOV       A,R1
   \   000025   7026         JNZ       ??ZDSecMgrMasterKeyLoad_1
   1144              {
   1145                // overwrite old key in NV
   1146                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1147                               SEC_KEY_LEN, key );
   \   000027                ; Setup parameters for call to function osal_nv_write
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   75..10       MOV       ?V0,#0x10
   \   00002F   75..00       MOV       ?V1,#0x0
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   7C02         MOV       R4,#0x2
   \   000039   7D00         MOV       R5,#0x0
   \   00003B   7406         MOV       A,#0x6
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   1148              }
   \                     ??CrossCallReturnLabel_161:
   \   000043   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000046   7404         MOV       A,#0x4
   \   000048   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004B   800C         SJMP      ??ZDSecMgrMasterKeyLoad_0
   1149              else
   1150              {
   1151                // store new key -- NULL will zero key
   1152                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00004D                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00004D   AC..         MOV       R4,?V0
   \   00004F   AD..         MOV       R5,?V1
   \   000051   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   1153              }
   1154            }
   \                     ??CrossCallReturnLabel_184:
   \   000054   12....       LCALL     `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   \   000057   E9           MOV       A,R1
   \   000058   FE           MOV       R6,A
   1155          
   1156            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000059   EE           MOV       A,R6
   \   00005A   F9           MOV       R1,A
   \   00005B                REQUIRE ?Subroutine6
   \   00005B                ; // Fall through to label ?Subroutine6
   1157          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine85_0 & 0xFFFF
   1158          
   1159          /******************************************************************************
   1160           * @fn          ZDSecMgrAppKeyGet
   1161           *
   1162           * @brief       get an APP key - option APP(MASTER or LINK) key
   1163           *
   1164           * @param       initNwkAddr - [in] NWK address of initiator device
   1165           * @param       initExtAddr - [in] EXT address of initiator device
   1166           * @param       partNwkAddr - [in] NWK address of partner device
   1167           * @param       partExtAddr - [in] EXT address of partner device
   1168           * @param       key         - [out] APP(MASTER or LINK) key
   1169           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1170           *
   1171           * @return      ZStatus_t
   1172           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1173          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1174                                                           // to KEY_TYPE_APP_LINK since
   1175                                                           // only specific requirement
   1176                                                           // right now comes from SE profile
   1177          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1178          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1179                                       uint8*  initExtAddr,
   1180                                       uint16  partNwkAddr,
   1181                                       uint8*  partExtAddr,
   1182                                       uint8** key,
   1183                                       uint8*  keyType )
   1184          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1185            // Intentionally unreferenced parameters
   1186            (void)initNwkAddr;
   1187            (void)initExtAddr;
   1188            (void)partNwkAddr;
   1189            (void)partExtAddr;
   1190            
   1191            //---------------------------------------------------------------------------
   1192            // note:
   1193            // should use a robust mechanism to generate keys, for example
   1194            // combine EXT addresses and call a hash function
   1195            //---------------------------------------------------------------------------
   1196            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV       A,#0x4
   \   000006   12....       LCALL     ?XSTACK_DISP0_8
   \   000009   12....       LCALL     ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   00000C   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00000F   7910         MOV       R1,#0x10
   \   000011   12....       LCALL     `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
   1197          
   1198            *keyType = ZDSecMgrAppKeyType;
   \   000014   90....       MOV       DPTR,#ZDSecMgrAppKeyType
   \   000017   E0           MOVX      A,@DPTR
   \   000018   C0E0         PUSH      A
   \   00001A   7406         MOV       A,#0x6
   \   00001C   12....       LCALL     ?XSTACK_DISP0_8
   \   00001F   12....       LCALL     ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000022   D0E0         POP       A
   \   000024   F0           MOVX      @DPTR,A
   1199          
   1200            return ZSuccess;
   \   000025   7900         MOV       R1,#0x0
   \   000027   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   1201          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine83_0:
   \   000000   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrAppKeyReq
   1205           *
   1206           * @brief       Process request for APP key between two devices.
   1207           *
   1208           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1209           *
   1210           * @return      none
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1213          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV       A,#-0x27
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1214            APSME_TransportKeyReq_t req;
   1215            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1216            uint16                  partNwkAddr;
   1217            uint8                   key[SEC_KEY_LEN];
   1218          
   1219          
   1220            // validate initiator and partner
   1221            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1222                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   EE           MOV       A,R6
   \   000013   2405         ADD       A,#0x5
   \   000015   FA           MOV       R2,A
   \   000016   E4           CLR       A
   \   000017   3F           ADDC      A,R7
   \   000018   FB           MOV       R3,A
   \   000019   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV       A,R1
   \   00001D   6401         XRL       A,#0x1
   \   00001F   6003         JZ        $+5
   \   000021   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   740F         MOV       A,#0xf
   \   000026   12....       LCALL     ?XSTACK_DISP102_8
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000032   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000035   E9           MOV       A,R1
   \   000036   6401         XRL       A,#0x1
   \   000038   6003         JZ        $+5
   \   00003A   02....       LJMP      ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1223            {
   1224              // point the key to some memory
   1225              req.key = key;
   \   00003D   7417         MOV       A,#0x17
   \   00003F   12....       LCALL     ?XSTACK_DISP100_8
   \   000042   7406         MOV       A,#0x6
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1226          
   1227              // get an APP key - option APP (MASTER or LINK) key
   1228              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1229                                      initExtAddr,
   1230                                      partNwkAddr,
   1231                                      ind->partExtAddr,
   1232                                      &req.key,
   1233                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_139:
   \   00004A                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004A   7404         MOV       A,#0x4
   \   00004C   12....       LCALL     ?XSTACK_DISP0_8
   \   00004F   8582..       MOV       ?V0,DPL
   \   000052   8583..       MOV       ?V1,DPH
   \   000055   78..         MOV       R0,#?V0
   \   000057   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005A   7408         MOV       A,#0x8
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   8582..       MOV       ?V0,DPL
   \   000062   8583..       MOV       ?V1,DPH
   \   000065   78..         MOV       R0,#?V0
   \   000067   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006A   EE           MOV       A,R6
   \   00006B   2405         ADD       A,#0x5
   \   00006D   F5..         MOV       ?V0,A
   \   00006F   E4           CLR       A
   \   000070   3F           ADDC      A,R7
   \   000071   F5..         MOV       ?V1,A
   \   000073   78..         MOV       R0,#?V0
   \   000075   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000078   7406         MOV       A,#0x6
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000080   7417         MOV       A,#0x17
   \   000082   12....       LCALL     ?XSTACK_DISP102_8
   \   000085   8E82         MOV       DPL,R6
   \   000087   8F83         MOV       DPH,R7
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   00008E   12....       LCALL     `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000091   7408         MOV       A,#0x8
   \   000093   12....       LCALL     ?DEALLOC_XSTACK8
   \   000096   E9           MOV       A,R1
   \   000097   7073         JNZ       ??ZDSecMgrAppKeyReq_0
   1234              {
   1235                // always secure
   1236                req.nwkSecure = TRUE;
   \   000099   740C         MOV       A,#0xc
   \   00009B   12....       LCALL     ?XSTACK_DISP0_8
   \   00009E   7401         MOV       A,#0x1
   \   0000A0   F0           MOVX      @DPTR,A
   1237                req.apsSecure = TRUE;
   \   0000A1   740B         MOV       A,#0xb
   \   0000A3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A6   7401         MOV       A,#0x1
   \   0000A8   F0           MOVX      @DPTR,A
   1238                req.tunnel    = NULL;
   \   0000A9   740D         MOV       A,#0xd
   \   0000AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AE   12....       LCALL     ?Subroutine18 & 0xFFFF
   1239          
   1240                // send key to initiator device
   1241                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_9:
   \   0000B1   7402         MOV       A,#0x2
   \   0000B3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B6   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1242                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_140:
   \   0000B9   EE           MOV       A,R6
   \   0000BA   2405         ADD       A,#0x5
   \   0000BC   F8           MOV       R0,A
   \   0000BD   E4           CLR       A
   \   0000BE   3F           ADDC      A,R7
   \   0000BF   F9           MOV       R1,A
   \   0000C0   7408         MOV       A,#0x8
   \   0000C2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C5   12....       LCALL     ?Subroutine16 & 0xFFFF
   1243                req.initiator = TRUE;
   \                     ??CrossCallReturnLabel_2:
   \   0000C8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CB   7401         MOV       A,#0x1
   \   0000CD   F0           MOVX      @DPTR,A
   1244                APSME_TransportKeyReq( &req );
   \   0000CE                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000CE   04           INC       A
   \   0000CF   12....       LCALL     ?XSTACK_DISP101_8
   \   0000D2   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1245          
   1246                // send key to partner device
   1247                req.dstAddr   = partNwkAddr;
   \   0000D5   85..82       MOV       DPL,?XSP + 0
   \   0000D8   85..83       MOV       DPH,?XSP + 1
   \   0000DB   12....       LCALL     ??Subroutine89_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   0000DE   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E1   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1248                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_141:
   \   0000E4   740F         MOV       A,#0xf
   \   0000E6   12....       LCALL     ?XSTACK_DISP100_8
   \   0000E9   7408         MOV       A,#0x8
   \   0000EB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000EE   12....       LCALL     ?Subroutine16 & 0xFFFF
   1249                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_3:
   \   0000F1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F4   E4           CLR       A
   \   0000F5   F0           MOVX      @DPTR,A
   1250          
   1251                APSME_TransportKeyReq( &req );
   \   0000F6                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F6   7402         MOV       A,#0x2
   \   0000F8   12....       LCALL     ?XSTACK_DISP101_8
   \   0000FB   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   1252                
   1253                // clear copy of key in RAM
   1254                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000FE                ; Setup parameters for call to function osal_memset
   \   0000FE   7C10         MOV       R4,#0x10
   \   000100   7D00         MOV       R5,#0x0
   \   000102   7900         MOV       R1,#0x0
   \   000104   7417         MOV       A,#0x17
   \   000106   12....       LCALL     ?XSTACK_DISP101_8
   \   000109   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1255          
   1256              }
   1257            }
   1258          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   00010C   7427         MOV       A,#0x27
   \   00010E   02....       LJMP      ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV       A,#0xa
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8E82         MOV       DPL,R6
   \   000003   8F83         MOV       DPH,R7
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_288:
   \   00000A   F9           MOV       R1,A
   \   00000B   22           RET
   1259          
   1260          /******************************************************************************
   1261           * @fn          ZDSecMgrEstablishKey
   1262           *
   1263           * @brief       Start SKKE with device joining network.
   1264           *
   1265           * @param       device - [in] ZDSecMgrDevice_t, device info
   1266           *
   1267           * @return      ZStatus_t
   1268           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1269          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1270          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1271            ZStatus_t               status;
   1272            APSME_EstablishKeyReq_t req;
   1273          
   1274          
   1275            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000015   12....       LCALL     ?XSTACK_DISP0_8
   \   000018   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1276            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_142:
   \   00001B   7404         MOV       A,#0x4
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E4           CLR       A
   \   000021   F0           MOVX      @DPTR,A
   1277          
   1278            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000022                ; Setup parameters for call to function NLME_GetShortAddr
   \   000022   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000025   8A..         MOV       ?V0,R2
   \   000027   8B..         MOV       ?V1,R3
   \   000029   A8..         MOV       R0,?V0
   \   00002B   A9..         MOV       R1,?V1
   \   00002D   8E82         MOV       DPL,R6
   \   00002F   8F83         MOV       DPH,R7
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   A3           INC       DPTR
   \   000035   E0           MOVX      A,@DPTR
   \   000036   68           XRL       A,R0
   \   000037   7003         JNZ       ??ZDSecMgrEstablishKey_0
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   69           XRL       A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00003C   8E82         MOV       DPL,R6
   \   00003E   8F83         MOV       DPH,R7
   \   000040   7010         JNZ       ??ZDSecMgrEstablishKey_1
   1279            {
   1280              req.dstAddr   = device->nwkAddr;
   \   000042   12....       LCALL     ?Subroutine25 & 0xFFFF
   1281              //devtag.0604.todo - remove obsolete
   1282              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_127:
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   E4           CLR       A
   \   000049   F0           MOVX      @DPTR,A
   1283              req.nwkSecure = FALSE;
   \   00004A   7406         MOV       A,#0x6
   \   00004C   12....       LCALL     ?XSTACK_DISP0_8
   \   00004F   E4           CLR       A
   \   000050   8014         SJMP      ??ZDSecMgrEstablishKey_2
   1284            }
   1285            else
   1286            {
   1287              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   12....       LCALL     ?Subroutine25 & 0xFFFF
   1288              //devtag.0604.todo - remove obsolete
   1289              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_128:
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   7401         MOV       A,#0x1
   \   00005E   F0           MOVX      @DPTR,A
   1290              req.nwkSecure = TRUE;
   \   00005F   7406         MOV       A,#0x6
   \   000061   12....       LCALL     ?XSTACK_DISP0_8
   \   000064   7401         MOV       A,#0x1
   1291            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000066   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   1292          
   1293            status = APSME_EstablishKeyReq( &req );
   1294          
   1295            return status;
   \                     ??CrossCallReturnLabel_244:
   \   000069   12....       LCALL     `??APSME_EstablishKeyReq::?relay`; Banked call to: APSME_EstablishKeyReq
   \   00006C   7407         MOV       A,#0x7
   \   00006E   02....       LJMP      ??Subroutine85_0 & 0xFFFF
   1296          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000003                REQUIRE ??Subroutine82_0
   \   000003                ; // Fall through to label ??Subroutine82_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine82_0:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV       A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine89_0
   \   000002                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   000003   F9           MOV       R1,A
   \   000004   85..82       MOV       DPL,?XSP + 0
   \   000007   85..83       MOV       DPH,?XSP + 1
   \   00000A   22           RET
   1297          
   1298          /******************************************************************************
   1299           * @fn          ZDSecMgrSendMasterKey
   1300           *
   1301           * @brief       Send MASTER key to device joining network.
   1302           *
   1303           * @param       device - [in] ZDSecMgrDevice_t, device info
   1304           *
   1305           * @return      ZStatus_t
   1306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1307          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1308          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV       A,#-0x1f
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1309            ZStatus_t status;
   1310            APSME_TransportKeyReq_t req;
   1311            uint16 keyNvId;
   1312            uint8 masterKey[SEC_KEY_LEN];
   1313          
   1314          
   1315            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7404         MOV       A,#0x4
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   E4           CLR       A
   \   000014   12....       LCALL     ?Subroutine19 & 0xFFFF
   1316            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_11:
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine94_0 & 0xFFFF
   1317            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_199:
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E4           CLR       A
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   F0           MOVX      @DPTR,A
   1318          
   1319            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \   000024                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000024   AC..         MOV       R4,?XSP + 0
   \   000026   AD..         MOV       R5,?XSP + 1
   \   000028   8E82         MOV       DPL,R6
   \   00002A   8F83         MOV       DPH,R7
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   A3           INC       DPTR
   \   000033   A3           INC       DPTR
   \   000034   12....       LCALL     ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000037   12....       LCALL     ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   00003A   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   00003D   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000040   E9           MOV       A,R1
   \   000041   702F         JNZ       ??ZDSecMgrSendMasterKey_0
   1320            {
   1321              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   1322                            SEC_KEY_LEN, masterKey );
   \   000043                ; Setup parameters for call to function osal_nv_read
   \   000043   740F         MOV       A,#0xf
   \   000045   12....       LCALL     ?XSTACK_DISP100_8
   \   000048   88..         MOV       ?V0,R0
   \   00004A   89..         MOV       ?V1,R1
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   75..10       MOV       ?V0,#0x10
   \   000054   75..00       MOV       ?V1,#0x0
   \   000057   78..         MOV       R0,#?V0
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   7C02         MOV       R4,#0x2
   \   00005E   7D00         MOV       R5,#0x0
   \   000060   7404         MOV       A,#0x4
   \   000062   12....       LCALL     ?XSTACK_DISP0_8
   \   000065   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   1323            }
   \                     ??CrossCallReturnLabel_166:
   \   000068   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00006B   7404         MOV       A,#0x4
   \   00006D   12....       LCALL     ?DEALLOC_XSTACK8
   \   000070   800E         SJMP      ??ZDSecMgrSendMasterKey_1
   1324            else
   1325            {
   1326              // in case read from NV fails
   1327              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000072                ; Setup parameters for call to function osal_memset
   \   000072   7C10         MOV       R4,#0x10
   \   000074   7D00         MOV       R5,#0x0
   \   000076   7900         MOV       R1,#0x0
   \   000078   740F         MOV       A,#0xf
   \   00007A   12....       LCALL     ?XSTACK_DISP101_8
   \   00007D   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1328            }
   1329          
   1330            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000080   740F         MOV       A,#0xf
   \   000082   12....       LCALL     ?XSTACK_DISP100_8
   \   000085   7406         MOV       A,#0x6
   \   000087   12....       LCALL     ?XSTACK_DISP0_8
   \   00008A   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1331          
   1332            //check if using secure hop to to parent
   1333            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_143:
   \   00008D                ; Setup parameters for call to function NLME_GetShortAddr
   \   00008D   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000090   8A..         MOV       ?V0,R2
   \   000092   8B..         MOV       ?V1,R3
   \   000094   A8..         MOV       R0,?V0
   \   000096   A9..         MOV       R1,?V1
   \   000098   8E82         MOV       DPL,R6
   \   00009A   8F83         MOV       DPH,R7
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   A3           INC       DPTR
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   68           XRL       A,R0
   \   0000A2   7003         JNZ       ??ZDSecMgrSendMasterKey_2
   \   0000A4   A3           INC       DPTR
   \   0000A5   E0           MOVX      A,@DPTR
   \   0000A6   69           XRL       A,R1
   \                     ??ZDSecMgrSendMasterKey_2:
   \   0000A7   8E82         MOV       DPL,R6
   \   0000A9   8F83         MOV       DPH,R7
   \   0000AB   601C         JZ        ??ZDSecMgrSendMasterKey_3
   1334            {
   1335              //send to parent with security
   1336              req.dstAddr   = device->parentAddr;
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   12....       LCALL     ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   0000B2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1337              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_144:
   \   0000B8   740C         MOV       A,#0xc
   \   0000BA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BD   7401         MOV       A,#0x1
   \   0000BF   F0           MOVX      @DPTR,A
   1338              req.apsSecure = TRUE;
   \   0000C0   740B         MOV       A,#0xb
   \   0000C2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C5   7401         MOV       A,#0x1
   \   0000C7   8016         SJMP      ??ZDSecMgrSendMasterKey_4
   1339            }
   1340            else
   1341            {
   1342              //direct with no security
   1343              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_3:
   \   0000C9   12....       LCALL     ??Subroutine89_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   0000CC   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CF   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1344              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_145:
   \   0000D2   740C         MOV       A,#0xc
   \   0000D4   12....       LCALL     ?XSTACK_DISP0_8
   \   0000D7   E4           CLR       A
   \   0000D8   F0           MOVX      @DPTR,A
   1345              req.apsSecure = FALSE;
   \   0000D9   740B         MOV       A,#0xb
   \   0000DB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DE   E4           CLR       A
   \                     ??ZDSecMgrSendMasterKey_4:
   \   0000DF   F0           MOVX      @DPTR,A
   1346            }
   1347          
   1348            status = APSME_TransportKeyReq( &req );
   \   0000E0                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000E0   7402         MOV       A,#0x2
   \   0000E2   12....       LCALL     ?XSTACK_DISP101_8
   \   0000E5   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000E8   E9           MOV       A,R1
   \   0000E9   FE           MOV       R6,A
   1349          
   1350            // clear copy of key in RAM
   1351            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   0000EA                ; Setup parameters for call to function osal_memset
   \   0000EA   7C10         MOV       R4,#0x10
   \   0000EC   7D00         MOV       R5,#0x0
   \   0000EE   7900         MOV       R1,#0x0
   \   0000F0   740F         MOV       A,#0xf
   \   0000F2   12....       LCALL     ?XSTACK_DISP101_8
   \   0000F5   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1352          
   1353            return status;
   \   0000F8   EE           MOV       A,R6
   \   0000F9   F9           MOV       R1,A
   \   0000FA   741F         MOV       A,#0x1f
   \   0000FC   02....       LJMP      ??Subroutine85_0 & 0xFFFF
   1354          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003   740D         MOV       A,#0xd
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000003   7408         MOV       A,#0x8
   \   000005   22           RET
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrSendNwkKey
   1358           *
   1359           * @brief       Send NWK key to device joining network.
   1360           *
   1361           * @param       device - [in] ZDSecMgrDevice_t, device info
   1362           *
   1363           * @return      ZStatus_t
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1366          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV       A,#-0x1e
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1367            ZStatus_t status;
   1368            APSME_TransportKeyReq_t req;
   1369            APSDE_FrameTunnel_t tunnel;
   1370            nwkKeyDesc tmpKey;
   1371              
   1372            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   12....       LCALL     ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000015   12....       LCALL     ?Subroutine17 & 0xFFFF
   1373            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   000018   7406         MOV       A,#0x6
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1374          
   1375            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1376              req.keyType   = KEY_TYPE_NWK_HIGH;
   1377            else
   1378              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_146:
   \   000020   7402         MOV       A,#0x2
   \   000022   12....       LCALL     ?XSTACK_DISP0_8
   \   000025   7401         MOV       A,#0x1
   \   000027   F0           MOVX      @DPTR,A
   1379          
   1380            // get the Active Key into a local variable 
   1381            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1382                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000028                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   000028   75..3A       MOV       ?V0,#0x3a
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   740F         MOV       A,#0xf
   \   000035   12....       LCALL     ?XSTACK_DISP100_8
   \   000038   88..         MOV       ?V0,R0
   \   00003A   89..         MOV       ?V1,R1
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   7C11         MOV       R4,#0x11
   \   000043   7D00         MOV       R5,#0x0
   \   000045   7A00         MOV       R2,#0x0
   \   000047   7B00         MOV       R3,#0x0
   \   000049   12....       LCALL     `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   00004C   7404         MOV       A,#0x4
   \   00004E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000051   E9           MOV       A,R1
   \   000052   600E         JZ        ??ZDSecMgrSendNwkKey_0
   1383            {
   1384              // set key data to all 0s if NV read fails
   1385              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000054                ; Setup parameters for call to function osal_memset
   \   000054   7C11         MOV       R4,#0x11
   \   000056   7D00         MOV       R5,#0x0
   \   000058   7900         MOV       R1,#0x0
   \   00005A   740D         MOV       A,#0xd
   \   00005C   12....       LCALL     ?XSTACK_DISP101_8
   \   00005F   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1386            }
   1387            
   1388            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1389                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1390            {
   1391              // set values
   1392              req.keySeqNum = tmpKey.keySeqNum;
   1393              req.key       = tmpKey.key;
   1394          
   1395              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1396              //key isn't used to secure the frame at the APS layer -- since the receiving
   1397              //device may not have a NWK key yet
   1398              req.apsSecure = TRUE;
   1399          
   1400              // check if using secure hop to to parent
   1401              if ( device->parentAddr == NLME_GetShortAddr() )
   1402              {
   1403                req.nwkSecure = FALSE;
   1404                req.tunnel    = NULL;
   1405              }
   1406              else
   1407              {
   1408                req.nwkSecure   = TRUE;
   1409                req.tunnel      = &tunnel;
   1410                req.tunnel->tna = device->parentAddr;
   1411                req.tunnel->dea = device->extAddr;
   1412              }
   1413            }
   1414            else
   1415            {
   1416              // default values
   1417              //devtag.0604.verify
   1418              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000062   740A         MOV       A,#0xa
   \   000064   12....       LCALL     ?XSTACK_DISP0_8
   \   000067   7401         MOV       A,#0x1
   \   000069   F0           MOVX      @DPTR,A
   1419              req.apsSecure = FALSE;
   \   00006A   7409         MOV       A,#0x9
   \   00006C   12....       LCALL     ?XSTACK_DISP0_8
   \   00006F   E4           CLR       A
   \   000070   F0           MOVX      @DPTR,A
   1420              req.tunnel    = NULL;
   \   000071   740B         MOV       A,#0xb
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   E4           CLR       A
   \   000077   F0           MOVX      @DPTR,A
   \   000078   A3           INC       DPTR
   \   000079   F0           MOVX      @DPTR,A
   1421          
   1422              if ( device->parentAddr != NLME_GetShortAddr() )
   \   00007A                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007A   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00007D   8A..         MOV       ?V0,R2
   \   00007F   8B..         MOV       ?V1,R3
   \   000081   A8..         MOV       R0,?V0
   \   000083   A9..         MOV       R1,?V1
   \   000085   8E82         MOV       DPL,R6
   \   000087   8F83         MOV       DPH,R7
   \   000089   A3           INC       DPTR
   \   00008A   A3           INC       DPTR
   \   00008B   A3           INC       DPTR
   \   00008C   A3           INC       DPTR
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   68           XRL       A,R0
   \   00008F   7003         JNZ       ??ZDSecMgrSendNwkKey_1
   \   000091   A3           INC       DPTR
   \   000092   E0           MOVX      A,@DPTR
   \   000093   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000094   600B         JZ        ??CrossCallReturnLabel_155
   1423              {
   1424                req.dstAddr = device->parentAddr;
   \   000096   8E82         MOV       DPL,R6
   \   000098   8F83         MOV       DPH,R7
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   12....       LCALL     ?Subroutine27 & 0xFFFF
   1425              }
   1426          
   1427              // special cases
   1428              //devtag.0604.todo - modify to preconfig flag
   1429              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_155:
   \   0000A1   8E82         MOV       DPL,R6
   \   0000A3   8F83         MOV       DPH,R7
   \   0000A5   A3           INC       DPTR
   \   0000A6   A3           INC       DPTR
   \   0000A7   A3           INC       DPTR
   \   0000A8   A3           INC       DPTR
   \   0000A9   A3           INC       DPTR
   \   0000AA   A3           INC       DPTR
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   7041         JNZ       ??ZDSecMgrSendNwkKey_2
   1430              {
   1431                req.keySeqNum = tmpKey.keySeqNum;
   \   0000AE   740D         MOV       A,#0xd
   \   0000B0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   C0E0         PUSH      A
   \   0000B6   7403         MOV       A,#0x3
   \   0000B8   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BB   D0E0         POP       A
   \   0000BD   F0           MOVX      @DPTR,A
   1432                req.key       = tmpKey.key;
   \   0000BE   740E         MOV       A,#0xe
   \   0000C0   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C3   A882         MOV       R0,DPL
   \   0000C5   A983         MOV       R1,DPH
   \   0000C7   7404         MOV       A,#0x4
   \   0000C9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   1433          
   1434                // check if using secure hop to to parent
   1435                if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_147:
   \   0000CF                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000CF   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000D2   8A..         MOV       ?V0,R2
   \   0000D4   8B..         MOV       ?V1,R3
   \   0000D6   A8..         MOV       R0,?V0
   \   0000D8   A9..         MOV       R1,?V1
   \   0000DA   8E82         MOV       DPL,R6
   \   0000DC   8F83         MOV       DPH,R7
   \   0000DE   A3           INC       DPTR
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   A3           INC       DPTR
   \   0000E2   E0           MOVX      A,@DPTR
   \   0000E3   68           XRL       A,R0
   \   0000E4   7003         JNZ       ??ZDSecMgrSendNwkKey_3
   \   0000E6   A3           INC       DPTR
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   69           XRL       A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000E9   7014         JNZ       ??ZDSecMgrSendNwkKey_4
   1436                {
   1437                  req.nwkSecure = FALSE;
   \   0000EB   740A         MOV       A,#0xa
   \   0000ED   800B         SJMP      ??ZDSecMgrSendNwkKey_5
   1438                }
   1439              }
   1440              else
   1441              {
   1442                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000EF   7404         MOV       A,#0x4
   \   0000F1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000F4   E4           CLR       A
   \   0000F5   F0           MOVX      @DPTR,A
   \   0000F6   A3           INC       DPTR
   \   0000F7   F0           MOVX      @DPTR,A
   1443                req.keySeqNum = 0;
   \   0000F8   7403         MOV       A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000FA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000FD   E4           CLR       A
   \   0000FE   F0           MOVX      @DPTR,A
   1444              }
   1445            }
   1446          
   1447            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000FF                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000FF   AA..         MOV       R2,?XSP + 0
   \   000101   AB..         MOV       R3,?XSP + 1
   \   000103   12....       LCALL     `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000106   E9           MOV       A,R1
   \   000107   FE           MOV       R6,A
   1448          
   1449            // clear copy of key in RAM before return
   1450            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000108                ; Setup parameters for call to function osal_memset
   \   000108   7C11         MOV       R4,#0x11
   \   00010A   7D00         MOV       R5,#0x0
   \   00010C   7900         MOV       R1,#0x0
   \   00010E   740D         MOV       A,#0xd
   \   000110   12....       LCALL     ?XSTACK_DISP101_8
   \   000113   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1451          
   1452            return status;
   \   000116   EE           MOV       A,R6
   \   000117   F9           MOV       R1,A
   \   000118   741E         MOV       A,#0x1e
   \   00011A   80..         SJMP      ??Subroutine85_0
   1453          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000003                REQUIRE ??Subroutine84_0
   \   000003                ; // Fall through to label ??Subroutine84_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   12....       LCALL     ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000003   22           RET
   1454          
   1455          /******************************************************************************
   1456           * @fn          ZDSecMgrDeviceEntryRemove
   1457           *
   1458           * @brief       Remove device entry.
   1459           *
   1460           * @param       entry - [in] valid entry
   1461           *
   1462           * @return      none
   1463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1464          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1465          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1466            // terminate device control
   1467            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1468            {
   1469              ZDSecMgrCtrlTerm( entry );
   1470            }
   1471          
   1472            // remove device from entry data
   1473            ZDSecMgrEntryFree( entry );
   \   000004                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000004   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1474          
   1475            // remove EXT address
   1476            //ZDSecMgrExtAddrRelease( aiOld );
   1477          }
   \   000007   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   1478          
   1479          /******************************************************************************
   1480           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1481           *
   1482           * @brief       Remove device entry by its ext address.
   1483           *
   1484           * @param       pAddr - pointer to the extended address
   1485           *
   1486           * @return      ZStatus_t
   1487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1488          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1489          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1490            ZDSecMgrEntry_t *pEntry;
   1491            uint8           retValue;
   1492            
   1493            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   AC..         MOV       R4,?XSP + 0
   \   00000C   AD..         MOV       R5,?XSP + 1
   \   00000E   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000011   E9           MOV       A,R1
   \   000012   FE           MOV       R6,A
   1494            
   1495            if( retValue == ZSuccess )
   \   000013   7006         JNZ       ??ZDSecMgrDeviceRemoveByExtAddr_0
   1496            {
   1497              ZDSecMgrDeviceEntryRemove( pEntry );
   \   000015                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000015   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000018   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1498            }
   1499            
   1500            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   00001B   EE           MOV       A,R6
   \   00001C   F9           MOV       R1,A
   \   00001D   02....       LJMP      ??Subroutine91_0 & 0xFFFF
   1501          }
   1502          
   1503          /******************************************************************************
   1504           * @fn          ZDSecMgrDeviceEntryAdd
   1505           *
   1506           * @brief       Add entry.
   1507           *
   1508           * @param       device - [in] ZDSecMgrDevice_t, device info
   1509           * @param       ami    - [in] Address Manager index
   1510           *
   1511           * @return      ZStatus_t
   1512           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1513          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1514          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   1515            AddrMgrEntry_t entry;
   1516          
   1517            // get the ami data
   1518            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
   1519            entry.index = ami;
   \   000017   740B         MOV       A,#0xb
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   EA           MOV       A,R2
   \   00001D   F0           MOVX      @DPTR,A
   \   00001E   A3           INC       DPTR
   \   00001F   EB           MOV       A,R3
   \   000020   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   1520          
   1521            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_245:
   \   000023   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1522          
   1523            // check if NWK address is same
   1524            if ( entry.nwkAddr != nwkAddr )
   \   000026   7401         MOV       A,#0x1
   \   000028   12....       LCALL     ?XSTACK_DISP0_8
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   6E           XRL       A,R6
   \   00002D   7003         JNZ       ??ZDSecMgrAddrMgrUpdate_0
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   6F           XRL       A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   000032   600F         JZ        ??ZDSecMgrAddrMgrUpdate_1
   1525            {
   1526              // update NWK address
   1527              entry.nwkAddr = nwkAddr;
   \   000034   7401         MOV       A,#0x1
   \   000036   12....       LCALL     ?XSTACK_DISP0_8
   \   000039   EE           MOV       A,R6
   \   00003A   F0           MOVX      @DPTR,A
   \   00003B   A3           INC       DPTR
   \   00003C   EF           MOV       A,R7
   \   00003D   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   1528          
   1529              AddrMgrEntryUpdate( &entry );
   1530            }
   \                     ??CrossCallReturnLabel_246:
   \   000040   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   1531          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   000043   02....       LJMP      ?Subroutine7 & 0xFFFF
   1532          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine83_0
   \   000006                ; // Fall through to label ??Subroutine83_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1533          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1534          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V2,R2
   \   00000C   8B..         MOV       ?V3,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   1535            ZStatus_t        status;
   1536            ZDSecMgrEntry_t* entry;
   1537          
   1538          
   1539            // initialize as unknown until completion
   1540            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV       ?V0,#-0x38
   1541          
   1542            device->ctrl = NULL;
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   F0           MOVX      @DPTR,A
   1543          
   1544            // make sure not already registered
   1545            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000025                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000025   AC..         MOV       R4,?XSP + 0
   \   000027   AD..         MOV       R5,?XSP + 1
   \   000029   8A82         MOV       DPL,R2
   \   00002B   8B83         MOV       DPH,R3
   \   00002D   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   000030   12....       LCALL     `??ZDSecMgrEntryLookup::?relay`; Banked call to: ZDSecMgrEntryLookup
   \   000033   E9           MOV       A,R1
   \   000034   7022         JNZ       ??ZDSecMgrDeviceEntryAdd_0
   1546            {
   1547              // verify that address index is same
   1548              if ( entry->ami != ami )
   \   000036   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   6E           XRL       A,R6
   \   00003B   7003         JNZ       ??ZDSecMgrDeviceEntryAdd_1
   \   00003D   A3           INC       DPTR
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   6F           XRL       A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000040   602A         JZ        ??ZDSecMgrDeviceEntryAdd_2
   1549              {
   1550                // remove conflicting entry
   1551                ZDSecMgrDeviceEntryRemove( entry );
   \   000042                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000042   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000045   12....       LCALL     `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
   1552          
   1553                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   1554                {
   1555                  // update NWK address
   1556                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1557                }
   1558              }
   1559            }
   \   000048                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000048   AC..         MOV       R4,?XSP + 0
   \   00004A   AD..         MOV       R5,?XSP + 1
   \   00004C   EE           MOV       A,R6
   \   00004D   FA           MOV       R2,A
   \   00004E   EF           MOV       A,R7
   \   00004F   FB           MOV       R3,A
   \   000050   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000053   E9           MOV       A,R1
   \   000054   7016         JNZ       ??ZDSecMgrDeviceEntryAdd_2
   \   000056   800E         SJMP      ??ZDSecMgrDeviceEntryAdd_3
   1560            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000058                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000058   AC..         MOV       R4,?XSP + 0
   \   00005A   AD..         MOV       R5,?XSP + 1
   \   00005C   EE           MOV       A,R6
   \   00005D   FA           MOV       R2,A
   \   00005E   EF           MOV       A,R7
   \   00005F   FB           MOV       R3,A
   \   000060   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000063   E9           MOV       A,R1
   \   000064   7006         JNZ       ??ZDSecMgrDeviceEntryAdd_2
   1561            {
   1562              // update NWK address
   1563              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000066                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000066   12....       LCALL     ?Subroutine36 & 0xFFFF
   1564            }
   \                     ??CrossCallReturnLabel_270:
   \   000069   12....       LCALL     `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   1565          
   1566            // check if a new entry needs to be created
   1567            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   00006C   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   00006F   7018         JNZ       ??ZDSecMgrDeviceEntryAdd_4
   1568            {
   1569              // get new entry
   1570              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000071                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000071   AA..         MOV       R2,?XSP + 0
   \   000073   AB..         MOV       R3,?XSP + 1
   \   000075   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000078   E9           MOV       A,R1
   \   000079   7011         JNZ       ??ZDSecMgrDeviceEntryAdd_5
   1571              {
   1572                // reset entry lkd
   1573          
   1574                // finish setting up entry
   1575                entry->ami = ami;
   \   00007B   12....       LCALL     ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00007E   EE           MOV       A,R6
   \   00007F   F0           MOVX      @DPTR,A
   \   000080   A3           INC       DPTR
   \   000081   EF           MOV       A,R7
   \   000082   F0           MOVX      @DPTR,A
   1576          
   1577                // update NWK address
   1578                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000083                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000083   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   000086   12....       LCALL     `??ZDSecMgrAddrMgrUpdate::?relay`; Banked call to: ZDSecMgrAddrMgrUpdate
   1579          
   1580                // enter new device into device control
   1581                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1582                {
   1583                  status = ZDSecMgrCtrlAdd( device, entry );
   1584                }
   1585                else
   1586                {
   1587                  status = ZSuccess;
   1588                }
   1589              }
   1590            }
   1591            else
   1592            {
   1593              // reset entry lkd
   1594          
   1595              // reset entry in entry control
   1596              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1597              {
   1598                status = ZDSecMgrCtrlReset( device, entry );
   1599              }
   1600              else
   1601              {
   1602                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000089   75..00       MOV       ?V0,#0x0
   1603              }
   1604            }
   1605          
   1606            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   00008C   A9..         MOV       R1,?V0
   \   00008E   7402         MOV       A,#0x2
   \   000090   02....       LJMP      ?Subroutine4 & 0xFFFF
   1607          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   85..82       MOV       DPL,?V2
   \   000003   85..83       MOV       DPH,?V3
   \   000006                REQUIRE ??Subroutine102_0
   \   000006                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   EE           MOV       A,R6
   \   000006   FA           MOV       R2,A
   \   000007   EF           MOV       A,R7
   \   000008   FB           MOV       R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine103_0
   \   000003                ; // Fall through to label ??Subroutine103_0
   1608          
   1609          /******************************************************************************
   1610           * @fn          ZDSecMgrDeviceCtrlHandler
   1611           *
   1612           * @brief       Device control handler.
   1613           *
   1614           * @param       device - [in] ZDSecMgrDevice_t, device info
   1615           *
   1616           * @return      none
   1617           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1618          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1619          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   1620            uint8 state;
   1621            uint8 cntr;
   1622          
   1623          
   1624            state = device->ctrl->state;
   \   000009   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F5..         MOV       ?V0,A
   1625            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1626          
   1627            switch ( state )
   \   00000F   24FE         ADD       A,#-0x2
   \   000011   600C         JZ        ??ZDSecMgrDeviceCtrlHandler_0
   \   000013   14           DEC       A
   \   000014   6014         JZ        ??ZDSecMgrDeviceCtrlHandler_1
   \   000016   14           DEC       A
   \   000017   6022         JZ        ??ZDSecMgrDeviceCtrlHandler_2
   \   000019   24FD         ADD       A,#-0x3
   \   00001B   6018         JZ        ??ZDSecMgrDeviceCtrlHandler_3
   \   00001D   8046         SJMP      ??ZDSecMgrDeviceCtrlHandler_4
   1628            {
   1629              case ZDSECMGR_CTRL_TK_MASTER:
   1630                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   00001F                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   00001F   12....       LCALL     `??ZDSecMgrSendMasterKey::?relay`; Banked call to: ZDSecMgrSendMasterKey
   \   000022   E9           MOV       A,R1
   \   000023   7016         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1631                {
   1632                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   000025   75..03       MOV       ?V0,#0x3
   1633                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   000028   8011         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1634                }
   1635                break;
   1636          
   1637              case ZDSECMGR_CTRL_SKKE_INIT:
   1638                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   00002A                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   00002A   12....       LCALL     `??ZDSecMgrEstablishKey::?relay`; Banked call to: ZDSecMgrEstablishKey
   \   00002D   E9           MOV       A,R1
   \   00002E   700B         JNZ       ??ZDSecMgrDeviceCtrlHandler_2
   1639                {
   1640                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000030   75..04       MOV       ?V0,#0x4
   \   000033   8006         SJMP      ??ZDSecMgrDeviceCtrlHandler_2
   1641                }
   1642                break;
   1643          
   1644              case ZDSECMGR_CTRL_SKKE_WAIT:
   1645                // continue to wait for SKA control timeout
   1646                break;
   1647          
   1648              case ZDSECMGR_CTRL_TK_NWK:
   1649                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000035                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000035   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000038   E9           MOV       A,R1
   \   000039   602A         JZ        ??ZDSecMgrDeviceCtrlHandler_4
   1650                {
   1651                  state = ZDSECMGR_CTRL_NONE;
   1652                }
   1653                break;
   1654          
   1655              default:
   1656                state = ZDSECMGR_CTRL_NONE;
   1657                break;
   1658            }
   1659          
   1660            if ( state != ZDSECMGR_CTRL_NONE )
   1661            {
   1662              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   00003B   EE           MOV       A,R6
   \   00003C   2408         ADD       A,#0x8
   \   00003E   F8           MOV       R0,A
   \   00003F   E4           CLR       A
   \   000040   3F           ADDC      A,R7
   \   000041   F9           MOV       R1,A
   \   000042   8882         MOV       DPL,R0
   \   000044   8983         MOV       DPH,R1
   \   000046   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   E5..         MOV       A,?V0
   \   00004E   12....       LCALL     ?Subroutine28 & 0xFFFF
   1663              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_22:
   \   000051   12....       LCALL     ?Subroutine56 & 0xFFFF
   1664          
   1665              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \                     ??CrossCallReturnLabel_67:
   \   000054                ; Setup parameters for call to function osal_start_timerEx
   \   000054   7C64         MOV       R4,#0x64
   \   000056   7D00         MOV       R5,#0x0
   \   000058   7A00         MOV       R2,#0x0
   \   00005A   FB           MOV       R3,A
   \   00005B   90....       MOV       DPTR,#ZDAppTaskID
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F9           MOV       R1,A
   \   000060   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000063   8005         SJMP      ??ZDSecMgrDeviceCtrlHandler_5
   1666            }
   1667            else
   1668            {
   1669              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000065   12....       LCALL     ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000068   E4           CLR       A
   \   000069   F0           MOVX      @DPTR,A
   1670            }
   1671          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   00006A   02....       LJMP      ??Subroutine93_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   C8           XCH       A,R0
   \   000001   2406         ADD       A,#0x6
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   38           ADDC      A,R0
   \   000007   F583         MOV       DPH,A
   \   000009   7401         MOV       A,#0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000003   12....       LCALL     ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   12....       LCALL     ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL     ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceCtrlSetup
   1675           *
   1676           * @brief       Setup device control.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      ZStatus_t
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine80_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F583         MOV       DPH,A
   \   000003   8882         MOV       DPL,R0
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1683          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1684            if ( device->ctrl != NULL )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000013   602A         JZ        ??ZDSecMgrDeviceCtrlSetup_0
   1685            {
   1686              if ( device->secure == FALSE )
   \   000015   8A82         MOV       DPL,R2
   \   000017   8B83         MOV       DPH,R3
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   8A82         MOV       DPL,R2
   \   000022   8B83         MOV       DPH,R3
   \   000024   A3           INC       DPTR
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   7007         JNZ       ??ZDSecMgrDeviceCtrlSetup_1
   1687              {
   1688                // send the master key data to the joining device
   1689                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002F   12....       LCALL     ??Subroutine80_0 & 0xFFFF
   1690              }
   \                     ??CrossCallReturnLabel_121:
   \   000032   7402         MOV       A,#0x2
   \   000034   8005         SJMP      ??ZDSecMgrDeviceCtrlSetup_2
   1691              else
   1692              {
   1693                // start SKKE
   1694                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000036   12....       LCALL     ??Subroutine80_0 & 0xFFFF
   1695              }
   \                     ??CrossCallReturnLabel_122:
   \   000039   7403         MOV       A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   00003B   F0           MOVX      @DPTR,A
   1696          
   1697              ZDSecMgrDeviceCtrlHandler( device );
   \   00003C                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   00003C   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   1698            }
   1699          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00003F   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   1700          
   1701          /******************************************************************************
   1702           * @fn          ZDSecMgrDeviceCtrlUpdate
   1703           *
   1704           * @brief       Update control data.
   1705           *
   1706           * @param       extAddr - [in] EXT address
   1707           * @param       state   - [in] new control state
   1708           *
   1709           * @return      none
   1710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006   A3           INC       DPTR
   \   000007                REQUIRE ??Subroutine80_0
   \   000007                ; // Fall through to label ??Subroutine80_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1711          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1712          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   1713            ZDSecMgrEntry_t* entry;
   1714            ZDSecMgrCtrl_t*  ctrl;
   1715          
   1716          
   1717            // lookup device entry data
   1718            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV       A,#0x2
   \   00000E   12....       LCALL     ?XSTACK_DISP102_8
   \   000011   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   1719          
   1720            if ( entry != NULL )
   \   000014   7402         MOV       A,#0x2
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   00001C   603F         JZ        ??CrossCallReturnLabel_68
   1721            {
   1722              // lookup device control data
   1723              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   00001E                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   00002A   12....       LCALL     `??ZDSecMgrCtrlLookup::?relay`; Banked call to: ZDSecMgrCtrlLookup
   1724          
   1725              // make sure control data is valid
   1726              if ( ctrl != NULL )
   \   00002D   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000030   602B         JZ        ??CrossCallReturnLabel_68
   1727              {
   1728                // possible state transitions
   1729                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   000032   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000035   E0           MOVX      A,@DPTR
   \   000036   6404         XRL       A,#0x4
   \   000038   7023         JNZ       ??CrossCallReturnLabel_68
   1730                {
   1731                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   00003A   7405         MOV       A,#0x5
   \   00003C   6E           XRL       A,R6
   \   00003D   7007         JNZ       ??ZDSecMgrDeviceCtrlUpdate_0
   1732                  {
   1733                    // send the network key
   1734                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   00003F   12....       LCALL     ?Subroutine40 & 0xFFFF
   1735                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1736                  }
   \                     ??CrossCallReturnLabel_125:
   \   000042   7407         MOV       A,#0x7
   \   000044   800A         SJMP      ??ZDSecMgrDeviceCtrlUpdate_1
   1737                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000046   7406         MOV       A,#0x6
   \   000048   6E           XRL       A,R6
   \   000049   7012         JNZ       ??CrossCallReturnLabel_68
   1738                  {
   1739                    // force default timeout in order to cleanup control logic
   1740                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   00004B   12....       LCALL     ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   00004E   7406         MOV       A,#0x6
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   000050   F0           MOVX      @DPTR,A
   1741                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \   000051   85..82       MOV       DPL,?XSP + 0
   \   000054   85..83       MOV       DPH,?XSP + 1
   \   000057   12....       LCALL     ?Subroutine73 & 0xFFFF
   1742                  }
   1743                }
   1744                // timer should be active
   1745              }
   1746            }
   \                     ??CrossCallReturnLabel_285:
   \   00005A   12....       LCALL     ?Subroutine56 & 0xFFFF
   1747          }
   \                     ??CrossCallReturnLabel_68:
   \   00005D                REQUIRE ?Subroutine8
   \   00005D                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7404         MOV       A,#0x4
   \   000002   02....       LJMP      ??Subroutine92_0 & 0xFFFF
   1748          
   1749          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1750          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1751          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1752            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1753            {
   1754              if ( initiator == TRUE )
   1755              {
   1756                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1757              }
   1758            }
   1759          }
   \   000000   02....       LJMP      ?BRET
   1760          
   1761          /******************************************************************************
   1762           * @fn          ZDSecMgrDeviceRemove
   1763           *
   1764           * @brief       Remove device from network.
   1765           *
   1766           * @param       device - [in] ZDSecMgrDevice_t, device info
   1767           *
   1768           * @return      none
   1769           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1770          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1771          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV       A,#-0x9
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1772            APSME_RemoveDeviceReq_t remDevReq;
   1773            NLME_LeaveReq_t         leaveReq;
   1774            associated_devices_t*   assoc;
   1775          
   1776          
   1777            // check if parent, remove the device
   1778            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   A8..         MOV       R0,?V0
   \   000017   A9..         MOV       R1,?V1
   \   000019   8E82         MOV       DPL,R6
   \   00001B   8F83         MOV       DPH,R7
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   A3           INC       DPTR
   \   000021   E0           MOVX      A,@DPTR
   \   000022   68           XRL       A,R0
   \   000023   7003         JNZ       ??ZDSecMgrDeviceRemove_0
   \   000025   A3           INC       DPTR
   \   000026   E0           MOVX      A,@DPTR
   \   000027   69           XRL       A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000028   7066         JNZ       ??ZDSecMgrDeviceRemove_1
   1779            {
   1780              // this is the parent of the device
   1781              leaveReq.extAddr        = device->extAddr;
   \   00002A   EE           MOV       A,R6
   \   00002B   2402         ADD       A,#0x2
   \   00002D   F8           MOV       R0,A
   \   00002E   E4           CLR       A
   \   00002F   3F           ADDC      A,R7
   \   000030   F9           MOV       R1,A
   \   000031   8882         MOV       DPL,R0
   \   000033   8983         MOV       DPH,R1
   \   000035   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000038   12....       LCALL     ?Subroutine21 & 0xFFFF
   1782              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_214:
   \   00003B   7402         MOV       A,#0x2
   \   00003D   12....       LCALL     ?XSTACK_DISP0_8
   \   000040   E4           CLR       A
   \   000041   F0           MOVX      @DPTR,A
   1783              leaveReq.rejoin         = FALSE;
   \   000042   7403         MOV       A,#0x3
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   E4           CLR       A
   \   000048   12....       LCALL     ?Subroutine61 & 0xFFFF
   1784          
   1785              // find child association
   1786              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_78:
   \   00004B   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   00004E   12....       LCALL     `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000051   8A..         MOV       ?V0,R2
   \   000053   8B..         MOV       ?V1,R3
   \   000055   A8..         MOV       R0,?V0
   \   000057   A9..         MOV       R1,?V1
   1787          
   1788              if ( ( assoc != NULL                            ) &&
   1789                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1790                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000059   E8           MOV       A,R0
   \   00005A   49           ORL       A,R1
   \   00005B   6052         JZ        ??ZDSecMgrDeviceRemove_2
   \   00005D   8882         MOV       DPL,R0
   \   00005F   8983         MOV       DPH,R1
   \   000061   A3           INC       DPTR
   \   000062   A3           INC       DPTR
   \   000063   A3           INC       DPTR
   \   000064   A3           INC       DPTR
   \   000065   E0           MOVX      A,@DPTR
   \   000066   6047         JZ        ??ZDSecMgrDeviceRemove_2
   \   000068   C3           CLR       C
   \   000069   9405         SUBB      A,#0x5
   \   00006B   5042         JNC       ??ZDSecMgrDeviceRemove_2
   1791              {
   1792                // check if associated device is authenticated
   1793                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00006D   8882         MOV       DPL,R0
   \   00006F   8983         MOV       DPH,R1
   \   000071   A3           INC       DPTR
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   A2E3         MOV       C,0xE0 /* A   */.3
   \   000079   7404         MOV       A,#0x4
   \   00007B   5006         JNC       ??ZDSecMgrDeviceRemove_3
   1794                {
   1795                  leaveReq.silent = FALSE;
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   E4           CLR       A
   \   000081   8005         SJMP      ??ZDSecMgrDeviceRemove_4
   1796                }
   1797                else
   1798                {
   1799                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   7401         MOV       A,#0x1
   1800                }
   1801          
   1802                NLME_LeaveReq( &leaveReq );
   1803              }
   1804            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000088   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   00008B   12....       LCALL     `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   00008E   801F         SJMP      ??ZDSecMgrDeviceRemove_2
   1805            else
   1806            {
   1807              // this is not the parent of the device
   1808              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000090   8E82         MOV       DPL,R6
   \   000092   8F83         MOV       DPH,R7
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   12....       LCALL     ??Subroutine104_0 & 0xFFFF
   1809              remDevReq.childExtAddr = device->extAddr;
   1810          
   1811              APSME_RemoveDeviceReq( &remDevReq );
   1812            }
   \                     ??CrossCallReturnLabel_276:
   \   000099   7405         MOV       A,#0x5
   \   00009B   12....       LCALL     ?XSTACK_DISP0_8
   \   00009E   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000A1   7407         MOV       A,#0x7
   \   0000A3   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL     ??Subroutine82_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0000A9   12....       LCALL     ?XSTACK_DISP101_8
   \   0000AC   12....       LCALL     `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1813          }
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000AF   7409         MOV       A,#0x9
   \   0000B1   02....       LJMP      ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine95_0
   \   000006                ; // Fall through to label ??Subroutine95_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   A3           INC       DPTR
   \   000001   A3           INC       DPTR
   \   000002                REQUIRE ??Subroutine105_0
   \   000002                ; // Fall through to label ??Subroutine105_0
   1814          
   1815          /******************************************************************************
   1816           * @fn          ZDSecMgrDeviceValidateSKKE
   1817           *
   1818           * @brief       Decide whether device is allowed for SKKE.
   1819           *
   1820           * @param       device - [in] ZDSecMgrDevice_t, device info
   1821           *
   1822           * @return      ZStatus_t
   1823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1824          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1825          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1826            ZStatus_t status;
   1827            uint16 ami;
   1828            uint16 keyNvId;
   1829          
   1830          
   1831            // get EXT address
   1832            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   8E82         MOV       DPL,R6
   \   000014   8F83         MOV       DPH,R7
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   00001B   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00001E   E9           MOV       A,R1
   \   00001F   F9           MOV       R1,A
   1833          
   1834            if ( status == ZSuccess )
   \   000020   701D         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1835            {
   1836              // get MASTER key
   1837              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   000022                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000022   7402         MOV       A,#0x2
   \   000024   12....       LCALL     ?XSTACK_DISP102_8
   \   000027   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00002A   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   00002D   E9           MOV       A,R1
   \   00002E   F9           MOV       R1,A
   1838          
   1839              if ( status == ZSuccess )
   \   00002F   700E         JNZ       ??ZDSecMgrDeviceValidateSKKE_0
   1840              {
   1841                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000031                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000031   85..82       MOV       DPL,?XSP + 0
   \   000034   85..83       MOV       DPH,?XSP + 1
   \   000037   12....       LCALL     ??Subroutine102_0 & 0xFFFF
   1842              }
   1843            }
   \                     ??CrossCallReturnLabel_267:
   \   00003A   12....       LCALL     `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00003D   E9           MOV       A,R1
   \   00003E   F9           MOV       R1,A
   1844          
   1845            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   00003F   02....       LJMP      ?Subroutine8 & 0xFFFF
   1846          }
   1847          
   1848          /******************************************************************************
   1849           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1850           *
   1851           * @brief       Decide whether device is allowed.
   1852           *
   1853           * @param       device - [in] ZDSecMgrDevice_t, device info
   1854           *
   1855           * @return      ZStatus_t
   1856           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1857          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1858          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1859          
   1860            ZStatus_t status;
   1861            status = ZSuccess;
   \   000004   7900         MOV       R1,#0x0
   1862          
   1863            (void)device;  // Intentionally unreferenced parameter
   1864            
   1865            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1866            // the trust center to reject any newly joining devices by sending
   1867            // Remove-device to the parents.
   1868            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV       DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   7002         JNZ       ??ZDSecMgrDeviceValidateRM_0
   1869            {
   1870              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV       R1,#-0x38
   1871            }
   1872          
   1873          
   1874          
   1875          #if 0  // Taken out because the following functionality is only used for test
   1876                 // purpose. A more efficient (above) way is used. It can be put
   1877                 // back in if customers request for a white/black list feature.
   1878                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1879          
   1880            // The following code processes the device black list (stored device list)
   1881            // If the joining device is not part of the forbidden device list
   1882            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1883            // will send Remove-device and ban the device from joining.
   1884          
   1885            uint8     index;
   1886            uint8*    restricted;
   1887          
   1888            // Look through the stored device list - used for restricted devices
   1889            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1890            {
   1891              restricted = ZDSecMgrStoredDeviceList[index];
   1892          
   1893              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1894              {
   1895                // return as unknown device in regards to validation
   1896                status = ZNwkUnknownDevice;
   1897          
   1898                // break from loop
   1899                index = ZDSECMGR_STORED_DEVICES;
   1900              }
   1901            }
   1902          
   1903          #endif
   1904          
   1905            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   1906          }
   1907          
   1908          /******************************************************************************
   1909           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1910           *
   1911           * @brief       Decide whether device is allowed.
   1912           *
   1913           * @param       device - [in] ZDSecMgrDevice_t, device info
   1914           *
   1915           * @return      ZStatus_t
   1916           */
   1917          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1918          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1919          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   1920            ZStatus_t status;
   1921            uint16    ami;
   1922            uint8     key[SEC_KEY_LEN];
   1923          
   1924          
   1925            // implement EXT address and MASTER key policy here -- the total number of
   1926            // Security Manager entries should never exceed the number of EXT addresses
   1927            // and MASTER keys available
   1928            
   1929            // set status based on policy
   1930            //status = ZNwkUnknownDevice;
   1931            
   1932            // set status based on policy
   1933            status = ZSuccess; // ZNwkUnknownDevice;
   1934            
   1935            // get key based on policy
   1936            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   00000E                ; Setup parameters for call to function osal_memcpy
   \   00000E   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000011   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   000014   75..80       MOV       ?V2,#-0x80
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00001C   7C10         MOV       R4,#0x10
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7405         MOV       A,#0x5
   \   000022   12....       LCALL     ?XSTACK_DISP101_8
   \   000025   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000028   7403         MOV       A,#0x3
   \   00002A   12....       LCALL     ?DEALLOC_XSTACK8
   1937            
   1938            // if policy, store new EXT address
   1939            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002D   EE           MOV       A,R6
   \   00002E   2402         ADD       A,#0x2
   \   000030   F5..         MOV       ?V0,A
   \   000032   E4           CLR       A
   \   000033   3F           ADDC      A,R7
   \   000034   F5..         MOV       ?V1,A
   \   000036                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000036   A8..         MOV       R0,?XSP + 0
   \   000038   A9..         MOV       R1,?XSP + 1
   \   00003A   88..         MOV       ?V2,R0
   \   00003C   89..         MOV       ?V3,R1
   \   00003E   78..         MOV       R0,#?V2
   \   000040   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000043   85..82       MOV       DPL,?V0
   \   000046   85..83       MOV       DPH,?V1
   \   000049   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00004C   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00004F   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000052   7402         MOV       A,#0x2
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   \   000057   E9           MOV       A,R1
   \   000058   F5..         MOV       ?V2,A
   1940            
   1941            // set the key
   1942            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00005A                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   00005A   7402         MOV       A,#0x2
   \   00005C   12....       LCALL     ?XSTACK_DISP102_8
   \   00005F   85..82       MOV       DPL,?V0
   \   000062   85..83       MOV       DPH,?V1
   \   000065   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000068   12....       LCALL     `??ZDSecMgrMasterKeyLoad::?relay`; Banked call to: ZDSecMgrMasterKeyLoad
   1943            
   1944            // if EXT address and MASTER key available -- add device
   1945            if ( status == ZSuccess )
   \   00006B   E5..         MOV       A,?V2
   \   00006D   700F         JNZ       ??ZDSecMgrDeviceValidateCM_0
   1946            {
   1947              // add device to internal data - with control
   1948              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00006F                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00006F   85..82       MOV       DPL,?XSP + 0
   \   000072   85..83       MOV       DPH,?XSP + 1
   \   000075   12....       LCALL     ??Subroutine102_0 & 0xFFFF
   1949            }
   \                     ??CrossCallReturnLabel_268:
   \   000078   12....       LCALL     `??ZDSecMgrDeviceEntryAdd::?relay`; Banked call to: ZDSecMgrDeviceEntryAdd
   \   00007B   E9           MOV       A,R1
   \   00007C   F5..         MOV       ?V2,A
   1950          
   1951            // remove copy of key in RAM  
   1952            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   00007E                ; Setup parameters for call to function osal_memset
   \   00007E   7C10         MOV       R4,#0x10
   \   000080   7D00         MOV       R5,#0x0
   \   000082   7900         MOV       R1,#0x0
   \   000084   7402         MOV       A,#0x2
   \   000086   12....       LCALL     ?XSTACK_DISP101_8
   \   000089   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   1953          
   1954            return status;
   \   00008C   A9..         MOV       R1,?V2
   \   00008E   7412         MOV       A,#0x12
   \   000090   02....       LJMP      ?Subroutine4 & 0xFFFF
   1955          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   22           RET
   1956          
   1957          /******************************************************************************
   1958           * @fn          ZDSecMgrDeviceValidate
   1959           *
   1960           * @brief       Decide whether device is allowed.
   1961           *
   1962           * @param       device - [in] ZDSecMgrDevice_t, device info
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1966          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1967          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1968            ZStatus_t status;
   1969          
   1970          
   1971            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   701F         JNZ       ??ZDSecMgrDeviceValidate_0
   1972            {
   1973              // device may be joining with a secure flag but it is ultimately the Trust
   1974              // Center that decides -- check if expected pre configured device --
   1975              // override settings
   1976              if ( zgPreConfigKeys == TRUE )
   \   00000C   90....       MOV       DPTR,#zgPreConfigKeys
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   6401         XRL       A,#0x1
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   A3           INC       DPTR
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   7004         JNZ       ??ZDSecMgrDeviceValidate_1
   1977              {
   1978                device->secure = TRUE;
   \   00001E   7401         MOV       A,#0x1
   \   000020   8001         SJMP      ??ZDSecMgrDeviceValidate_2
   1979              }
   1980              else
   1981              {
   1982                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000022   E4           CLR       A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000023   F0           MOVX      @DPTR,A
   1983              }
   1984          
   1985              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1986              {
   1987                status = ZDSecMgrDeviceValidateCM( device );
   1988              }
   1989              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1990              {
   1991                status = ZDSecMgrDeviceValidateRM( device );
   \   000024                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000024   12....       LCALL     `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000027   E9           MOV       A,R1
   \   000028   F9           MOV       R1,A
   \   000029   8002         SJMP      ??ZDSecMgrDeviceValidate_3
   1992              }
   1993            }
   1994            else
   1995            {
   1996              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV       R1,#-0x38
   1997            }
   1998          
   1999            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2000          }
   2001          
   2002          /******************************************************************************
   2003           * @fn          ZDSecMgrDeviceJoin
   2004           *
   2005           * @brief       Try to join this device.
   2006           *
   2007           * @param       device - [in] ZDSecMgrDevice_t, device info
   2008           *
   2009           * @return      ZStatus_t
   2010           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2011          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2012          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2013            ZStatus_t status;
   2014            uint16    ami;
   2015          
   2016            // attempt to validate device
   2017            status = ZDSecMgrDeviceValidate( device );
   \   00000E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00000E   12....       LCALL     `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000011   E9           MOV       A,R1
   \   000012   F5..         MOV       ?V0,A
   2018          
   2019            if ( status == ZSuccess )
   \   000014   702D         JNZ       ??ZDSecMgrDeviceJoin_0
   2020            {
   2021              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2022              {
   2023                ZDSecMgrDeviceCtrlSetup( device );
   2024              }
   2025              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2026              {
   2027                // Add the device to the address manager
   2028                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000016                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000016   A8..         MOV       R0,?XSP + 0
   \   000018   A9..         MOV       R1,?XSP + 1
   \   00001A   88..         MOV       ?V0,R0
   \   00001C   89..         MOV       ?V1,R1
   \   00001E   78..         MOV       R0,#?V0
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000023   8E82         MOV       DPL,R6
   \   000025   8F83         MOV       DPH,R7
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   12....       LCALL     ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00002C   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   00002F   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000032   7402         MOV       A,#0x2
   \   000034   12....       LCALL     ?DEALLOC_XSTACK8
   2029                //send the nwk key data to the joining device
   2030                status = ZDSecMgrSendNwkKey( device );
   \   000037                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000037   EE           MOV       A,R6
   \   000038   FA           MOV       R2,A
   \   000039   EF           MOV       A,R7
   \   00003A   FB           MOV       R3,A
   \   00003B   12....       LCALL     `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00003E   E9           MOV       A,R1
   \   00003F   F5..         MOV       ?V0,A
   \   000041   8007         SJMP      ??ZDSecMgrDeviceJoin_1
   2031              }
   2032            }
   2033            else
   2034            {
   2035              // not allowed, remove the device
   2036              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000043                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000043   EE           MOV       A,R6
   \   000044   FA           MOV       R2,A
   \   000045   EF           MOV       A,R7
   \   000046   FB           MOV       R3,A
   \   000047   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2037            }
   2038          
   2039            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00004A   A9..         MOV       R1,?V0
   \   00004C   02....       LJMP      ?Subroutine0 & 0xFFFF
   2040          }
   2041          
   2042          /******************************************************************************
   2043           * @fn          ZDSecMgrDeviceJoinDirect
   2044           *
   2045           * @brief       Try to join this device as a direct child.
   2046           *
   2047           * @param       device - [in] ZDSecMgrDevice_t, device info
   2048           *
   2049           * @return      ZStatus_t
   2050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2051          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2052          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   2053            ZStatus_t status;
   2054          
   2055            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV       A,R1
   \   00000D   F5..         MOV       ?V0,A
   2056          
   2057            if ( status == ZSuccess )
   \   00000F   700D         JNZ       ??ZDSecMgrDeviceJoinDirect_0
   2058            {
   2059              // set association status to authenticated
   2060              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV       DPL,R6
   \   000013   8F83         MOV       DPH,R7
   \   000015   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   2061            }
   \                     ??CrossCallReturnLabel_175:
   \   000018   12....       LCALL     `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   00001B   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2062          
   2063            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV       R1,?V0
   \   000020   02....       LJMP      ??Subroutine93_0 & 0xFFFF
   2064          }
   2065          
   2066          /******************************************************************************
   2067           * @fn          ZDSecMgrDeviceJoinFwd
   2068           *
   2069           * @brief       Forward join to Trust Center.
   2070           *
   2071           * @param       device - [in] ZDSecMgrDevice_t, device info
   2072           *
   2073           * @return      ZStatus_t
   2074           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2075          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2076          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV       A,#-0x8
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2077            ZStatus_t               status;
   2078            APSME_UpdateDeviceReq_t req;
   2079          
   2080          
   2081            // forward any joining device to the Trust Center -- the Trust Center will
   2082            // decide if the device is allowed to join
   2083            status = ZSuccess;
   2084          
   2085            // forward authorization to the Trust Center
   2086            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   F0           MOVX      @DPTR,A
   2087            req.devAddr    = device->nwkAddr;
   \   000013   8A82         MOV       DPL,R2
   \   000015   8B83         MOV       DPH,R3
   \   000017   12....       LCALL     ??Subroutine89_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   12....       LCALL     ?Subroutine14 & 0xFFFF
   2088            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_0:
   \   000020   12....       LCALL     ?XSTACK_DISP0_8
   \   000023   E8           MOV       A,R0
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   E9           MOV       A,R1
   \   000027   12....       LCALL     ?Subroutine20 & 0xFFFF
   2089          
   2090            // set security status, option for router to reject if policy set
   2091            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_14:
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   A2E7         MOV       C,0xE0 /* A   */.7
   \   00002D   502E         JNC       ??ZDSecMgrDeviceJoinFwd_0
   2092            {
   2093              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00002F   A2E6         MOV       C,0xE0 /* A   */.6
   \   000031   5021         JNC       ??ZDSecMgrDeviceJoinFwd_1
   2094              {
   2095                if ( device->secure == TRUE )
   \   000033   8A82         MOV       DPL,R2
   \   000035   8B83         MOV       DPH,R3
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   6401         XRL       A,#0x1
   \   000040   7009         JNZ       ??ZDSecMgrDeviceJoinFwd_2
   2096                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000042   7406         MOV       A,#0x6
   \   000044   12....       LCALL     ?XSTACK_DISP0_8
   \   000047   7404         MOV       A,#0x4
   \   000049   803D         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2097                else
   2098                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004B   7406         MOV       A,#0x6
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   7407         MOV       A,#0x7
   \   000052   8034         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2099              }
   2100              else
   2101                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000054   7406         MOV       A,#0x6
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   7405         MOV       A,#0x5
   \   00005B   802B         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2102            }
   2103            else
   2104            {
   2105              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005D   A2E6         MOV       C,0xE0 /* A   */.6
   \   00005F   5020         JNC       ??ZDSecMgrDeviceJoinFwd_4
   2106              {
   2107                if ( device->secure == TRUE )
   \   000061   8A82         MOV       DPL,R2
   \   000063   8B83         MOV       DPH,R3
   \   000065   A3           INC       DPTR
   \   000066   A3           INC       DPTR
   \   000067   A3           INC       DPTR
   \   000068   A3           INC       DPTR
   \   000069   A3           INC       DPTR
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   6401         XRL       A,#0x1
   \   00006E   7008         JNZ       ??ZDSecMgrDeviceJoinFwd_5
   2108                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000070   7406         MOV       A,#0x6
   \   000072   12....       LCALL     ?XSTACK_DISP0_8
   \   000075   E4           CLR       A
   \   000076   8010         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2109                else
   2110                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000078   7406         MOV       A,#0x6
   \   00007A   12....       LCALL     ?XSTACK_DISP0_8
   \   00007D   7403         MOV       A,#0x3
   \   00007F   8007         SJMP      ??ZDSecMgrDeviceJoinFwd_3
   2111              }
   2112              else
   2113                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000081   7406         MOV       A,#0x6
   \   000083   12....       LCALL     ?XSTACK_DISP0_8
   \   000086   7401         MOV       A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000088   F0           MOVX      @DPTR,A
   2114            }
   2115          
   2116            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2117              req.apsSecure = TRUE;
   2118            else
   2119              req.apsSecure = FALSE;
   \   000089   7407         MOV       A,#0x7
   \   00008B   12....       LCALL     ?XSTACK_DISP0_8
   \   00008E   E4           CLR       A
   \   00008F   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   2120          
   2121            // send and APSME_UPDATE_DEVICE request to the trust center
   2122            status = APSME_UpdateDeviceReq( &req );
   2123          
   2124            return status;
   \                     ??CrossCallReturnLabel_248:
   \   000092   12....       LCALL     `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   000095   7408         MOV       A,#0x8
   \   000097   02....       LJMP      ??Subroutine81_0 & 0xFFFF
   2125          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL     ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000003   8A82         MOV       DPL,R2
   \   000005   8B83         MOV       DPH,R3
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   12....       LCALL     ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   00000C   7404         MOV       A,#0x4
   \   00000E   22           RET
   2126          
   2127          /******************************************************************************
   2128           * @fn          ZDSecMgrDeviceNew
   2129           *
   2130           * @brief       Process a new device.
   2131           *
   2132           * @param       device - [in] ZDSecMgrDevice_t, device info
   2133           *
   2134           * @return      ZStatus_t
   2135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2136          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2137          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2138            ZStatus_t status;
   2139          
   2140            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2141            {
   2142              // try to join this device
   2143              status = ZDSecMgrDeviceJoinDirect( joiner );
   2144            }
   2145            else
   2146            {
   2147              status = ZDSecMgrDeviceJoinFwd( joiner );
   2148            }
   2149          
   2150            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL     `??ZDSecMgrDeviceJoinFwd::?relay`; Banked call to: ZDSecMgrDeviceJoinFwd
   \   000007   80..         SJMP      ??Subroutine90_0
   2151          }
   2152          
   2153          /******************************************************************************
   2154           * @fn          ZDSecMgrAssocDeviceAuth
   2155           *
   2156           * @brief       Set associated device status to authenticated
   2157           *
   2158           * @param       assoc - [in, out] associated_devices_t
   2159           *
   2160           * @return      none
   2161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2162          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2163          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2164            if ( assoc != NULL )
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   600D         JZ        ??ZDSecMgrAssocDeviceAuth_0
   2165            {
   2166              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV       DPL,R2
   \   00000A   8B83         MOV       DPH,R3
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   D2E3         SETB      0xE0 /* A   */.3
   \   000014   F0           MOVX      @DPTR,A
   2167            }
   2168          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP      ??Subroutine90_0
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthInitiate
   2172           *
   2173           * @brief       Initiate entity authentication
   2174           *
   2175           * @param       responder - [in] responder EXT address
   2176           *
   2177           * @return      none
   2178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2179          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2180          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2181            APSME_AuthenticateReq_t req;
   2182          
   2183          
   2184            // make sure NWK address is available
   2185            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000015   E9           MOV       A,R1
   \   000016   601F         JZ        ??ZDSecMgrAuthInitiate_0
   2186            {
   2187              // set request fields
   2188              req.extAddr   = responder;
   \   000018   7402         MOV       A,#0x2
   \   00001A   12....       LCALL     ?XSTACK_DISP0_8
   \   00001D   EE           MOV       A,R6
   \   00001E   F0           MOVX      @DPTR,A
   \   00001F   A3           INC       DPTR
   \   000020   EF           MOV       A,R7
   \   000021   F0           MOVX      @DPTR,A
   2189              req.action    = APSME_EA_INITIATE;
   \   000022   7406         MOV       A,#0x6
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   E4           CLR       A
   \   000028   F0           MOVX      @DPTR,A
   2190              req.challenge = NULL;
   \   000029   7404         MOV       A,#0x4
   \   00002B   12....       LCALL     ?XSTACK_DISP0_8
   \   00002E   E4           CLR       A
   \   00002F   F0           MOVX      @DPTR,A
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   2191          
   2192              // start EA processing
   2193              APSME_AuthenticateReq( &req );
   2194            }
   \                     ??CrossCallReturnLabel_249:
   \   000034   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   2195          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000037   7407         MOV       A,#0x7
   \   000039   80..         SJMP      ??Subroutine92_0
   2196          
   2197          /******************************************************************************
   2198           * @fn          ZDSecMgrAuthNwkKey
   2199           *
   2200           * @brief       Handle next step in authentication process
   2201           *
   2202           * @param       none
   2203           *
   2204           * @return      none
   2205           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2206          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2207          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2208            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV       DPTR,#devState
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6405         XRL       A,#0x5
   \   00000A   700C         JNZ       ??ZDSecMgrAuthNwkKey_0
   2209            {
   2210              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2211              {
   2212                uint8 parent[Z_EXTADDR_LEN];
   2213          
   2214                // get parent's EXT address
   2215                NLME_GetCoordExtAddr( parent );
   2216          
   2217                // begin entity authentication with parent
   2218                ZDSecMgrAuthInitiate( parent );
   2219              }
   2220              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2221              {
   2222                // inform ZDO that device has been authenticated
   2223                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV       R2,#-0x80
   \   00000E   7B00         MOV       R3,#0x0
   \   000010   90....       MOV       DPTR,#ZDAppTaskID
   \   000013   E0           MOVX      A,@DPTR
   \   000014   F9           MOV       R1,A
   \   000015   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   2224              }
   2225            }
   2226          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2227          
   2228          /******************************************************************************
   2229           * PUBLIC FUNCTIONS
   2230           */
   2231          /******************************************************************************
   2232           * @fn          ZDSecMgrInit
   2233           *
   2234           * @brief       Initialize ZigBee Device Security Manager.
   2235           *
   2236           * @param       state - device initialization state
   2237           *
   2238           * @return      none
   2239           */
   2240          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2241          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2242          void ZDSecMgrAddrMgrCB( uint8           update,
   2243                                  AddrMgrEntry_t* newEntry,
   2244                                  AddrMgrEntry_t* oldEntry )
   2245          {
   2246            (void)update;
   2247            (void)newEntry;
   2248            (void)oldEntry;
   2249          }
   2250          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2251          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL     `??APSME_SecurityNM::?relay`; Banked call to: APSME_SecurityNM
   \   000007                REQUIRE ??Subroutine90_0
   \   000007                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2252          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   \   000000   02....       LJMP      ?Subroutine3 & 0xFFFF
   2253          {
   2254            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2255                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2256            {
   2257              // initialize sub modules
   2258              ZDSecMgrEntryInit(state);
   2259          
   2260              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2261              {
   2262                ZDSecMgrCtrlInit();
   2263              }
   2264          
   2265              // register with Address Manager
   2266              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2267              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2268              #endif
   2269            }
   2270          
   2271            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2272            {
   2273              // configure SKA slot data
   2274              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2275            }
   2276            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2277            {
   2278              APSME_TCAddrSetup( zgTrustCenterAddr );    
   2279            }
   2280          
   2281            if ( ZG_SECURE_ENABLED )
   2282            {
   2283              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2284              {
   2285                // setup joining permissions
   2286                ZDSecMgrPermitJoiningEnabled = TRUE;
   2287                ZDSecMgrPermitJoiningTimed   = FALSE;
   2288              }
   2289            }
   2290          
   2291            
   2292            // configure security based on security mode and type of device
   2293            ZDSecMgrConfig();
   2294          }
   2295          
   2296          /******************************************************************************
   2297           * @fn          ZDSecMgrConfig
   2298           *
   2299           * @brief       Configure ZigBee Device Security Manager.
   2300           *
   2301           * @param       none
   2302           *
   2303           * @return      none
   2304           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2305          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   02....       LJMP      ?Subroutine3 & 0xFFFF
   2306          {
   2307            if ( ZG_SECURE_ENABLED )
   2308            {
   2309              SSP_Init();
   2310          
   2311              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2312                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2313              {
   2314                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2315                {
   2316                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2317                  APSME_SecurityCM_CD();
   2318                }
   2319                else if ( ZSTACK_ROUTER_BUILD )
   2320                {
   2321                  // COMMERCIAL MODE - ROUTER DEVICE
   2322                  APSME_SecurityCM_RD();
   2323                }
   2324                else
   2325                {
   2326                  // COMMERCIAL MODE - END DEVICE
   2327                  APSME_SecurityCM_ED();
   2328                }
   2329              }
   2330              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2331              {
   2332                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2333                {
   2334                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2335                  APSME_SecurityRM_CD();
   2336                }
   2337                else if ( ZSTACK_ROUTER_BUILD )
   2338                {
   2339                  // RESIDENTIAL MODE - ROUTER DEVICE
   2340                  APSME_SecurityRM_RD();
   2341                }
   2342                else
   2343                {
   2344                  // RESIDENTIAL MODE - END DEVICE
   2345                  APSME_SecurityRM_ED();
   2346                }
   2347              }
   2348            }
   2349            else
   2350            {
   2351              // NO SECURITY
   2352              APSME_SecurityNM();
   2353            }
   2354          }
   2355          
   2356          /******************************************************************************
   2357           * @fn          ZDSecMgrPermitJoining
   2358           *
   2359           * @brief       Process request to change joining permissions.
   2360           *
   2361           * @param       duration - [in] timed duration for join in seconds
   2362           *                         - 0x00 not allowed
   2363           *                         - 0xFF allowed without timeout
   2364           *
   2365           * @return      uint8 - success(TRUE:FALSE)
   2366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2367          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2368          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   F8           MOV       R0,A
   2369            uint8 accept;
   2370          
   2371          
   2372            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   2373          
   2374            if ( duration > 0 )
   \   00000B   E8           MOV       A,R0
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ        ??ZDSecMgrPermitJoining_0
   2375            {
   2376              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV       A,#0x1
   \   000013   F0           MOVX      @DPTR,A
   2377          
   2378              if ( duration != 0xFF )
   \   000014   74FF         MOV       A,#-0x1
   \   000016   68           XRL       A,R0
   \   000017   6009         JZ        ??ZDSecMgrPermitJoining_1
   2379              {
   2380                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV       A,#0x1
   \   00001E   8001         SJMP      ??ZDSecMgrPermitJoining_2
   2381              }
   2382            }
   2383            else
   2384            {
   2385              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR       A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX      @DPTR,A
   2386            }
   2387          
   2388            accept = TRUE;
   2389          
   2390            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV       R1,#0x1
   \   000024   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2391          }
   2392          
   2393          /******************************************************************************
   2394           * @fn          ZDSecMgrPermitJoiningTimeout
   2395           *
   2396           * @brief       Process permit joining timeout
   2397           *
   2398           * @param       none
   2399           *
   2400           * @return      none
   2401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2402          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2403          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2404            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX      A,@DPTR
   \   000008   6401         XRL       A,#0x1
   \   00000A   7009         JNZ       ??ZDSecMgrPermitJoiningTimeout_0
   2405            {
   2406              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV       DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   2407              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV       DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX      @DPTR,A
   2408            }
   2409          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2410          
   2411          /******************************************************************************
   2412           * @fn          ZDSecMgrNewDeviceEvent
   2413           *
   2414           * @brief       Process a the new device event, if found reset new device
   2415           *              event/timer.
   2416           *
   2417           * @param       none
   2418           *
   2419           * @return      uint8 - found(TRUE:FALSE)
   2420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2421          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2422          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2423            uint8                 found;
   2424            ZDSecMgrDevice_t      device;
   2425            AddrMgrEntry_t        addrEntry;
   2426            associated_devices_t* assoc;
   2427            ZStatus_t             status;
   2428          
   2429            // initialize return results
   2430            found = FALSE;
   \   00000A   75..00       MOV       ?V0,#0x0
   2431          
   2432            // look for device in the security init state
   2433            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV       R1,#0x4
   \   00000F   12....       LCALL     `??AssocMatchDeviceStatus::?relay`; Banked call to: AssocMatchDeviceStatus
   \   000012   8A..         MOV       ?V2,R2
   \   000014   8B..         MOV       ?V3,R3
   \   000016   AE..         MOV       R6,?V2
   \   000018   AF..         MOV       R7,?V3
   2434          
   2435            if ( assoc != NULL )
   \   00001A   EE           MOV       A,R6
   \   00001B   4F           ORL       A,R7
   \   00001C   7003         JNZ       $+5
   \   00001E   02....       LJMP      ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   2436            {
   2437              // device found
   2438              found = TRUE;
   \   000021   75..01       MOV       ?V0,#0x1
   2439          
   2440              // check for preconfigured security
   2441              if ( zgPreConfigKeys == TRUE )
   \   000024   90....       MOV       DPTR,#zgPreConfigKeys
   \   000027   E0           MOVX      A,@DPTR
   \   000028   6401         XRL       A,#0x1
   \   00002A   7003         JNZ       ??ZDSecMgrNewDeviceEvent_1
   2442              {
   2443                // set association status to authenticated
   2444                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2445              }
   2446          
   2447              // set up device info
   2448              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002F   740A         MOV       A,#0xa
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E4           CLR       A
   \   000035   F0           MOVX      @DPTR,A
   2449              addrEntry.index = assoc->addrIdx;
   \   000036   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000039   7415         MOV       A,#0x15
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   12....       LCALL     ?Subroutine16 & 0xFFFF
   2450              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_4:
   \   000041   12....       LCALL     ?XSTACK_DISP101_8
   \   000044   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2451          
   2452              device.nwkAddr    = assoc->shortAddr;
   \   000047   8E82         MOV       DPL,R6
   \   000049   8F83         MOV       DPH,R7
   \   00004B   12....       LCALL     ?Subroutine26 & 0xFFFF
   2453              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_197:
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   A882         MOV       R0,DPL
   \   000053   A983         MOV       R1,DPH
   \   000055   7402         MOV       A,#0x2
   \   000057   12....       LCALL     ?XSTACK_DISP0_8
   \   00005A   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   2454              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_148:
   \   00005D                ; Setup parameters for call to function NLME_GetShortAddr
   \   00005D   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000060   7404         MOV       A,#0x4
   \   000062   12....       LCALL     ?XSTACK_DISP0_8
   \   000065   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   2455              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_211:
   \   000068   7406         MOV       A,#0x6
   \   00006A   12....       LCALL     ?XSTACK_DISP0_8
   \   00006D   E4           CLR       A
   \   00006E   F0           MOVX      @DPTR,A
   2456              device.devStatus  = assoc->devStatus;
   \   00006F   8E82         MOV       DPL,R6
   \   000071   8F83         MOV       DPH,R7
   \   000073   A3           INC       DPTR
   \   000074   A3           INC       DPTR
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   E0           MOVX      A,@DPTR
   \   000079   C0E0         PUSH      A
   \   00007B   7407         MOV       A,#0x7
   \   00007D   12....       LCALL     ?XSTACK_DISP0_8
   \   000080   D0E0         POP       A
   \   000082   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   2457          
   2458              // process new device
   2459              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_250:
   \   000085   12....       LCALL     `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   000088   E9           MOV       A,R1
   \   000089   F8           MOV       R0,A
   2460          
   2461              if ( status == ZSuccess )
   \   00008A   700F         JNZ       ??ZDSecMgrNewDeviceEvent_2
   2462              {
   2463                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   00008C   8E82         MOV       DPL,R6
   \   00008E   8F83         MOV       DPH,R7
   \   000090   A3           INC       DPTR
   \   000091   A3           INC       DPTR
   \   000092   A3           INC       DPTR
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C2E2         CLR       0xE0 /* A   */.2
   \   000098   F0           MOVX      @DPTR,A
   \   000099   8011         SJMP      ??ZDSecMgrNewDeviceEvent_0
   2464              }
   2465              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00009B   74C8         MOV       A,#-0x38
   \   00009D   68           XRL       A,R0
   \   00009E   700C         JNZ       ??ZDSecMgrNewDeviceEvent_0
   2466              {
   2467                AssocRemove( addrEntry.extAddr );
   \   0000A0                ; Setup parameters for call to function AssocRemove
   \   0000A0   740D         MOV       A,#0xd
   \   0000A2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A5   AA82         MOV       R2,DPL
   \   0000A7   AB83         MOV       R3,DPH
   \   0000A9   12....       LCALL     `??AssocRemove::?relay`; Banked call to: AssocRemove
   2468              }
   2469            }
   2470          
   2471            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000AC   A9..         MOV       R1,?V0
   \   0000AE   7417         MOV       A,#0x17
   \   0000B0   02....       LJMP      ?Subroutine4 & 0xFFFF
   2472          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000003                REQUIRE ??Subroutine94_0
   \   000003                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine104_0
   \   000004                ; // Fall through to label ??Subroutine104_0
   2473          
   2474          /******************************************************************************
   2475           * @fn          ZDSecMgrEvent
   2476           *
   2477           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2478           *
   2479           * @param       none
   2480           *
   2481           * @return      none
   2482           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2483          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2484          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV       A,#-0x17
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2485            uint8            action;
   2486            uint8            restart;
   2487            uint16           index;
   2488            AddrMgrEntry_t   entry;
   2489            ZDSecMgrDevice_t device;
   2490          
   2491          
   2492            // verify data is available
   2493            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00000D   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??ZDSecMgrEvent_0 & 0xFFFF
   2494            {
   2495              action  = FALSE;
   \   000015   75..00       MOV       ?V1,#0x0
   2496              restart = FALSE;
   \   000018   75..00       MOV       ?V0,#0x0
   2497          
   2498              // update all the counters
   2499              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7E00         MOV       R6,#0x0
   \   00001D   7F00         MOV       R7,#0x0
   2500              {
   2501                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_1:
   \   00001F   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000022   E0           MOVX      A,@DPTR
   \   000023   7003         JNZ       $+5
   \   000025   02....       LJMP      ??ZDSecMgrEvent_2 & 0xFFFF
   2502                {
   2503                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   000028   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00002B   6005         JZ        ??ZDSecMgrEvent_3
   2504                  {
   2505                    ZDSecMgrCtrlData[index].cntr--;
   \   00002D   12....       LCALL     ?Subroutine35 & 0xFFFF
   2506                  }
   \                     ??CrossCallReturnLabel_35:
   \   000030   14           DEC       A
   \   000031   F0           MOVX      @DPTR,A
   2507          
   2508                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   000032   E5..         MOV       A,?V1
   \   000034   A2E0         MOV       C,0xE0 /* A   */.0
   \   000036   5003         JNC       $+5
   \   000038   02....       LJMP      ??ZDSecMgrEvent_4 & 0xFFFF
   \   00003B   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   00003E   6003         JZ        $+5
   \   000040   02....       LJMP      ??ZDSecMgrEvent_4 & 0xFFFF
   2509                  {
   2510                    action = TRUE;
   \   000043   75..01       MOV       ?V1,#0x1
   \   000046   EE           MOV       A,R6
   \   000047   F8           MOV       R0,A
   \   000048   EF           MOV       A,R7
   \   000049   F9           MOV       R1,A
   \   00004A   E8           MOV       A,R0
   \   00004B   75F007       MOV       B,#0x7
   \   00004E   A4           MUL       AB
   \   00004F   F8           MOV       R0,A
   \   000050   AAF0         MOV       R2,B
   \   000052   75F007       MOV       B,#0x7
   \   000055   E9           MOV       A,R1
   \   000056   A4           MUL       AB
   \   000057   2A           ADD       A,R2
   \   000058   F9           MOV       R1,A
   \   000059   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   00005C   12....       LCALL     ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   00005F   F9           MOV       R1,A
   \   000060   8882         MOV       DPL,R0
   \   000062   8983         MOV       DPH,R1
   \   000064   A3           INC       DPTR
   \   000065   A3           INC       DPTR
   \   000066   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000069   7404         MOV       A,#0x4
   \   00006B   12....       LCALL     ?XSTACK_DISP0_8
   \   00006E   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   2511          
   2512                    // update from control data
   2513                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   2514                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_212:
   \   000071   8882         MOV       DPL,R0
   \   000073   8983         MOV       DPH,R1
   \   000075   A3           INC       DPTR
   \   000076   A3           INC       DPTR
   \   000077   A3           INC       DPTR
   \   000078   A3           INC       DPTR
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   C0E0         PUSH      A
   \   00007C   7406         MOV       A,#0x6
   \   00007E   12....       LCALL     ?XSTACK_DISP0_8
   \   000081   D0E0         POP       A
   \   000083   F0           MOVX      @DPTR,A
   2515                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   000084   7408         MOV       A,#0x8
   \   000086   12....       LCALL     ?XSTACK_DISP0_8
   \   000089   12....       LCALL     ?Subroutine16 & 0xFFFF
   2516          
   2517                    // set the user and address index
   2518                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_5:
   \   00008C   12....       LCALL     ?XSTACK_DISP0_8
   \   00008F   7402         MOV       A,#0x2
   \   000091   12....       LCALL     ?Subroutine28 & 0xFFFF
   2519                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \                     ??CrossCallReturnLabel_23:
   \   000094   F583         MOV       DPH,A
   \   000096   8882         MOV       DPL,R0
   \   000098   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00009B   7415         MOV       A,#0x15
   \   00009D   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A0   12....       LCALL     ?Subroutine16 & 0xFFFF
   2520          
   2521                    // get the address data
   2522                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_6:
   \   0000A3   12....       LCALL     ?XSTACK_DISP101_8
   \   0000A6   12....       LCALL     `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   2523          
   2524                    // set device address data
   2525                    device.nwkAddr = entry.nwkAddr;
   \   0000A9   740B         MOV       A,#0xb
   \   0000AB   12....       LCALL     ?XSTACK_DISP0_8
   \   0000AE   12....       LCALL     ?Subroutine26 & 0xFFFF
   2526                    device.extAddr = entry.extAddr;
   2527          
   2528                    // update from entry data
   2529                    ZDSecMgrDeviceCtrlHandler( &device );
   2530                  }
   \                     ??CrossCallReturnLabel_198:
   \   0000B1   12....       LCALL     ?XSTACK_DISP0_8
   \   0000B4   A882         MOV       R0,DPL
   \   0000B6   A983         MOV       R1,DPH
   \   0000B8   7402         MOV       A,#0x2
   \   0000BA   12....       LCALL     ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   0000C0   12....       LCALL     `??ZDSecMgrDeviceCtrlHandler::?relay`; Banked call to: ZDSecMgrDeviceCtrlHandler
   \   0000C3   8003         SJMP      ??ZDSecMgrEvent_2
   2531                  else
   2532                  {
   2533                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   0000C5   75..01       MOV       ?V0,#0x1
   2534                  }
   2535                }
   2536              }
   \                     ??ZDSecMgrEvent_2:
   \   0000C8   0E           INC       R6
   \   0000C9   EE           MOV       A,R6
   \   0000CA   7001         JNZ       ??ZDSecMgrEvent_5
   \   0000CC   0F           INC       R7
   \                     ??ZDSecMgrEvent_5:
   \   0000CD   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   0000D0   5003         JNC       $+5
   \   0000D2   02....       LJMP      ??ZDSecMgrEvent_1 & 0xFFFF
   2537          
   2538              // check for timer restart
   2539              if ( restart == TRUE )
   \   0000D5   E5..         MOV       A,?V0
   \   0000D7   A2E0         MOV       C,0xE0 /* A   */.0
   \   0000D9   5010         JNC       ??ZDSecMgrEvent_0
   2540              {
   2541                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000DB                ; Setup parameters for call to function osal_start_timerEx
   \   0000DB   7C64         MOV       R4,#0x64
   \   0000DD   7D00         MOV       R5,#0x0
   \   0000DF   7A00         MOV       R2,#0x0
   \   0000E1   7B01         MOV       R3,#0x1
   \   0000E3   90....       MOV       DPTR,#ZDAppTaskID
   \   0000E6   E0           MOVX      A,@DPTR
   \   0000E7   F9           MOV       R1,A
   \   0000E8   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   2542              }
   2543            }
   2544          }
   \                     ??ZDSecMgrEvent_0:
   \   0000EB   7417         MOV       A,#0x17
   \   0000ED   02....       LJMP      ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL     ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   EE           MOV       A,R6
   \   000001   F8           MOV       R0,A
   \   000002   EF           MOV       A,R7
   \   000003   F9           MOV       R1,A
   \   000004   E8           MOV       A,R0
   \   000005   75F007       MOV       B,#0x7
   \   000008   A4           MUL       AB
   \   000009   F8           MOV       R0,A
   \   00000A   AAF0         MOV       R2,B
   \   00000C   75F007       MOV       B,#0x7
   \   00000F   E9           MOV       A,R1
   \   000010   A4           MUL       AB
   \   000011   2A           ADD       A,R2
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#ZDSecMgrCtrlData
   \   000016   E0           MOVX      A,@DPTR
   \   000017   28           ADD       A,R0
   \   000018   FA           MOV       R2,A
   \   000019   A3           INC       DPTR
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   39           ADDC      A,R1
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   F583         MOV       DPH,A
   \   000020   A3           INC       DPTR
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   A3           INC       DPTR
   \   000024   A3           INC       DPTR
   \   000025   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004                REQUIRE ??Subroutine98_0
   \   000004                ; // Fall through to label ??Subroutine98_0
   2545          
   2546          /******************************************************************************
   2547           * @fn          ZDSecMgrEstablishKeyCfm
   2548           *
   2549           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2550           *
   2551           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2552           *
   2553           * @return      none
   2554           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2555          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2556          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2557            // send the NWK key
   2558            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2559            {
   2560              // update control for specified EXT address
   2561              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2562            }
   2563            else
   2564            {
   2565              // this should be done when receiving the NWK key
   2566              // if devState ==
   2567              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2568                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2569          
   2570              // if not in joining state -- this should trigger an event for an
   2571              // end point that requested SKKE
   2572              // if ( devState == DEV_END_DEVICE )
   2573             //       devState == DEV_ROUTER;
   2574          
   2575            }
   2576          }
   \   000000   02....       LJMP      ?BRET
   2577          
   2578          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2579          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2580          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2581            uint8  match;
   2582            uint8  lookup[Z_EXTADDR_LEN];
   2583          
   2584            match = FALSE;
   \   00000E   75..00       MOV       ?V0,#0x0
   2585          
   2586            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   AC..         MOV       R4,?XSP + 0
   \   000013   AD..         MOV       R5,?XSP + 1
   \   000015   7A00         MOV       R2,#0x0
   \   000017   7B00         MOV       R3,#0x0
   \   000019   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   00001C   E9           MOV       A,R1
   \   00001D   600E         JZ        ??ZDSecMgrTCExtAddrCheck_0
   2587            {
   2588              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   00001F   EE           MOV       A,R6
   \   000020   FC           MOV       R4,A
   \   000021   EF           MOV       A,R7
   \   000022   FD           MOV       R5,A
   \   000023   AA..         MOV       R2,?XSP + 0
   \   000025   AB..         MOV       R3,?XSP + 1
   \   000027   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00002A   E9           MOV       A,R1
   \   00002B   F5..         MOV       ?V0,A
   2589            }
   2590          
   2591            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   00002D   A9..         MOV       R1,?V0
   \   00002F   7408         MOV       A,#0x8
   \   000031   02....       LJMP      ??Subroutine92_0 & 0xFFFF
   2592          }
   2593          
   2594          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2595          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2596          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2597            uint16 ami;
   2598            uint16 keyNvId;   
   2599            uint8 masterKey[SEC_KEY_LEN];
   2600          
   2601            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   7074         JNZ       ??ZDSecMgrTCDataLoad_0
   2602            {
   2603              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V0,R0
   \   000016   89..         MOV       ?V1,R1
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   EA           MOV       A,R2
   \   00001E   FC           MOV       R4,A
   \   00001F   EB           MOV       A,R3
   \   000020   FD           MOV       R5,A
   \   000021   7A00         MOV       R2,#0x0
   \   000023   7B00         MOV       R3,#0x0
   \   000025   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002D   E9           MOV       A,R1
   \   00002E   704E         JNZ       ??ZDSecMgrTCDataLoad_1
   2604              {
   2605                // if preconfigured load key
   2606                if ( zgPreConfigKeys == TRUE )
   \   000030   90....       MOV       DPTR,#zgPreConfigKeys
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6401         XRL       A,#0x1
   \   000036   7046         JNZ       ??ZDSecMgrTCDataLoad_1
   2607                {
   2608                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000038   7402         MOV       A,#0x2
   \   00003A   12....       LCALL     ?XSTACK_DISP102_8
   \   00003D   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000040   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000043   E9           MOV       A,R1
   \   000044   6038         JZ        ??ZDSecMgrTCDataLoad_1
   2609                  {
   2610                    // temporary copy
   2611                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000046                ; Setup parameters for call to function osal_memcpy
   \   000046   75....       MOV       ?V0,#ZDSecMgrTCMasterKey & 0xff
   \   000049   75....       MOV       ?V1,#(ZDSecMgrTCMasterKey >> 8) & 0xff
   \   00004C   75..80       MOV       ?V2,#-0x80
   \   00004F   78..         MOV       R0,#?V0
   \   000051   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000054   7C10         MOV       R4,#0x10
   \   000056   7D00         MOV       R5,#0x0
   \   000058   7407         MOV       A,#0x7
   \   00005A   12....       LCALL     ?XSTACK_DISP101_8
   \   00005D   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000060   7403         MOV       A,#0x3
   \   000062   12....       LCALL     ?DEALLOC_XSTACK8
   2612          
   2613                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   000065                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000065   7404         MOV       A,#0x4
   \   000067   12....       LCALL     ?XSTACK_DISP102_8
   \   00006A   12....       LCALL     ??Subroutine87_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   00006D   12....       LCALL     `??ZDSecMgrMasterKeyStore::?relay`; Banked call to: ZDSecMgrMasterKeyStore
   2614                      
   2615                    // remove copy of key in RAM  
   2616                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \   000070                ; Setup parameters for call to function osal_memset
   \   000070   7C10         MOV       R4,#0x10
   \   000072   7D00         MOV       R5,#0x0
   \   000074   7900         MOV       R1,#0x0
   \   000076   7404         MOV       A,#0x4
   \   000078   12....       LCALL     ?XSTACK_DISP101_8
   \   00007B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2617                  }
   2618                }
   2619              }
   2620          
   2621              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??ZDSecMgrTCDataLoad_1:
   \   00007E   90....       MOV       DPTR,#ZDSecMgrTCDataLoaded
   \   000081   7401         MOV       A,#0x1
   \   000083   F0           MOVX      @DPTR,A
   2622            }
   2623          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000084   7414         MOV       A,#0x14
   \   000086                REQUIRE ?Subroutine5
   \   000086                ; // Fall through to label ?Subroutine5

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F03         MOV       R7,#0x3
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
   2624          
   2625          /******************************************************************************
   2626           * @fn          ZDSecMgrEstablishKeyInd
   2627           *
   2628           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2629           *
   2630           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2631           *
   2632           * @return      none
   2633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2634          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2635          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV       A,#-0x11
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2636            ZDSecMgrDevice_t        device;
   2637            APSME_EstablishKeyRsp_t rsp;
   2638          
   2639          
   2640            // load Trust Center data if needed
   2641            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   EE           MOV       A,R6
   \   00000F   2404         ADD       A,#0x4
   \   000011   F5..         MOV       ?V0,A
   \   000013   E4           CLR       A
   \   000014   3F           ADDC      A,R7
   \   000015   F5..         MOV       ?V1,A
   \   000017                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000017   AA..         MOV       R2,?V0
   \   000019   FB           MOV       R3,A
   \   00001A   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2642          
   2643            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00001D                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00001D   AA..         MOV       R2,?V0
   \   00001F   AB..         MOV       R3,?V1
   \   000021   12....       LCALL     `??ZDSecMgrTCExtAddrCheck::?relay`; Banked call to: ZDSecMgrTCExtAddrCheck
   \   000024   E9           MOV       A,R1
   \   000025   6013         JZ        ??ZDSecMgrEstablishKeyInd_0
   2644            {
   2645              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2646              //OR
   2647              //!ZDSecMgrTCAuthenticated
   2648              //devtag.0604.critical
   2649                  //how is the parentAddr used here
   2650          
   2651              // initial SKKE from Trust Center via parent
   2652              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000027   7407         MOV       A,#0x7
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   12....       LCALL     ?Subroutine18 & 0xFFFF
   2653              device.parentAddr = ind->srcAddr;
   2654            }
   \                     ??CrossCallReturnLabel_10:
   \   00002F   740B         MOV       A,#0xb
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   E8           MOV       A,R0
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E9           MOV       A,R1
   \   000038   8015         SJMP      ??ZDSecMgrEstablishKeyInd_1
   2655            else
   2656            {
   2657              // Trust Center direct or E2E SKKE
   2658              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00003A   12....       LCALL     ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00003D   7407         MOV       A,#0x7
   \   00003F   12....       LCALL     ?XSTACK_DISP0_8
   \   000042   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   2659              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_149:
   \   000045   740B         MOV       A,#0xb
   \   000047   12....       LCALL     ?XSTACK_DISP0_8
   \   00004A   74FE         MOV       A,#-0x2
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   04           INC       A
   2660            }
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   00004F   12....       LCALL     ?Subroutine62 & 0xFFFF
   2661          
   2662            device.extAddr = ind->initExtAddr;
   \                     ??CrossCallReturnLabel_235:
   \   000052   7409         MOV       A,#0x9
   \   000054   12....       LCALL     ?XSTACK_DISP0_8
   \   000057   E8           MOV       A,R0
   \   000058   F0           MOVX      @DPTR,A
   \   000059   A3           INC       DPTR
   \   00005A   E9           MOV       A,R1
   \   00005B   12....       LCALL     ?Subroutine22 & 0xFFFF
   2663            //devtag.pro.security.0724.todo - verify usage
   2664            device.secure  = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_15:
   \   00005E   C0E0         PUSH      A
   \   000060   740D         MOV       A,#0xd
   \   000062   12....       LCALL     ?XSTACK_DISP0_8
   \   000065   D0E0         POP       A
   \   000067   F0           MOVX      @DPTR,A
   2665          
   2666            // validate device for SKKE
   2667            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000068                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000068   7407         MOV       A,#0x7
   \   00006A   12....       LCALL     ?XSTACK_DISP101_8
   \   00006D   12....       LCALL     `??ZDSecMgrDeviceValidateSKKE::?relay`; Banked call to: ZDSecMgrDeviceValidateSKKE
   \   000070   E9           MOV       A,R1
   \   000071   7009         JNZ       ??ZDSecMgrEstablishKeyInd_2
   2668            {
   2669              rsp.accept = TRUE;
   \   000073   7404         MOV       A,#0x4
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   7401         MOV       A,#0x1
   \   00007A   8006         SJMP      ??ZDSecMgrEstablishKeyInd_3
   2670            }
   2671            else
   2672            {
   2673              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00007C   7404         MOV       A,#0x4
   \   00007E   12....       LCALL     ?XSTACK_DISP0_8
   \   000081   E4           CLR       A
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000082   F0           MOVX      @DPTR,A
   2674            }
   2675          
   2676            rsp.dstAddr     = ind->srcAddr;
   \   000083   12....       LCALL     ?Subroutine15 & 0xFFFF
   2677            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_232:
   \   000086   12....       LCALL     ?XSTACK_DISP0_8
   \   000089   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   2678            //devtag.0604.todo - remove obsolete
   2679            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_150:
   \   00008C   EE           MOV       A,R6
   \   00008D   240D         ADD       A,#0xd
   \   00008F   F582         MOV       DPL,A
   \   000091   E4           CLR       A
   \   000092   3F           ADDC      A,R7
   \   000093   F583         MOV       DPH,A
   \   000095   E0           MOVX      A,@DPTR
   \   000096   C0E0         PUSH      A
   \   000098   7405         MOV       A,#0x5
   \   00009A   12....       LCALL     ?XSTACK_DISP0_8
   \   00009D   D0E0         POP       A
   \   00009F   12....       LCALL     ?Subroutine22 & 0xFFFF
   2680            rsp.nwkSecure   = ind->nwkSecure;
   \                     ??CrossCallReturnLabel_16:
   \   0000A2   C0E0         PUSH      A
   \   0000A4   7406         MOV       A,#0x6
   \   0000A6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000A9   D0E0         POP       A
   \   0000AB   12....       LCALL     ??Subroutine98_0 & 0xFFFF
   2681          
   2682            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_251:
   \   0000AE   12....       LCALL     `??APSME_EstablishKeyRsp::?relay`; Banked call to: APSME_EstablishKeyRsp
   2683          }
   \   0000B1   7411         MOV       A,#0x11
   \   0000B3   02....       LJMP      ??Subroutine85_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   EE           MOV       A,R6
   \   000002   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   12....       LCALL     ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000009   E8           MOV       A,R0
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   E9           MOV       A,R1
   \   00000D                REQUIRE ??Subroutine97_0
   \   00000D                ; // Fall through to label ??Subroutine97_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   12....       LCALL     ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   7402         MOV       A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   EE           MOV       A,R6
   \   000002   2404         ADD       A,#0x4
   \   000004   F8           MOV       R0,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F9           MOV       R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   240E         ADD       A,#0xe
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F583         MOV       DPH,A
   \   000008   22           RET
   2684          //devtag.pro.security
   2685          #if 0
   2686          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2687          {
   2688            ZDSecMgrDevice_t        device;
   2689            APSME_EstablishKeyRsp_t rsp;
   2690          
   2691          
   2692            device.extAddr = ind->initExtAddr;
   2693            device.secure  = ind->secure;
   2694          
   2695            if ( ind->secure == FALSE )
   2696            {
   2697              // SKKE from Trust Center is not secured between child and parent
   2698              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2699              device.parentAddr = ind->srcAddr;
   2700            }
   2701            else
   2702            {
   2703              // SKKE from initiator should be secured
   2704              device.nwkAddr    = ind->srcAddr;
   2705              device.parentAddr = INVALID_NODE_ADDR;
   2706            }
   2707          
   2708            rsp.dstAddr     = ind->srcAddr;
   2709            rsp.initExtAddr = &ind->initExtAddr[0];
   2710            rsp.secure      = ind->secure;
   2711          
   2712            // validate device for SKKE
   2713            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2714            {
   2715              rsp.accept = TRUE;
   2716            }
   2717            else
   2718            {
   2719              rsp.accept = FALSE;
   2720            }
   2721          
   2722            APSME_EstablishKeyRsp( &rsp );
   2723          }
   2724          #endif
   2725          
   2726          /******************************************************************************
   2727           * @fn          ZDSecMgrTransportKeyInd
   2728           *
   2729           * @brief       Process the ZDO_TransportKeyInd_t message.
   2730           *
   2731           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2732           *
   2733           * @return      none
   2734           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2735          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2736          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2737            uint8 index;
   2738            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2739          
   2740            // load Trust Center data if needed
   2741            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00000E   EE           MOV       A,R6
   \   00000F   2416         ADD       A,#0x16
   \   000011   FA           MOV       R2,A
   \   000012   E4           CLR       A
   \   000013   3F           ADDC      A,R7
   \   000014   FB           MOV       R3,A
   \   000015   12....       LCALL     `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   2742          
   2743            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000018   8E82         MOV       DPL,R6
   \   00001A   8F83         MOV       DPH,R7
   \   00001C   A3           INC       DPTR
   \   00001D   A3           INC       DPTR
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   7003         JNZ       $+5
   \   000023   02....       LJMP      ??ZDSecMgrTransportKeyInd_0 & 0xFFFF
   2744            {
   2745              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2746              //ZDSecMgrTCMasterKey( ind );
   2747              {
   2748                if ( zgPreConfigKeys != TRUE )
   2749                {
   2750                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2751                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2752                }
   2753                else
   2754                {
   2755                  // error condition - reject key
   2756                }
   2757              }
   2758            }
   2759            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2760                      ( ind->keyType == 6                 ) ||
   2761                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000026   6401         XRL       A,#0x1
   \   000028   601A         JZ        ??ZDSecMgrTransportKeyInd_1
   \   00002A   8E82         MOV       DPL,R6
   \   00002C   8F83         MOV       DPH,R7
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E0           MOVX      A,@DPTR
   \   000033   6406         XRL       A,#0x6
   \   000035   600D         JZ        ??ZDSecMgrTransportKeyInd_1
   \   000037   8E82         MOV       DPL,R6
   \   000039   8F83         MOV       DPH,R7
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E0           MOVX      A,@DPTR
   \   000040   6405         XRL       A,#0x5
   \   000042   7077         JNZ       ??ZDSecMgrTransportKeyInd_0
   2762            {
   2763              // check for dummy NWK key (all zeros)
   2764              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000044   7800         MOV       R0,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000046   E8           MOV       A,R0
   \   000047   FA           MOV       R2,A
   \   000048   EE           MOV       A,R6
   \   000049   2A           ADD       A,R2
   \   00004A   F582         MOV       DPL,A
   \   00004C   E4           CLR       A
   \   00004D   3F           ADDC      A,R7
   \   00004E   F583         MOV       DPH,A
   \   000050   A3           INC       DPTR
   \   000051   A3           INC       DPTR
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   E0           MOVX      A,@DPTR
   \   000057   7007         JNZ       ??ZDSecMgrTransportKeyInd_3
   2765                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2766                    index++ );
   \   000059   08           INC       R0
   \   00005A   E8           MOV       A,R0
   \   00005B   C3           CLR       C
   \   00005C   9410         SUBB      A,#0x10
   \   00005E   40E6         JC        ??ZDSecMgrTransportKeyInd_2
   2767          
   2768              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000060   7410         MOV       A,#0x10
   \   000062   68           XRL       A,R0
   \   000063   702E         JNZ       ??ZDSecMgrTransportKeyInd_4
   2769              {
   2770                // load preconfigured key - once!!
   2771                if ( !_NIB.nwkKeyLoaded )
   \   000065   90....       MOV       DPTR,#_NIB + 61
   \   000068   E0           MOVX      A,@DPTR
   \   000069   704D         JNZ       ??ZDSecMgrTransportKeyInd_5
   2772                {
   2773                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00006B                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00006B   AC..         MOV       R4,?XSP + 0
   \   00006D   AD..         MOV       R5,?XSP + 1
   \   00006F   7A62         MOV       R2,#0x62
   \   000071   7B00         MOV       R3,#0x0
   \   000073   12....       LCALL     `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   2774                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000076                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000076   7900         MOV       R1,#0x0
   \   000078   AA..         MOV       R2,?XSP + 0
   \   00007A   AB..         MOV       R3,?XSP + 1
   \   00007C   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2775                  SSP_SwitchNwkKey( 0 );
   \   00007F                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007F   7900         MOV       R1,#0x0
   \   000081   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2776                  
   2777                  // clear local copy of key
   2778                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000084                ; Setup parameters for call to function osal_memset
   \   000084   7C10         MOV       R4,#0x10
   \   000086   7D00         MOV       R5,#0x0
   \   000088   7900         MOV       R1,#0x0
   \   00008A   AA..         MOV       R2,?XSP + 0
   \   00008C   AB..         MOV       R3,?XSP + 1
   \   00008E   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   \   000091   8025         SJMP      ??ZDSecMgrTransportKeyInd_5
   2779                }
   2780              }
   2781              else
   2782              {
   2783                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000093                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000093   8E82         MOV       DPL,R6
   \   000095   8F83         MOV       DPH,R7
   \   000097   A3           INC       DPTR
   \   000098   A3           INC       DPTR
   \   000099   A3           INC       DPTR
   \   00009A   A3           INC       DPTR
   \   00009B   A3           INC       DPTR
   \   00009C   E0           MOVX      A,@DPTR
   \   00009D   F9           MOV       R1,A
   \   00009E   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0000A1   12....       LCALL     `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   2784                if ( !_NIB.nwkKeyLoaded )
   \   0000A4   90....       MOV       DPTR,#_NIB + 61
   \   0000A7   E0           MOVX      A,@DPTR
   \   0000A8   700E         JNZ       ??ZDSecMgrTransportKeyInd_5
   2785                {
   2786                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000AA                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000AA   8E82         MOV       DPL,R6
   \   0000AC   8F83         MOV       DPH,R7
   \   0000AE   A3           INC       DPTR
   \   0000AF   A3           INC       DPTR
   \   0000B0   A3           INC       DPTR
   \   0000B1   A3           INC       DPTR
   \   0000B2   A3           INC       DPTR
   \   0000B3   E0           MOVX      A,@DPTR
   \   0000B4   F9           MOV       R1,A
   \   0000B5   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2787                }
   2788              }
   2789          
   2790              // handle next step in authentication process
   2791              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000B8                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000B8   12....       LCALL     `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   2792            }
   2793            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2794            {
   2795              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2796              {
   2797                // This should not happen because TCLK should not be Tx
   2798              }
   2799            }
   2800            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2801            {
   2802              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2803              {
   2804                uint16           ami;
   2805                AddrMgrEntry_t   entry;
   2806                ZDSecMgrEntry_t* entryZD;
   2807          
   2808                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2809          
   2810                if ( ind->initiator == TRUE )
   2811                {
   2812                  // get the ami data
   2813                  entry.user  = ADDRMGR_USER_SECURITY;
   2814                  entry.index = ami;
   2815                  AddrMgrEntryGet( &entry );
   2816          
   2817                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2818                  {
   2819                    APSME_EstablishKeyReq_t req;
   2820                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2821          
   2822                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2823          
   2824                    if ( entryZD == NULL )
   2825                    {
   2826                      // get new entry
   2827                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2828                      {
   2829                        // finish setting up entry
   2830                        entryZD->ami = ami;
   2831                      }
   2832                    }
   2833          
   2834                    req.respExtAddr = ind->srcExtAddr;
   2835                    req.method      = APSME_SKKE_METHOD;
   2836                    req.dstAddr     = entry.nwkAddr;
   2837                    req.apsSecure   = FALSE;
   2838                    req.nwkSecure   = TRUE;
   2839                    APSME_EstablishKeyReq( &req );
   2840                  }
   2841                }
   2842                else
   2843                {
   2844                  if ( ami == INVALID_NODE_ADDR )
   2845                  {
   2846                    // store new EXT address
   2847                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2848                  }
   2849          
   2850                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2851                }
   2852              }
   2853            }
   2854            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2855            {
   2856              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2857              {
   2858                uint16           ami;
   2859                ZDSecMgrEntry_t* entry;
   2860          
   2861                // get the address index
   2862                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2863                {
   2864                  // store new EXT address
   2865                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2866                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2867                }
   2868          
   2869                ZDSecMgrEntryLookupAMI( ami, &entry );
   2870          
   2871                if ( entry == NULL )
   2872                {
   2873                  // get new entry
   2874                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2875                  {
   2876                    // finish setting up entry
   2877                    entry->ami = ami;
   2878                  }
   2879                }
   2880          
   2881                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2882              }
   2883            }
   2884          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   0000BB   7410         MOV       A,#0x10
   \   0000BD   02....       LJMP      ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   EE           MOV       A,R6
   \   000001   2406         ADD       A,#0x6
   \   000003   FA           MOV       R2,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   FB           MOV       R3,A
   \   000007   22           RET
   2885          
   2886          /******************************************************************************
   2887           * @fn          ZDSecMgrUpdateDeviceInd
   2888           *
   2889           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2890           *
   2891           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2892           *
   2893           * @return      none
   2894           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   740A         MOV       A,#0xa
   \   000002                REQUIRE ??Subroutine81_0
   \   000002                ; // Fall through to label ??Subroutine81_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2895          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2896          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2897            ZDSecMgrDevice_t device;
   2898          
   2899          
   2900            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV       A,R2
   \   00000A   240C         ADD       A,#0xc
   \   00000C   F582         MOV       DPL,A
   \   00000E   E4           CLR       A
   \   00000F   3B           ADDC      A,R3
   \   000010   F583         MOV       DPH,A
   \   000012   12....       LCALL     ?Subroutine27 & 0xFFFF
   2901            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_156:
   \   000015   EA           MOV       A,R2
   \   000016   2404         ADD       A,#0x4
   \   000018   F8           MOV       R0,A
   \   000019   E4           CLR       A
   \   00001A   3B           ADDC      A,R3
   \   00001B   F9           MOV       R1,A
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   12....       LCALL     ?Subroutine14 & 0xFFFF
   2902            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_1:
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   12....       LCALL     ?Subroutine10 & 0xFFFF
   2903          
   2904            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2905            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2906            //{
   2907            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2908            //  {
   2909            //    device.secure = TRUE;
   2910            //  }
   2911            //  else
   2912            //  {
   2913            //    device.secure = FALSE;
   2914            //  }
   2915          
   2916              // try to join this device
   2917              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_238:
   \   00002A   12....       LCALL     `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   2918            //}
   2919          }
   \   00002D   02....       LJMP      ?Subroutine9 & 0xFFFF
   2920          
   2921          /******************************************************************************
   2922           * @fn          ZDSecMgrRemoveDeviceInd
   2923           *
   2924           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2925           *
   2926           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2927           *
   2928           * @return      none
   2929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2930          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2931          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV       A,#-0xa
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2932            ZDSecMgrDevice_t device;
   2933          
   2934          
   2935            // only accept from Trust Center
   2936            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV       DPL,R6
   \   000010   8F83         MOV       DPH,R7
   \   000012   A3           INC       DPTR
   \   000013   A3           INC       DPTR
   \   000014   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000017   702B         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2937            {
   2938              // look up NWK address
   2939              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000019                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000019   AC..         MOV       R4,?XSP + 0
   \   00001B   AD..         MOV       R5,?XSP + 1
   \   00001D   EE           MOV       A,R6
   \   00001E   2404         ADD       A,#0x4
   \   000020   FA           MOV       R2,A
   \   000021   E4           CLR       A
   \   000022   3F           ADDC      A,R7
   \   000023   FB           MOV       R3,A
   \   000024   12....       LCALL     `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV       A,R1
   \   000028   6401         XRL       A,#0x1
   \   00002A   7018         JNZ       ??ZDSecMgrRemoveDeviceInd_0
   2940              {
   2941                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL     `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV       A,#0x4
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   EA           MOV       A,R2
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   EB           MOV       A,R3
   \   000038   12....       LCALL     ??Subroutine97_0 & 0xFFFF
   2942                device.extAddr    = ind->childExtAddr;
   2943          
   2944                // remove device
   2945                ZDSecMgrDeviceRemove( &device );
   2946              }
   2947            }
   \                     ??CrossCallReturnLabel_234:
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000041   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2948          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000044   740A         MOV       A,#0xa
   \   000046   02....       LJMP      ??Subroutine92_0 & 0xFFFF
   2949          
   2950          /******************************************************************************
   2951           * @fn          ZDSecMgrRequestKeyInd
   2952           *
   2953           * @brief       Process the ZDO_RequestKeyInd_t message.
   2954           *
   2955           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2960          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2961            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   6401         XRL       A,#0x1
   \   00000F   6010         JZ        ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963            }
   2964            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000011   8A82         MOV       DPL,R2
   \   000013   8B83         MOV       DPH,R3
   \   000015   A3           INC       DPTR
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   6402         XRL       A,#0x2
   \   00001C   7003         JNZ       ??ZDSecMgrRequestKeyInd_0
   2965            {
   2966              ZDSecMgrAppKeyReq( ind );
   \   00001E                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   00001E   12....       LCALL     `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   2967            }
   2968            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2969            {
   2970            }
   2971            //else ignore
   2972          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000021   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2973          
   2974          /******************************************************************************
   2975           * @fn          ZDSecMgrSwitchKeyInd
   2976           *
   2977           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2978           *
   2979           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2980           *
   2981           * @return      none
   2982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2983          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2984          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2985            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   E0           MOVX      A,@DPTR
   \   00000D   F9           MOV       R1,A
   \   00000E   12....       LCALL     `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   2986          
   2987            // Save if nv
   2988            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL     `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   2989          }
   \   000014   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   2990          
   2991          /******************************************************************************
   2992           * @fn          ZDSecMgrAuthenticateInd
   2993           *
   2994           * @brief       Process the ZDO_AuthenticateInd_t message.
   2995           *
   2996           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2997           *
   2998           * @return      none
   2999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3000          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3001          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   3002            APSME_AuthenticateReq_t req;
   3003            AddrMgrEntry_t          entry;
   3004          
   3005          
   3006            // update the address manager
   3007            //---------------------------------------------------------------------------
   3008            // note:
   3009            // required for EA processing, but ultimately EA logic could also use the
   3010            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3011            // table is supposed to have authentication states for neighbors
   3012            //---------------------------------------------------------------------------
   3013            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV       A,#0x7
   \   000010   12....       LCALL     ?XSTACK_DISP0_8
   \   000013   7402         MOV       A,#0x2
   \   000015   12....       LCALL     ?Subroutine19 & 0xFFFF
   3014            entry.nwkAddr = ind->aps.initNwkAddr;
   \                     ??CrossCallReturnLabel_12:
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   3015            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_151:
   \   00001E                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001E   EE           MOV       A,R6
   \   00001F   2404         ADD       A,#0x4
   \   000021   FC           MOV       R4,A
   \   000022   E4           CLR       A
   \   000023   3F           ADDC      A,R7
   \   000024   FD           MOV       R5,A
   \   000025   740A         MOV       A,#0xa
   \   000027   12....       LCALL     ?XSTACK_DISP0_8
   \   00002A   AA82         MOV       R2,DPL
   \   00002C   AB83         MOV       R3,DPH
   \   00002E   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3016          
   3017            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000031                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000031   7407         MOV       A,#0x7
   \   000033   12....       LCALL     ?XSTACK_DISP101_8
   \   000036   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000039   E9           MOV       A,R1
   \   00003A   6401         XRL       A,#0x1
   \   00003C   7023         JNZ       ??ZDSecMgrAuthenticateInd_0
   3018            {
   3019              // set request fields
   3020              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00003E   12....       LCALL     ?Subroutine15 & 0xFFFF
   3021              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_233:
   \   000041   12....       LCALL     ?XSTACK_DISP0_8
   \   000044   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   3022              req.action    = APSME_EA_ACCEPT;
   \                     ??CrossCallReturnLabel_152:
   \   000047   7406         MOV       A,#0x6
   \   000049   12....       LCALL     ?XSTACK_DISP0_8
   \   00004C   7401         MOV       A,#0x1
   \   00004E   F0           MOVX      @DPTR,A
   3023              req.challenge = ind->aps.challenge;
   \   00004F   EE           MOV       A,R6
   \   000050   240C         ADD       A,#0xc
   \   000052   F8           MOV       R0,A
   \   000053   E4           CLR       A
   \   000054   3F           ADDC      A,R7
   \   000055   F9           MOV       R1,A
   \   000056   7404         MOV       A,#0x4
   \   000058   12....       LCALL     ?XSTACK_DISP0_8
   \   00005B   12....       LCALL     ?Subroutine10 & 0xFFFF
   3024          
   3025              // start EA processing
   3026              APSME_AuthenticateReq( &req );
   3027            }
   \                     ??CrossCallReturnLabel_240:
   \   00005E   12....       LCALL     `??APSME_AuthenticateReq::?relay`; Banked call to: APSME_AuthenticateReq
   3028          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000061   7414         MOV       A,#0x14
   \   000063   02....       LJMP      ??Subroutine92_0 & 0xFFFF
   3029          
   3030          /******************************************************************************
   3031           * @fn          ZDSecMgrAuthenticateCfm
   3032           *
   3033           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3034           *
   3035           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3036           *
   3037           * @return      none
   3038           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3039          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3040          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3041            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV       A,R2
   \   000005   240B         ADD       A,#0xb
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   3B           ADDC      A,R3
   \   00000B   F583         MOV       DPH,A
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   701F         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3042            {
   3043              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000010   8A82         MOV       DPL,R2
   \   000012   8B83         MOV       DPH,R3
   \   000014   A3           INC       DPTR
   \   000015   A3           INC       DPTR
   \   000016   E0           MOVX      A,@DPTR
   \   000017   6401         XRL       A,#0x1
   \   000019   7014         JNZ       ??ZDSecMgrAuthenticateCfm_0
   \   00001B   90....       MOV       DPTR,#devState
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   6405         XRL       A,#0x5
   \   000021   700C         JNZ       ??ZDSecMgrAuthenticateCfm_0
   3044              {
   3045                // inform ZDO that device has been authenticated
   3046                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000023                ; Setup parameters for call to function osal_set_event
   \   000023   7A80         MOV       R2,#-0x80
   \   000025   7B00         MOV       R3,#0x0
   \   000027   90....       MOV       DPTR,#ZDAppTaskID
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F9           MOV       R1,A
   \   00002C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   3047              }
   3048            }
   3049          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002F   02....       LJMP      ??Subroutine90_0 & 0xFFFF
   3050          
   3051          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3052          /******************************************************************************
   3053           * @fn          ZDSecMgrUpdateNwkKey
   3054           *
   3055           * @brief       Load a new NWK key and trigger a network wide update.
   3056           *
   3057           * @param       key       - [in] new NWK key
   3058           * @param       keySeqNum - [in] new NWK key sequence number
   3059           *
   3060           * @return      ZStatus_t
   3061           */
   3062          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3063          {
   3064            ZStatus_t               status;
   3065            APSME_TransportKeyReq_t req;
   3066          
   3067            // initialize common elements of local variables
   3068            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3069              req.keyType   = KEY_TYPE_NWK_HIGH;
   3070            else
   3071              req.keyType   = KEY_TYPE_NWK;
   3072          
   3073            req.dstAddr   = dstAddr;
   3074            req.keySeqNum = keySeqNum;
   3075            req.key       = key;
   3076            req.extAddr   = NULL;
   3077            req.nwkSecure = TRUE;
   3078            req.apsSecure = TRUE;
   3079            req.tunnel    = NULL;
   3080          
   3081            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3082            {
   3083              ZDSecMgrEntry_t*        entry;
   3084              uint16                  index;
   3085              AddrMgrEntry_t          addrEntry;
   3086          
   3087              addrEntry.user = ADDRMGR_USER_SECURITY;
   3088          
   3089              status = ZFailure;
   3090          
   3091              // verify data is available
   3092              if ( ZDSecMgrEntries != NULL )
   3093              {
   3094                // find available entry
   3095                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3096                {
   3097                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3098                  {
   3099                    // return successful result
   3100                    entry = &ZDSecMgrEntries[index];
   3101          
   3102                    // get NWK address
   3103                    addrEntry.index = entry->ami;
   3104                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3105                    {
   3106                      req.dstAddr = addrEntry.nwkAddr;
   3107                      req.extAddr = addrEntry.extAddr;
   3108                      status = APSME_TransportKeyReq( &req );
   3109                    }
   3110                  }
   3111                }
   3112              }
   3113            }
   3114            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3115            {
   3116              status = APSME_TransportKeyReq( &req );
   3117            }
   3118          
   3119            SSP_UpdateNwkKey( key, keySeqNum );
   3120          
   3121            // Save if nv
   3122            ZDApp_NVUpdate();
   3123          
   3124            return status;
   3125          }
   3126          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3127          
   3128          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3129          /******************************************************************************
   3130           * @fn          ZDSecMgrSwitchNwkKey
   3131           *
   3132           * @brief       Causes the NWK key to switch via a network wide command.
   3133           *
   3134           * @param       keySeqNum - [in] new NWK key sequence number
   3135           *
   3136           * @return      ZStatus_t
   3137           */
   3138          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3139          {
   3140            ZStatus_t            status;
   3141            APSME_SwitchKeyReq_t req;
   3142          
   3143            // initialize common elements of local variables
   3144            req.dstAddr = dstAddr;
   3145            req.keySeqNum = keySeqNum;
   3146          
   3147            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3148            {
   3149              ZDSecMgrEntry_t*     entry;
   3150              uint16               index;
   3151              AddrMgrEntry_t       addrEntry;
   3152          
   3153              addrEntry.user = ADDRMGR_USER_SECURITY;
   3154          
   3155              status = ZFailure;
   3156          
   3157              // verify data is available
   3158              if ( ZDSecMgrEntries != NULL )
   3159              {
   3160                // find available entry
   3161                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3162                {
   3163                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3164                  {
   3165                    // return successful result
   3166                    entry = &ZDSecMgrEntries[index];
   3167          
   3168                    // get NWK address
   3169                    addrEntry.index = entry->ami;
   3170          
   3171                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3172                    {
   3173                      req.dstAddr = addrEntry.nwkAddr;
   3174                      status = APSME_SwitchKeyReq( &req );
   3175                    }
   3176                  }
   3177                }
   3178              }
   3179            }
   3180            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3181            {
   3182              status = APSME_SwitchKeyReq( &req );
   3183            }
   3184          
   3185            SSP_SwitchNwkKey( keySeqNum );
   3186          
   3187            // Save if nv
   3188            ZDApp_NVUpdate();
   3189          
   3190            return status;
   3191          }
   3192          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3193          
   3194          #if ( ZG_BUILD_JOINING_TYPE )
   3195          /******************************************************************************
   3196           * @fn          ZDSecMgrRequestAppKey
   3197           *
   3198           * @brief       Request an application key with partner.
   3199           *
   3200           * @param       partNwkAddr - [in] partner network address
   3201           *
   3202           * @return      ZStatus_t
   3203           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3204          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3205          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV       A,#-0xc
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3206            ZStatus_t             status;
   3207            APSME_RequestKeyReq_t req;
   3208            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3209          
   3210          
   3211            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV       A,#0x4
   \   00000B   12....       LCALL     ?XSTACK_DISP102_8
   \   00000E   12....       LCALL     `??AddrMgrExtAddrLookup::?relay`; Banked call to: AddrMgrExtAddrLookup
   \   000011   E9           MOV       A,R1
   \   000012   6023         JZ        ??ZDSecMgrRequestAppKey_0
   3212            {
   3213              req.dstAddr = 0;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   3214              req.keyType = KEY_TYPE_APP_MASTER;
   \   00001C   04           INC       A
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   7402         MOV       A,#0x2
   \   000022   F0           MOVX      @DPTR,A
   3215              req.partExtAddr = partExtAddr;
   \   000023   7404         MOV       A,#0x4
   \   000025   12....       LCALL     ?XSTACK_DISP100_8
   \   000028   7402         MOV       A,#0x2
   \   00002A   12....       LCALL     ?XSTACK_DISP0_8
   \   00002D   12....       LCALL     ?Subroutine10 & 0xFFFF
   3216              status = APSME_RequestKeyReq( &req );
   3217            }
   \                     ??CrossCallReturnLabel_241:
   \   000030   12....       LCALL     `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000033   E9           MOV       A,R1
   \   000034   F9           MOV       R1,A
   \   000035   8002         SJMP      ??ZDSecMgrRequestAppKey_1
   3218            else
   3219            {
   3220              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   000037   7901         MOV       R1,#0x1
   3221            }
   3222          
   3223            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   000039   740C         MOV       A,#0xc
   \   00003B   02....       LJMP      ??Subroutine81_0 & 0xFFFF
   3224          }
   3225          #endif // ( ZG_BUILD_JOINING_TYPE )
   3226          
   3227          #if ( ZG_BUILD_JOINING_TYPE )
   3228          /******************************************************************************
   3229           * @fn          ZDSecMgrSetupPartner
   3230           *
   3231           * @brief       Setup for application key partner.
   3232           *
   3233           * @param       partNwkAddr - [in] partner network address
   3234           *
   3235           * @return      ZStatus_t
   3236           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3237          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3238          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV       A,#-0xd
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V0,R4
   \   000010   8D..         MOV       ?V1,R5
   3239            AddrMgrEntry_t entry;
   3240            ZStatus_t      status;
   3241          
   3242            status = ZFailure;
   \   000012   75..01       MOV       ?V2,#0x1
   3243          
   3244            // update the address manager
   3245            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV       DPL,?XSP + 0
   \   000018   85..83       MOV       DPH,?XSP + 1
   \   00001B   7402         MOV       A,#0x2
   \   00001D   F0           MOVX      @DPTR,A
   3246            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC       A
   \   00001F   12....       LCALL     ?XSTACK_DISP0_8
   \   000022   EE           MOV       A,R6
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   EF           MOV       A,R7
   \   000026   F0           MOVX      @DPTR,A
   3247            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000027                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000027   7403         MOV       A,#0x3
   \   000029   12....       LCALL     ?XSTACK_DISP0_8
   \   00002C   AA82         MOV       R2,DPL
   \   00002E   AB83         MOV       R3,DPH
   \   000030   12....       LCALL     `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   3248          
   3249            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000033                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000033   AA..         MOV       R2,?XSP + 0
   \   000035   AB..         MOV       R3,?XSP + 1
   \   000037   12....       LCALL     `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00003A   E9           MOV       A,R1
   \   00003B   6401         XRL       A,#0x1
   \   00003D   7036         JNZ       ??ZDSecMgrSetupPartner_0
   3250            {
   3251              status = ZSuccess;
   \   00003F   75..00       MOV       ?V2,#0x0
   3252          
   3253              // check for address discovery
   3254              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000042   74FE         MOV       A,#-0x2
   \   000044   6E           XRL       A,R6
   \   000045   7003         JNZ       ??ZDSecMgrSetupPartner_1
   \   000047   74FF         MOV       A,#-0x1
   \   000049   6F           XRL       A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   00004A   700F         JNZ       ??ZDSecMgrSetupPartner_2
   3255              {
   3256                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00004C                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00004C   7D00         MOV       R5,#0x0
   \   00004E   7C00         MOV       R4,#0x0
   \   000050   7900         MOV       R1,#0x0
   \   000052   AA..         MOV       R2,?V0
   \   000054   AB..         MOV       R3,?V1
   \   000056   12....       LCALL     `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   \   000059   8017         SJMP      ??ZDSecMgrSetupPartner_3
   3257              }
   3258              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00005B                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00005B   AA..         MOV       R2,?V0
   \   00005D   AB..         MOV       R3,?V1
   \   00005F   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000062   E9           MOV       A,R1
   \   000063   7010         JNZ       ??ZDSecMgrSetupPartner_0
   3259              {
   3260                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000065                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000065   7D00         MOV       R5,#0x0
   \   000067   7C00         MOV       R4,#0x0
   \   000069   7900         MOV       R1,#0x0
   \   00006B   EE           MOV       A,R6
   \   00006C   FA           MOV       R2,A
   \   00006D   EF           MOV       A,R7
   \   00006E   FB           MOV       R3,A
   \   00006F   12....       LCALL     `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_3:
   \   000072   E9           MOV       A,R1
   \   000073   F5..         MOV       ?V2,A
   3261              }
   3262            }
   3263          
   3264            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000075   A9..         MOV       R1,?V2
   \   000077   740D         MOV       A,#0xd
   \   000079   02....       LJMP      ?Subroutine5 & 0xFFFF
   3265          }
   3266          #endif // ( ZG_BUILD_JOINING_TYPE )
   3267          
   3268          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3269          /******************************************************************************
   3270           * @fn          ZDSecMgrAppKeyTypeSet
   3271           *
   3272           * @brief       Set application key type.
   3273           *
   3274           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3275           *                                                   KEY_TYPE_APP_LINK@3
   3276           *
   3277           * @return      ZStatus_t
   3278           */
   3279          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3280          {
   3281            if ( keyType == KEY_TYPE_APP_LINK )
   3282            {
   3283              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3284            }
   3285            else
   3286            {
   3287              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3288            }
   3289          
   3290            return ZSuccess;
   3291          }
   3292          #endif
   3293          
   3294          /******************************************************************************
   3295           * ZigBee Device Security Manager - Stub Implementations
   3296           */
   3297          /******************************************************************************
   3298           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3299           *
   3300           * @brief       Get MASTER key for specified EXT address.
   3301           *
   3302           * @param       extAddr - [in] EXT address
   3303           * @param       pKeyNvId - [out] MASTER key NV ID
   3304           *
   3305           * @return      ZStatus_t
   3306           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3307          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3308          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3309            ZStatus_t status;
   3310            uint16 ami;
   3311          
   3312          
   3313            // lookup entry for specified EXT address
   3314            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV       A,R1
   \   000016   F5..         MOV       ?V0,A
   3315          
   3316            if ( status == ZSuccess )
   \   000018   7008         JNZ       ??APSME_MasterKeyGet_0
   3317            {
   3318              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   00001A                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00001A   12....       LCALL     ?Subroutine33 & 0xFFFF
   3319            }
   \                     ??CrossCallReturnLabel_191:
   \   00001D   12....       LCALL     `??ZDSecMgrMasterKeyLookup::?relay`; Banked call to: ZDSecMgrMasterKeyLookup
   \   000020   8008         SJMP      ??APSME_MasterKeyGet_1
   3320            else
   3321            {
   3322              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   000022   8E82         MOV       DPL,R6
   \   000024   8F83         MOV       DPH,R7
   \   000026   E4           CLR       A
   \   000027   F0           MOVX      @DPTR,A
   \   000028   A3           INC       DPTR
   \   000029   F0           MOVX      @DPTR,A
   3323            }
   3324          
   3325            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   00002A   02....       LJMP      ?Subroutine1 & 0xFFFF
   3326          }
   3327          
   3328          /******************************************************************************
   3329           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3330           *
   3331           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3332           *
   3333           * @param       extAddr - [in] EXT address
   3334           * @param       data    - [in] APSME_LinkKeyData_t
   3335           *
   3336           * @return      ZStatus_t
   3337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3338          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3339          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8C..         MOV       ?V2,R4
   \   00000C   8D..         MOV       ?V3,R5
   3340            ZStatus_t status;
   3341            ZDSecMgrEntry_t* entry;
   3342            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3343            uint16 Index;
   3344          
   3345            // lookup entry index for specified EXT address
   3346            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index ); 
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP102_8
   \   000021   12....       LCALL     `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV       A,#0x2
   \   000026   12....       LCALL     ?DEALLOC_XSTACK8
   \   000029   E9           MOV       A,R1
   \   00002A   FE           MOV       R6,A
   3347          
   3348            if ( status == ZSuccess )
   \   00002B   6003         JZ        $+5
   \   00002D   02....       LJMP      ??CrossCallReturnLabel_255 & 0xFFFF
   3349            {
   3350              // point to NV item
   3351              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   E0           MOVX      A,@DPTR
   \   000036   2401         ADD       A,#0x1
   \   000038   F8           MOV       R0,A
   \   000039   A3           INC       DPTR
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   3402         ADDC      A,#0x2
   \   00003D   F9           MOV       R1,A
   \   00003E   85..82       MOV       DPL,?XSP + 0
   \   000041   85..83       MOV       DPH,?XSP + 1
   \   000044   12....       LCALL     ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   000047   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   3352          
   3353              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_153:
   \   00004A                ; Setup parameters for call to function osal_mem_alloc
   \   00004A   7A18         MOV       R2,#0x18
   \   00004C   7B00         MOV       R3,#0x0
   \   00004E   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000051   8A..         MOV       ?V0,R2
   \   000053   8B..         MOV       ?V1,R3
   3354          
   3355              if (pApsLinkKey != NULL)
   \   000055   EA           MOV       A,R2
   \   000056   45..         ORL       A,?V1
   \   000058   7003         JNZ       $+5
   \   00005A   02....       LJMP      ??CrossCallReturnLabel_255 & 0xFFFF
   3356              {
   3357                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3358                osal_nv_read( entry->keyNvId, 0, 
   3359                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00005D                ; Setup parameters for call to function osal_nv_read
   \   00005D   78..         MOV       R0,#?V0
   \   00005F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000062   75..18       MOV       ?V4,#0x18
   \   000065   75..00       MOV       ?V5,#0x0
   \   000068   78..         MOV       R0,#?V4
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006D   7C00         MOV       R4,#0x0
   \   00006F   7D00         MOV       R5,#0x0
   \   000071   7404         MOV       A,#0x4
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   12....       LCALL     ??Subroutine101_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000079   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   00007C   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007F   7404         MOV       A,#0x4
   \   000081   12....       LCALL     ?DEALLOC_XSTACK8
   3360                
   3361                // set new values of the key 
   3362                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   000084                ; Setup parameters for call to function osal_memcpy
   \   000084   85....       MOV       ?V4,?V2
   \   000087   85....       MOV       ?V5,?V3
   \   00008A   75..00       MOV       ?V6,#0x0
   \   00008D   78..         MOV       R0,#?V4
   \   00008F   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000092   7C10         MOV       R4,#0x10
   \   000094   7D00         MOV       R5,#0x0
   \   000096   AA..         MOV       R2,?V0
   \   000098   AB..         MOV       R3,?V1
   \   00009A   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00009D   7403         MOV       A,#0x3
   \   00009F   12....       LCALL     ?DEALLOC_XSTACK8
   3363                pApsLinkKey->rxFrmCntr = 0;
   \   0000A2   E5..         MOV       A,?V0
   \   0000A4   2414         ADD       A,#0x14
   \   0000A6   12....       LCALL     ?Subroutine11 & 0xFFFF
   3364                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_256:
   \   0000A9   E5..         MOV       A,?V0
   \   0000AB   2410         ADD       A,#0x10
   \   0000AD   12....       LCALL     ?Subroutine11 & 0xFFFF
   3365                
   3366                osal_nv_write( entry->keyNvId, 0, 
   3367                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_257:
   \   0000B0                ; Setup parameters for call to function osal_nv_write
   \   0000B0   78..         MOV       R0,#?V0
   \   0000B2   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B5   75..18       MOV       ?V2,#0x18
   \   0000B8   75..00       MOV       ?V3,#0x0
   \   0000BB   78..         MOV       R0,#?V2
   \   0000BD   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C0   7C00         MOV       R4,#0x0
   \   0000C2   7D00         MOV       R5,#0x0
   \   0000C4   7404         MOV       A,#0x4
   \   0000C6   12....       LCALL     ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL     ??Subroutine101_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   0000CC   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   0000CF   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000D2   7404         MOV       A,#0x4
   \   0000D4   12....       LCALL     ?DEALLOC_XSTACK8
   3368                
   3369                // clear copy of key in RAM 
   3370                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000D7                ; Setup parameters for call to function osal_memset
   \   0000D7   7C18         MOV       R4,#0x18
   \   0000D9   7D00         MOV       R5,#0x0
   \   0000DB   7900         MOV       R1,#0x0
   \   0000DD   AA..         MOV       R2,?V0
   \   0000DF   AB..         MOV       R3,?V1
   \   0000E1   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3371                
   3372                osal_mem_free(pApsLinkKey);
   \   0000E4                ; Setup parameters for call to function osal_mem_free
   \   0000E4   AA..         MOV       R2,?V0
   \   0000E6   AB..         MOV       R3,?V1
   \   0000E8   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000EB   12....       LCALL     ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   0000EE   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   0000F1   E8           MOV       A,R0
   \   0000F2   75F009       MOV       B,#0x9
   \   0000F5   A4           MUL       AB
   \   0000F6   F8           MOV       R0,A
   \   0000F7   AAF0         MOV       R2,B
   \   0000F9   75F009       MOV       B,#0x9
   \   0000FC   E9           MOV       A,R1
   \   0000FD   A4           MUL       AB
   \   0000FE   2A           ADD       A,R2
   \   0000FF   F9           MOV       R1,A
   \   000100   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   000102   28           ADD       A,R0
   \   000103   F8           MOV       R0,A
   \   000104   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000106   39           ADDC      A,R1
   \   000107   F9           MOV       R1,A
   \   000108   E8           MOV       A,R0
   \   000109   24F7         ADD       A,#-0x9
   \   00010B   F582         MOV       DPL,A
   \   00010D   E9           MOV       A,R1
   \   00010E   34ED         ADDC      A,#-0x13
   \   000110   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   3373                
   3374                // set initial values for counters in RAM
   3375                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3376                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_254:
   \   000113   E8           MOV       A,R0
   \   000114   24FB         ADD       A,#-0x5
   \   000116   F582         MOV       DPL,A
   \   000118   E9           MOV       A,R1
   \   000119   34ED         ADDC      A,#-0x13
   \   00011B   12....       LCALL     ??Subroutine99_0 & 0xFFFF
   3377              }
   3378            }
   3379          
   3380            return status;
   \                     ??CrossCallReturnLabel_255:
   \   00011E   EE           MOV       A,R6
   \   00011F   F9           MOV       R1,A
   \   000120   7404         MOV       A,#0x4
   \   000122   12....       LCALL     ?DEALLOC_XSTACK8
   \   000125   7F07         MOV       R7,#0x7
   \   000127   02....       LJMP      ?BANKED_LEAVE_XDATA
   3381          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   F582         MOV       DPL,A
   \   000002   E4           CLR       A
   \   000003   35..         ADDC      A,?V1
   \   000005                REQUIRE ??Subroutine99_0
   \   000005                ; // Fall through to label ??Subroutine99_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine100_0
   \   000002                ; // Fall through to label ??Subroutine100_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   E4           CLR       A
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   F0           MOVX      @DPTR,A
   \   000004   A3           INC       DPTR
   \   000005   F0           MOVX      @DPTR,A
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   85..82       MOV       DPL,?XSP + 0
   \   000003   85..83       MOV       DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine101_0
   \   000006                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   12....       LCALL     ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   22           RET
   3382          
   3383          /******************************************************************************
   3384           * @fn          ZDSecMgrAuthenticationSet
   3385           *
   3386           * @brief       Mark the specific device as authenticated or not
   3387           *
   3388           * @param       extAddr - [in] EXT address
   3389           * @param       option  - [in] authenticated or not
   3390           *
   3391           * @return      ZStatus_t
   3392           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3393          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3394          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   3395            ZStatus_t        status;
   3396            ZDSecMgrEntry_t* entry;
   3397          
   3398          
   3399            // lookup entry index for specified EXT address
   3400            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV       R4,?XSP + 0
   \   00000E   AD..         MOV       R5,?XSP + 1
   \   000010   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV       A,R1
   \   000014   F9           MOV       R1,A
   3401          
   3402            if ( status == ZSuccess )
   \   000015   7007         JNZ       ??ZDSecMgrAuthenticationSet_0
   3403            {
   3404              entry->authenticateOption = option;
   \   000017   12....       LCALL     ?Subroutine41 & 0xFFFF
   3405            }
   \                     ??CrossCallReturnLabel_261:
   \   00001A   A3           INC       DPTR
   \   00001B   A3           INC       DPTR
   \   00001C   EE           MOV       A,R6
   \   00001D   F0           MOVX      @DPTR,A
   3406          
   3407            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00001E   02....       LJMP      ??Subroutine91_0 & 0xFFFF
   3408          }
   3409          
   3410          /******************************************************************************
   3411           * @fn          ZDSecMgrAuthenticationCheck
   3412           *
   3413           * @brief       Check if the specific device has been authenticated or not
   3414           *              For non-trust center device, always return true
   3415           *
   3416           * @param       shortAddr - [in] short address
   3417           *
   3418           * @return      TRUE @ authenticated with CBKE
   3419           *              FALSE @ not authenticated
   3420           */
   3421          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3422          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3423          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3424          #if defined (TC_LINKKEY_JOIN)
   3425          
   3426            ZDSecMgrEntry_t* entry;
   3427            uint8 extAddr[Z_EXTADDR_LEN];
   3428          
   3429            // If the local device is not the trust center, always return TRUE
   3430            if ( NLME_GetShortAddr() != TCshortAddr )
   3431            {
   3432              return TRUE;
   3433            }
   3434            // Otherwise, check the authentication option
   3435            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3436            {
   3437              // lookup entry index for specified EXT address
   3438              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3439              {
   3440                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3441                {
   3442                  return TRUE;
   3443                }
   3444                else
   3445                {
   3446                  return FALSE;
   3447                }
   3448              }
   3449            }
   3450            return FALSE;
   3451          
   3452          #else
   3453            (void)shortAddr;  // Intentionally unreferenced parameter
   3454            
   3455            // For non AMI/SE Profile, perform no check and always return true.
   3456            return TRUE;
   \   000000   7901         MOV       R1,#0x1
   \   000002   02....       LJMP      ?BRET
   3457          
   3458          #endif // TC_LINKKEY_JOIN
   3459          }
   3460          
   3461          
   3462          /******************************************************************************
   3463           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3464           *
   3465           * @brief       Get Key NV ID for specified NWK address.
   3466           *
   3467           * @param       extAddr - [in] EXT address
   3468           * @param       keyNvId - [out] NV ID
   3469           *
   3470           * @return      ZStatus_t
   3471           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3472          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3473          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV       A,#-0x2
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3474            ZStatus_t status;
   3475            ZDSecMgrEntry_t* entry;
   3476          
   3477            // lookup entry index for specified NWK address
   3478            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV       R4,?XSP + 0
   \   000010   AD..         MOV       R5,?XSP + 1
   \   000012   12....       LCALL     `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV       A,R1
   \   000016   F9           MOV       R1,A
   3479          
   3480            if ( status == ZSuccess )
   \   000017   7010         JNZ       ??APSME_LinkKeyNVIdGet_0
   3481            {
   3482              // return the index to the NV table
   3483              *pKeyNvId = entry->keyNvId;
   \   000019   12....       LCALL     ?Subroutine41 & 0xFFFF
   3484            }
   \                     ??CrossCallReturnLabel_262:
   \   00001C   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   00001F   8E82         MOV       DPL,R6
   \   000021   8F83         MOV       DPH,R7
   \   000023   EA           MOV       A,R2
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   EB           MOV       A,R3
   \   000027   8007         SJMP      ??APSME_LinkKeyNVIdGet_1
   3485            else
   3486            {
   3487              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   E4           CLR       A
   \   00002E   F0           MOVX      @DPTR,A
   \   00002F   A3           INC       DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000030   F0           MOVX      @DPTR,A
   3488            }
   3489          
   3490            return status;
   \   000031   02....       LJMP      ??Subroutine91_0 & 0xFFFF
   3491          }
   3492          
   3493          /******************************************************************************
   3494           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3495           *
   3496           * @brief       Verifies if Link Key in NV has been set.
   3497           *
   3498           * @param       extAddr - [in] EXT address
   3499           *
   3500           * @return      TRUE - Link Key has been established
   3501           *              FALSE - Link Key in NV has default value.
   3502           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3503          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3504          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV       A,#-0x12
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   3505            APSME_LinkKeyData_t *pKeyData = NULL;
   3506            uint16 apsLinkKeyNvId;
   3507            uint8 nullKey[SEC_KEY_LEN];
   3508            uint8 status = FALSE;
   \   00000E   7E00         MOV       R6,#0x0
   3509          
   3510            // initialize default vealue to compare to
   3511            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000010                ; Setup parameters for call to function osal_memset
   \   000010   7C10         MOV       R4,#0x10
   \   000012   7D00         MOV       R5,#0x0
   \   000014   7900         MOV       R1,#0x0
   \   000016   7402         MOV       A,#0x2
   \   000018   12....       LCALL     ?XSTACK_DISP101_8
   \   00001B   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3512          
   3513            // check for APS link NV ID
   3514            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001E                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001E   AC..         MOV       R4,?XSP + 0
   \   000020   AD..         MOV       R5,?XSP + 1
   \   000022   AA..         MOV       R2,?V0
   \   000024   AB..         MOV       R3,?V1
   \   000026   12....       LCALL     `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   3515          
   3516            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   000029   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   00002C   6063         JZ        ??APSME_IsLinkKeyValid_0
   3517            {
   3518              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00002E                ; Setup parameters for call to function osal_mem_alloc
   \   00002E   7A18         MOV       R2,#0x18
   \   000030   7B00         MOV       R3,#0x0
   \   000032   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000035   8A..         MOV       ?V4,R2
   \   000037   8B..         MOV       ?V5,R3
   3519              
   3520              if (pKeyData != NULL)
   \   000039   EA           MOV       A,R2
   \   00003A   45..         ORL       A,?V5
   \   00003C   6053         JZ        ??APSME_IsLinkKeyValid_0
   3521              {
   3522                // retrieve key from NV
   3523                if ( osal_nv_read( apsLinkKeyNvId, 0, 
   3524                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   00003E                ; Setup parameters for call to function osal_nv_read
   \   00003E   78..         MOV       R0,#?V4
   \   000040   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000043   75..18       MOV       ?V0,#0x18
   \   000046   8E..         MOV       ?V1,R6
   \   000048   78..         MOV       R0,#?V0
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004D   7C00         MOV       R4,#0x0
   \   00004F   7D00         MOV       R5,#0x0
   \   000051   7404         MOV       A,#0x4
   \   000053   12....       LCALL     ?XSTACK_DISP0_8
   \   000056   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   000059   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00005C   7404         MOV       A,#0x4
   \   00005E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000061   E9           MOV       A,R1
   \   000062   702D         JNZ       ??APSME_IsLinkKeyValid_0
   3525                {
   3526                  // if stored key is different than default value, then a key has been established
   3527                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000064                ; Setup parameters for call to function osal_memcmp
   \   000064   7402         MOV       A,#0x2
   \   000066   12....       LCALL     ?XSTACK_DISP100_8
   \   000069   88..         MOV       ?V0,R0
   \   00006B   89..         MOV       ?V1,R1
   \   00006D   8E..         MOV       ?V2,R6
   \   00006F   78..         MOV       R0,#?V0
   \   000071   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000074   7C10         MOV       R4,#0x10
   \   000076   7D00         MOV       R5,#0x0
   \   000078   85..82       MOV       DPL,?V4
   \   00007B   85..83       MOV       DPH,?V5
   \   00007E   A982         MOV       R1,DPL
   \   000080   AA83         MOV       R2,DPH
   \   000082   7B00         MOV       R3,#0x0
   \   000084   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000087   7403         MOV       A,#0x3
   \   000089   12....       LCALL     ?DEALLOC_XSTACK8
   \   00008C   E9           MOV       A,R1
   \   00008D   7002         JNZ       ??APSME_IsLinkKeyValid_0
   3528                  {
   3529                    status = TRUE;
   \   00008F   7E01         MOV       R6,#0x1
   3530                  }
   3531                }
   3532              }
   3533            }
   3534          
   3535            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   000091   EE           MOV       A,R6
   \   000092   F9           MOV       R1,A
   \   000093   02....       LJMP      ?Subroutine2 & 0xFFFF
   3536          }
   3537          
   3538          /******************************************************************************
   3539           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3540           *
   3541           * @brief       Verify and process key transportation to child.
   3542           *
   3543           * @param       ind - [in] APSME_TransportKeyInd_t
   3544           *
   3545           * @return      uint8 - success(TRUE:FALSE)
   3546           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3547          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3548          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3549            uint8 success;
   3550          
   3551            success = FALSE;
   \   000005   7E00         MOV       R6,#0x0
   3552          
   3553            // verify from Trust Center
   3554            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV       DPL,R2
   \   000009   8B83         MOV       DPH,R3
   \   00000B   12....       LCALL     ??Subroutine96_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   00000E   7036         JNZ       ??APSME_KeyFwdToChild_0
   3555            {
   3556              success = TRUE;
   \   000010   7E01         MOV       R6,#0x1
   3557          
   3558              // check for initial NWK key
   3559              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3560                   ( ind->keyType == 6                 ) ||
   3561                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   6401         XRL       A,#0x1
   \   00001B   6016         JZ        ??APSME_KeyFwdToChild_1
   \   00001D   8A82         MOV       DPL,R2
   \   00001F   8B83         MOV       DPH,R3
   \   000021   A3           INC       DPTR
   \   000022   A3           INC       DPTR
   \   000023   E0           MOVX      A,@DPTR
   \   000024   6406         XRL       A,#0x6
   \   000026   600B         JZ        ??APSME_KeyFwdToChild_1
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   6405         XRL       A,#0x5
   \   000031   7013         JNZ       ??APSME_KeyFwdToChild_0
   3562              {
   3563                // set association status to authenticated
   3564                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000033                ; Setup parameters for call to function AssocGetWithExt
   \   000033   8A82         MOV       DPL,R2
   \   000035   8B83         MOV       DPH,R3
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   3565              }
   3566            }
   \                     ??CrossCallReturnLabel_181:
   \   000040   12....       LCALL     `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000043                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000043   12....       LCALL     `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   3567          
   3568            return success;
   \                     ??APSME_KeyFwdToChild_0:
   \   000046   EE           MOV       A,R6
   \   000047   F9           MOV       R1,A
   \   000048   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   3569          }
   3570          
   3571          /******************************************************************************
   3572           * @fn          ZDSecMgrAddLinkKey
   3573           *
   3574           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3575           *              as authenticated in the authenticateOption. Note that this function
   3576           *              is hardwared to CBKE right now.
   3577           *
   3578           * @param       shortAddr - short address of the partner device
   3579           * @param       extAddr - extended address of the partner device
   3580           * @param       key - link key
   3581           *
   3582           * @return      ZStatus_t
   3583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3584          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3585          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3586            uint16           ami;
   3587            ZDSecMgrEntry_t* entry;
   3588          
   3589            /* Store the device address in the addr manager */
   3590            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?XSTACK_DISP100_8
   \   000013   88..         MOV       ?V0,R0
   \   000015   89..         MOV       ?V1,R1
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL     `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV       A,#0x2
   \   000021   12....       LCALL     ?DEALLOC_XSTACK8
   \   000024   E9           MOV       A,R1
   \   000025   6004         JZ        ??ZDSecMgrAddLinkKey_0
   3591            {
   3592              /* Adding to Addr Manager fails */
   3593              return ZFailure;
   \   000027   7901         MOV       R1,#0x1
   \   000029   8039         SJMP      ??ZDSecMgrAddLinkKey_1
   3594            }
   3595          
   3596            /* Lookup entry using specified address index */
   3597            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV       R4,?XSP + 0
   \   00002D   AD..         MOV       R5,?XSP + 1
   \   00002F   7402         MOV       A,#0x2
   \   000031   12....       LCALL     ?XSTACK_DISP0_8
   \   000034   12....       LCALL     ??Subroutine88_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000037   12....       LCALL     `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   3598          
   3599            // If no existing entry, create one
   3600            if ( entry == NULL )
   \   00003A   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   00003D   7018         JNZ       ??CrossCallReturnLabel_154
   3601            {
   3602              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00003F                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   00003F   AA..         MOV       R2,?XSP + 0
   \   000041   AB..         MOV       R3,?XSP + 1
   \   000043   12....       LCALL     `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   000046   E9           MOV       A,R1
   \   000047   701E         JNZ       ??ZDSecMgrAddLinkKey_2
   3603              {
   3604                entry->ami = ami;
   \   000049   7402         MOV       A,#0x2
   \   00004B   12....       LCALL     ?XSTACK_DISP0_8
   \   00004E   12....       LCALL     ?Subroutine45 & 0xFFFF
   3605              }
   \                     ??CrossCallReturnLabel_46:
   \   000051   12....       LCALL     ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000054   12....       LCALL     ??Subroutine84_0 & 0xFFFF
   3606              else
   3607              {
   3608                /* Security Manager full */
   3609                return ZBufferFull;
   3610              }
   3611            }
   3612            // Write the link key
   3613            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_154:
   \   000057                ; Setup parameters for call to function APSME_LinkKeySet
   \   000057   740E         MOV       A,#0xe
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   12....       LCALL     ??Subroutine102_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   00005F   12....       LCALL     `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   3614          
   3615          #if defined (TC_LINKKEY_JOIN)
   3616            // Mark the device as authenticated.
   3617            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3618          #endif
   3619          
   3620          #if defined NV_RESTORE
   3621            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3622          #endif
   3623            
   3624            return ZSuccess;
   \   000062   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000064   02....       LJMP      ?Subroutine6 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000067   7911         MOV       R1,#0x11
   \   000069   80F9         SJMP      ??ZDSecMgrAddLinkKey_1
   3625          }
   3626          
   3627          #if defined ( NV_RESTORE )
   3628          /******************************************************************************
   3629           * @fn          ZDSecMgrInitNV
   3630           *
   3631           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3632           *
   3633           * @param       none
   3634           *
   3635           * @return      uint8 - <osal_nv_item_init> return codes
   3636           */
   3637          uint8 ZDSecMgrInitNV(void)
   3638          {
   3639            
   3640            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE, 
   3641                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3642            
   3643            // If the item does not already exist, set all values to 0 
   3644            if (rtrn != SUCCESS)  
   3645            {
   3646              nvDeviceListHdr_t hdr;
   3647              hdr.numRecs = 0;
   3648              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3649            }
   3650          
   3651            return rtrn;
   3652          }
   3653          #endif // NV_RESTORE
   3654          
   3655          #if defined ( NV_RESTORE )
   3656          /*********************************************************************
   3657           * @fn      ZDSecMgrWriteNV()
   3658           *
   3659           * @brief   Save off the APS link key list to NV
   3660           *
   3661           * @param   none
   3662           *
   3663           * @return  none
   3664           */
   3665          static void ZDSecMgrWriteNV( void )
   3666          {
   3667            uint16 i;
   3668            nvDeviceListHdr_t hdr;
   3669          
   3670            hdr.numRecs = 0;
   3671          
   3672            if (ZDSecMgrEntries != NULL)
   3673            {
   3674              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3675              {
   3676                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3677                {
   3678                  // Save off the record
   3679                  osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3680                          (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3681                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3682                  hdr.numRecs++;
   3683                }
   3684              }
   3685            }
   3686          
   3687            // Save off the header
   3688            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3689          }
   3690          #endif // NV_RESTORE
   3691          
   3692          #if defined ( NV_RESTORE )
   3693          /******************************************************************************
   3694           * @fn          ZDSecMgrRestoreFromNV
   3695           *
   3696           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3697           *              the key data itself as they remain in NV until they are used. 
   3698           *              Only list data is restored.
   3699           *
   3700           * @param       none
   3701           *
   3702           * @return      None.
   3703           */
   3704          static void ZDSecMgrRestoreFromNV( void )
   3705          {
   3706            nvDeviceListHdr_t hdr;
   3707            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3708            
   3709            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3710                (hdr.numRecs <= ZDSECMGR_ENTRY_MAX))
   3711            {
   3712              uint8 x;
   3713          
   3714              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3715              
   3716              for (x = 0; x < hdr.numRecs; x++)
   3717              {
   3718                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3719                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3720                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3721                {
   3722                  // update data only for valid entries 
   3723                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3724                  {
   3725                    if (pApsLinkKey != NULL)
   3726                    {
   3727                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3728                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0, 
   3729                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3730                      
   3731                      // set new values for the counter 
   3732                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3733          
   3734                      // restore values for counters in RAM
   3735                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 
   3736                                                      pApsLinkKey->txFrmCntr;
   3737          
   3738                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 
   3739                                                      pApsLinkKey->rxFrmCntr;
   3740                      
   3741                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0, 
   3742                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3743                      
   3744                      // clear copy of key in RAM 
   3745                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3746                    }
   3747                  }
   3748                }
   3749              }
   3750              
   3751              if (pApsLinkKey != NULL)
   3752              {
   3753                osal_mem_free(pApsLinkKey);
   3754              }    
   3755            }
   3756          }
   3757          #endif // NV_RESTORE
   3758          
   3759          /*********************************************************************
   3760           * @fn          ZDSecMgrSetDefaultNV
   3761           *
   3762           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3763           *
   3764           * @param       none
   3765           *
   3766           * @return      none
   3767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3768          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3769          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV       A,#-0x7
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3770            uint16 i;
   3771            nvDeviceListHdr_t hdr;
   3772            ZDSecMgrEntry_t secMgrEntry;
   3773            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3774              
   3775            // Initialize the header
   3776            hdr.numRecs = 0;
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   E4           CLR       A
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   F0           MOVX      @DPTR,A
   3777          
   3778            // clear the header
   3779            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   000014                ; Setup parameters for call to function osal_nv_write
   \   000014   A8..         MOV       R0,?XSP + 0
   \   000016   A9..         MOV       R1,?XSP + 1
   \   000018   88..         MOV       ?V0,R0
   \   00001A   89..         MOV       ?V1,R1
   \   00001C   78..         MOV       R0,#?V0
   \   00001E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000021   75..02       MOV       ?V0,#0x2
   \   000024   75..00       MOV       ?V1,#0x0
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   7C00         MOV       R4,#0x0
   \   00002E   7D00         MOV       R5,#0x0
   \   000030   7A4C         MOV       R2,#0x4c
   \   000032   7B00         MOV       R3,#0x0
   \   000034   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000037   7404         MOV       A,#0x4
   \   000039   12....       LCALL     ?DEALLOC_XSTACK8
   3780            
   3781            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00003C                ; Setup parameters for call to function osal_memset
   \   00003C   7C05         MOV       R4,#0x5
   \   00003E   7D00         MOV       R5,#0x0
   \   000040   7900         MOV       R1,#0x0
   \   000042   7402         MOV       A,#0x2
   \   000044   12....       LCALL     ?XSTACK_DISP101_8
   \   000047   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3782          
   3783            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   00004A   7E00         MOV       R6,#0x0
   \   00004C   7F00         MOV       R7,#0x0
   3784            {
   3785              // Clear the record
   3786              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3787                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3788                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   00004E                ; Setup parameters for call to function osal_nv_write
   \   00004E   7402         MOV       A,#0x2
   \   000050   12....       LCALL     ?XSTACK_DISP100_8
   \   000053   88..         MOV       ?V0,R0
   \   000055   89..         MOV       ?V1,R1
   \   000057   78..         MOV       R0,#?V0
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   75..05       MOV       ?V0,#0x5
   \   00005F   75..00       MOV       ?V1,#0x0
   \   000062   78..         MOV       R0,#?V0
   \   000064   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000067   EE           MOV       A,R6
   \   000068   F8           MOV       R0,A
   \   000069   EF           MOV       A,R7
   \   00006A   F9           MOV       R1,A
   \   00006B   E8           MOV       A,R0
   \   00006C   75F005       MOV       B,#0x5
   \   00006F   A4           MUL       AB
   \   000070   F8           MOV       R0,A
   \   000071   AAF0         MOV       R2,B
   \   000073   75F005       MOV       B,#0x5
   \   000076   E9           MOV       A,R1
   \   000077   A4           MUL       AB
   \   000078   2A           ADD       A,R2
   \   000079   F9           MOV       R1,A
   \   00007A   E8           MOV       A,R0
   \   00007B   2402         ADD       A,#0x2
   \   00007D   FC           MOV       R4,A
   \   00007E   E4           CLR       A
   \   00007F   39           ADDC      A,R1
   \   000080   FD           MOV       R5,A
   \   000081   7A4C         MOV       R2,#0x4c
   \   000083   7B00         MOV       R3,#0x0
   \   000085   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000088   7404         MOV       A,#0x4
   \   00008A   12....       LCALL     ?DEALLOC_XSTACK8
   3789            }
   \   00008D   0E           INC       R6
   \   00008E   EE           MOV       A,R6
   \   00008F   7001         JNZ       ??ZDSecMgrSetDefaultNV_1
   \   000091   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   000092   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000095   40B7         JC        ??ZDSecMgrSetDefaultNV_0
   3790          
   3791            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000097                ; Setup parameters for call to function osal_mem_alloc
   \   000097   7A18         MOV       R2,#0x18
   \   000099   7B00         MOV       R3,#0x0
   \   00009B   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00009E   8A..         MOV       ?V0,R2
   \   0000A0   8B..         MOV       ?V1,R3
   3792          
   3793            if (pApsLinkKey != NULL)
   \   0000A2   EA           MOV       A,R2
   \   0000A3   45..         ORL       A,?V1
   \   0000A5   6039         JZ        ??ZDSecMgrSetDefaultNV_2
   3794            {
   3795              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000A7                ; Setup parameters for call to function osal_memset
   \   0000A7   7C18         MOV       R4,#0x18
   \   0000A9   7D00         MOV       R5,#0x0
   \   0000AB   7900         MOV       R1,#0x0
   \   0000AD   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3796          
   3797              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000B0   7E00         MOV       R6,#0x0
   \   0000B2   7F00         MOV       R7,#0x0
   3798              {
   3799                // Clear the record
   3800                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3801                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000B4                ; Setup parameters for call to function osal_nv_write
   \   0000B4   78..         MOV       R0,#?V0
   \   0000B6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B9   75..18       MOV       ?V2,#0x18
   \   0000BC   75..00       MOV       ?V3,#0x0
   \   0000BF   78..         MOV       R0,#?V2
   \   0000C1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C4   12....       LCALL     ?Subroutine32 & 0xFFFF
   3802              }
   \                     ??CrossCallReturnLabel_31:
   \   0000C7   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000CA   7404         MOV       A,#0x4
   \   0000CC   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CF   0E           INC       R6
   \   0000D0   EE           MOV       A,R6
   \   0000D1   7001         JNZ       ??ZDSecMgrSetDefaultNV_4
   \   0000D3   0F           INC       R7
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   0000D4   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000D7   40DB         JC        ??ZDSecMgrSetDefaultNV_3
   3803              
   3804              osal_mem_free(pApsLinkKey);
   \   0000D9                ; Setup parameters for call to function osal_mem_free
   \   0000D9   AA..         MOV       R2,?V0
   \   0000DB   AB..         MOV       R3,?V1
   \   0000DD   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3805            }
   3806          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   0000E0   7407         MOV       A,#0x7
   \   0000E2                REQUIRE ?Subroutine4
   \   0000E2                ; // Fall through to label ?Subroutine4

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   7C00         MOV       R4,#0x0
   \   000002   7D00         MOV       R5,#0x0
   \   000004   EE           MOV       A,R6
   \   000005   2401         ADD       A,#0x1
   \   000007   FA           MOV       R2,A
   \   000008   EF           MOV       A,R7
   \   000009   3402         ADDC      A,#0x2
   \   00000B   FB           MOV       R3,A
   \   00000C   22           RET
   3807          
   3808          /******************************************************************************
   3809           * @fn          ZDSecMgrAPSRemove
   3810           *
   3811           * @brief       Remove device from network.
   3812           *
   3813           * @param       nwkAddr - device's NWK address
   3814           * @param       extAddr - device's Extended address
   3815           * @param       parentAddr - parent's NWK address
   3816           *
   3817           * @return      ZStatus_t
   3818           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3819          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3820          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV       A,#-0xa
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3821            ZDSecMgrDevice_t device;
   3822          
   3823            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3824                 ( extAddr == NULL )              ||
   3825                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV       A,#-0x2
   \   00000B   6A           XRL       A,R2
   \   00000C   7003         JNZ       ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV       A,#-0x1
   \   000010   6B           XRL       A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ        ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV       A,R4
   \   000014   4D           ORL       A,R5
   \   000015   6012         JZ        ??ZDSecMgrAPSRemove_1
   \   000017   740A         MOV       A,#0xa
   \   000019   12....       LCALL     ?XSTACK_DISP0_8
   \   00001C   12....       LCALL     ??Subroutine105_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00001F   74FE         MOV       A,#-0x2
   \   000021   68           XRL       A,R0
   \   000022   7003         JNZ       ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV       A,#-0x1
   \   000026   69           XRL       A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ       ??ZDSecMgrAPSRemove_3
   3826            {
   3827              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV       R1,#0x1
   \   00002B   801A         SJMP      ??ZDSecMgrAPSRemove_4
   3828            }
   3829          
   3830            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   12....       LCALL     ?Subroutine21 & 0xFFFF
   3831            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_215:
   \   000030   7402         MOV       A,#0x2
   \   000032   12....       LCALL     ?XSTACK_DISP0_8
   \   000035   EC           MOV       A,R4
   \   000036   F0           MOVX      @DPTR,A
   \   000037   A3           INC       DPTR
   \   000038   ED           MOV       A,R5
   \   000039   F0           MOVX      @DPTR,A
   3832            device.parentAddr = parentAddr;
   \   00003A   7404         MOV       A,#0x4
   \   00003C   12....       LCALL     ?XSTACK_DISP0_8
   \   00003F   12....       LCALL     ?Subroutine10 & 0xFFFF
   3833          
   3834            // remove device
   3835            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_242:
   \   000042   12....       LCALL     `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   3836          
   3837            return ( ZSuccess );
   \   000045   7900         MOV       R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000047   02....       LJMP      ?Subroutine9 & 0xFFFF
   3838          }
   3839          
   3840          /******************************************************************************
   3841           * @fn          APSME_TCLinkKeyInit
   3842           *
   3843           * @brief       Initialize the NV table for preconfigured TC link key
   3844           *               
   3845           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3846           *              Trust Center Link Key is written to NV. A single tclk is used   
   3847           *              by all devices joining the network.
   3848           *              
   3849           * @param       setDefault - TRUE to set default values
   3850           *
   3851           * @return      none
   3852           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3853          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3854          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   3855            uint8             i;
   3856            APSME_TCLinkKey_t tcLinkKey;
   3857            uint8             rtrn;
   3858            
   3859            // Initialize all NV items for preconfigured TCLK 
   3860            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3861            {
   3862              // Making sure data is cleared for every key all the time
   3863              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV       R4,#0x20
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3864          
   3865              // Initialize first element of the table with the default TCLK
   3866              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000017   90....       MOV       DPTR,#zgUseDefaultTCLK
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6401         XRL       A,#0x1
   \   00001D   7030         JNZ       ??APSME_TCLinkKeyInit_0
   3867              {
   3868                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C08         MOV       R4,#0x8
   \   000021   7D00         MOV       R5,#0x0
   \   000023   79FF         MOV       R1,#-0x1
   \   000025   AA..         MOV       R2,?XSP + 0
   \   000027   AB..         MOV       R3,?XSP + 1
   \   000029   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3869                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00002C                ; Setup parameters for call to function osal_memcpy
   \   00002C   75....       MOV       ?V0,#defaultTCLinkKey & 0xff
   \   00002F   75....       MOV       ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   000032   75..80       MOV       ?V2,#-0x80
   \   000035   78..         MOV       R0,#?V0
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00003A   7C10         MOV       R4,#0x10
   \   00003C   7D00         MOV       R5,#0x0
   \   00003E   740B         MOV       A,#0xb
   \   000040   12....       LCALL     ?XSTACK_DISP0_8
   \   000043   AA82         MOV       R2,DPL
   \   000045   AB83         MOV       R3,DPH
   \   000047   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00004A   7403         MOV       A,#0x3
   \   00004C   12....       LCALL     ?DEALLOC_XSTACK8
   3870              }
   3871          
   3872              // If the item doesn't exist in NV memory, create and initialize
   3873              // it with the default value passed in, either defaultTCLK or 0
   3874              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i), 
   3875                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   3876               
   3877              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   00004F                ; Setup parameters for call to function osal_nv_item_init
   \   00004F   A8..         MOV       R0,?XSP + 0
   \   000051   A9..         MOV       R1,?XSP + 1
   \   000053   88..         MOV       ?V0,R0
   \   000055   89..         MOV       ?V1,R1
   \   000057   78..         MOV       R0,#?V0
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   7C20         MOV       R4,#0x20
   \   00005E   7D00         MOV       R5,#0x0
   \   000060   7A01         MOV       R2,#0x1
   \   000062   7B01         MOV       R3,#0x1
   \   000064   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000067   7402         MOV       A,#0x2
   \   000069   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006C   E9           MOV       A,R1
   \   00006D   7074         JNZ       ??APSME_TCLinkKeyInit_1
   3878              {
   3879                // set the Frame counters to 0 to existing keys in NV
   3880                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0, 
   3881                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00006F                ; Setup parameters for call to function osal_nv_read
   \   00006F   78..         MOV       R0,#?V0
   \   000071   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000074   75..20       MOV       ?V0,#0x20
   \   000077   75..00       MOV       ?V1,#0x0
   \   00007A   78..         MOV       R0,#?V0
   \   00007C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00007F   7C00         MOV       R4,#0x0
   \   000081   7D00         MOV       R5,#0x0
   \   000083   7A01         MOV       R2,#0x1
   \   000085   7B01         MOV       R3,#0x1
   \   000087   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00008A   7404         MOV       A,#0x4
   \   00008C   12....       LCALL     ?DEALLOC_XSTACK8
   3882                
   3883          #if defined ( NV_RESTORE )
   3884                if (setDefault == TRUE)
   3885                {
   3886                  // clear the value stored in NV  
   3887                  tcLinkKey.txFrmCntr = 0;
   3888                }
   3889                else
   3890                {
   3891                  // increase the value stored in NV  
   3892                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   3893                }
   3894          #else      
   3895                // Clear the counters if NV_RESTORE is not enabled and this NV item
   3896                // already existed in the NV memory
   3897                tcLinkKey.txFrmCntr = 0;
   \   00008F   7418         MOV       A,#0x18
   \   000091   12....       LCALL     ?XSTACK_DISP0_8
   \   000094   12....       LCALL     ??Subroutine100_0 & 0xFFFF
   3898                tcLinkKey.rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_252:
   \   000097   741C         MOV       A,#0x1c
   \   000099   12....       LCALL     ?XSTACK_DISP0_8
   \   00009C   12....       LCALL     ??Subroutine100_0 & 0xFFFF
   3899          #endif  // NV_RESTORE
   3900          
   3901                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   3902                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??CrossCallReturnLabel_253:
   \   00009F                ; Setup parameters for call to function osal_nv_write
   \   00009F   A8..         MOV       R0,?XSP + 0
   \   0000A1   A9..         MOV       R1,?XSP + 1
   \   0000A3   88..         MOV       ?V0,R0
   \   0000A5   89..         MOV       ?V1,R1
   \   0000A7   78..         MOV       R0,#?V0
   \   0000A9   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AC   75..20       MOV       ?V0,#0x20
   \   0000AF   75..00       MOV       ?V1,#0x0
   \   0000B2   78..         MOV       R0,#?V0
   \   0000B4   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B7   7C00         MOV       R4,#0x0
   \   0000B9   7D00         MOV       R5,#0x0
   \   0000BB   7A01         MOV       R2,#0x1
   \   0000BD   7B01         MOV       R3,#0x1
   \   0000BF   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C2   7404         MOV       A,#0x4
   \   0000C4   12....       LCALL     ?DEALLOC_XSTACK8
   3903                
   3904                // set initial values for counters in RAM
   3905                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   0000C7   7418         MOV       A,#0x18
   \   0000C9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL     ?XLOAD_R0123
   \   0000CF   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   0000D2   12....       LCALL     ?XSTORE_R0123
   3906                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;    
   \   0000D5   741C         MOV       A,#0x1c
   \   0000D7   12....       LCALL     ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL     ?XLOAD_R0123
   \   0000DD   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   0000E0   12....       LCALL     ?XSTORE_R0123
   3907              }
   3908            }
   3909              
   3910            // clear copy of key in RAM
   3911            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   0000E3                ; Setup parameters for call to function osal_memset
   \   0000E3   7C20         MOV       R4,#0x20
   \   0000E5   7D00         MOV       R5,#0x0
   \   0000E7   7900         MOV       R1,#0x0
   \   0000E9   AA..         MOV       R2,?XSP + 0
   \   0000EB   AB..         MOV       R3,?XSP + 1
   \   0000ED   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3912          
   3913          }
   \   0000F0   7420         MOV       A,#0x20
   \   0000F2   02....       LJMP      ?Subroutine5 & 0xFFFF
   3914          
   3915          /******************************************************************************
   3916           * @fn          APSME_TCLinkKeySync
   3917           *
   3918           * @brief       Sync Trust Center LINK key data.
   3919           *
   3920           * @param       srcAddr - [in] srcAddr
   3921           * @param       si      - [in, out] SSP_Info_t
   3922           *
   3923           * @return      ZStatus_t
   3924           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3925          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   3926          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV       A,#-0x20
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3927            ZStatus_t status = ZSecNoKey;
   3928            uint8 i;
   3929            APSME_TCLinkKey_t tcLinkKey;       
   3930            uint32 *tclkRxFrmCntr;
   3931            
   3932            // Look up the IEEE address of the trust center if it's available
   3933            if ( AddrMgrExtAddrValid( si->extAddr ) == false )
   \   000012                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000012   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000015   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000018   E9           MOV       A,R1
   \   000019   700E         JNZ       ??APSME_TCLinkKeySync_0
   3934            {
   3935              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00001B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00001B   EE           MOV       A,R6
   \   00001C   2406         ADD       A,#0x6
   \   00001E   FC           MOV       R4,A
   \   00001F   E4           CLR       A
   \   000020   3F           ADDC      A,R7
   \   000021   FD           MOV       R5,A
   \   000022   AA..         MOV       R2,?V0
   \   000024   AB..         MOV       R3,?V1
   \   000026   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3936            }
   3937            
   3938            // Look up the TC link key associated with the device
   3939            // or the default TC link key (extAddr is all FFs), whichever is found
   3940            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3941            {
   3942              // Read entry i of the TC link key table from NV
   3943              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   3944                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_0:
   \   000029                ; Setup parameters for call to function osal_nv_read
   \   000029   A8..         MOV       R0,?XSP + 0
   \   00002B   A9..         MOV       R1,?XSP + 1
   \   00002D   88..         MOV       ?V0,R0
   \   00002F   89..         MOV       ?V1,R1
   \   000031   78..         MOV       R0,#?V0
   \   000033   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000036   75..20       MOV       ?V0,#0x20
   \   000039   75..00       MOV       ?V1,#0x0
   \   00003C   78..         MOV       R0,#?V0
   \   00003E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000041   7C00         MOV       R4,#0x0
   \   000043   7D00         MOV       R5,#0x0
   \   000045   7A01         MOV       R2,#0x1
   \   000047   7B01         MOV       R3,#0x1
   \   000049   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00004C   7404         MOV       A,#0x4
   \   00004E   12....       LCALL     ?DEALLOC_XSTACK8
   3945              
   3946              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   3947                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000051                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000051   AC..         MOV       R4,?XSP + 0
   \   000053   AD..         MOV       R5,?XSP + 1
   \   000055   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000058   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00005B   E9           MOV       A,R1
   \   00005C   700A         JNZ       ??APSME_TCLinkKeySync_1
   \   00005E                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00005E   AA..         MOV       R2,?XSP + 0
   \   000060   AB..         MOV       R3,?XSP + 1
   \   000062   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000065   E9           MOV       A,R1
   \   000066   6032         JZ        ??APSME_TCLinkKeySync_2
   3948              {
   3949                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   3950          
   3951                // verify that the incoming frame counter is valid
   3952                if ( si->frmCntr >= *tclkRxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   000068   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   00006B   78..         MOV       R0,#?V0
   \   00006D   12....       LCALL     ?L_MOV_X
   \   000070   EE           MOV       A,R6
   \   000071   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000074   12....       LCALL     ?UL_GT_X
   \   000077   401D         JC        ??APSME_TCLinkKeySync_3
   3953                {
   3954                  // set the keyNvId to use
   3955                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000079   12....       LCALL     ?Subroutine54 & 0xFFFF
   3956                  
   3957                  // update the rx frame counter
   3958                  *tclkRxFrmCntr = si->frmCntr + 1;
   \                     ??CrossCallReturnLabel_61:
   \   00007C   12....       LCALL     ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00007F   12....       LCALL     ?L_MOV_X
   \   000082   90....       MOV       DPTR,#__Constant_1
   \   000085   78..         MOV       R0,#?V0
   \   000087   12....       LCALL     ?L_ADD_X
   \   00008A   90....       MOV       DPTR,#TCLinkKeyFrmCntr + 4
   \   00008D   78..         MOV       R0,#?V0
   \   00008F   12....       LCALL     ?L_MOV_TO_X
   3959                  
   3960                  status = ZSuccess;
   \   000092   7900         MOV       R1,#0x0
   \   000094   8013         SJMP      ??APSME_TCLinkKeySync_4
   3961                }
   3962                else
   3963                {
   3964                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   000096   79A2         MOV       R1,#-0x5e
   3965                }
   3966                
   3967                return status;
   \   000098   800F         SJMP      ??APSME_TCLinkKeySync_4
   3968              }
   3969            }
   3970            
   3971            // clear copy of key in RAM 
   3972            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   00009A                ; Setup parameters for call to function osal_memset
   \   00009A   7C20         MOV       R4,#0x20
   \   00009C   7D00         MOV       R5,#0x0
   \   00009E   7900         MOV       R1,#0x0
   \   0000A0   AA..         MOV       R2,?XSP + 0
   \   0000A2   AB..         MOV       R3,?XSP + 1
   \   0000A4   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   3973            
   3974            return status;
   \   0000A7   79A1         MOV       R1,#-0x5f
   \                     ??APSME_TCLinkKeySync_4:
   \   0000A9   7420         MOV       A,#0x20
   \   0000AB   02....       LJMP      ?Subroutine4 & 0xFFFF
   3975          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   2412         ADD       A,#0x12
   \   000002   F582         MOV       DPL,A
   \   000004   E4           CLR       A
   \   000005   3F           ADDC      A,R7
   \   000006   F583         MOV       DPH,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   EE           MOV       A,R6
   \   000001   240F         ADD       A,#0xf
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F583         MOV       DPH,A
   \   000009   7401         MOV       A,#0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   F0           MOVX      @DPTR,A
   \   00000E   EE           MOV       A,R6
   \   00000F   22           RET
   3976          
   3977          /******************************************************************************
   3978           * @fn          APSME_TCLinkKeyLoad
   3979           *
   3980           * @brief       Load Trust Center LINK key data.
   3981           *
   3982           * @param       dstAddr - [in] dstAddr
   3983           * @param       si      - [in, out] SSP_Info_t
   3984           *
   3985           * @return      ZStatus_t
   3986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3987          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   3988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV       A,#-0x2d
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EC           MOV       A,R4
   \   00000B   FE           MOV       R6,A
   \   00000C   ED           MOV       A,R5
   \   00000D   FF           MOV       R7,A
   3989            uint8              i;
   3990            APSME_TCLinkKey_t  tcLinkKey;
   3991            AddrMgrEntry_t     addrEntry;  
   3992            uint32 *tclkTxFrmCntr;
   3993            
   3994            // Look up the ami of the srcAddr if available
   3995            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   E4           CLR       A
   \   000015   F0           MOVX      @DPTR,A
   3996            addrEntry.nwkAddr = dstAddr;
   \   000016   04           INC       A
   \   000017   12....       LCALL     ?XSTACK_DISP0_8
   \   00001A   12....       LCALL     ??Subroutine95_0 & 0xFFFF
   3997          
   3998            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \                     ??CrossCallReturnLabel_213:
   \   00001D   EE           MOV       A,R6
   \   00001E   2406         ADD       A,#0x6
   \   000020   F5..         MOV       ?V0,A
   \   000022   E4           CLR       A
   \   000023   3F           ADDC      A,R7
   \   000024   F5..         MOV       ?V1,A
   \   000026                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000026   AC..         MOV       R4,?V0
   \   000028   FD           MOV       R5,A
   \   000029   12....       LCALL     `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   3999          
   4000            if ( AddrMgrExtAddrValid( si->extAddr ) == TRUE )
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002C   AA..         MOV       R2,?V0
   \   00002E   AB..         MOV       R3,?V1
   \   000030   12....       LCALL     `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000033   E9           MOV       A,R1
   \   000034   6401         XRL       A,#0x1
   \   000036   706B         JNZ       ??APSME_TCLinkKeyLoad_0
   4001            {
   4002              // Look up the TC link key associated with the device
   4003              // or the master TC link key (ami = 0xFFFF), whichever is found
   4004              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4005              {
   4006                // Read entry i of the TC link key table from NV
   4007                osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0, 
   4008                             sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000038                ; Setup parameters for call to function osal_nv_read
   \   000038   740D         MOV       A,#0xd
   \   00003A   12....       LCALL     ?XSTACK_DISP100_8
   \   00003D   88..         MOV       ?V0,R0
   \   00003F   89..         MOV       ?V1,R1
   \   000041   78..         MOV       R0,#?V0
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   75..20       MOV       ?V0,#0x20
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   7C00         MOV       R4,#0x0
   \   000053   7D00         MOV       R5,#0x0
   \   000055   7A01         MOV       R2,#0x1
   \   000057   7B01         MOV       R3,#0x1
   \   000059   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00005C   7404         MOV       A,#0x4
   \   00005E   12....       LCALL     ?DEALLOC_XSTACK8
   4009                
   4010                if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) || 
   4011                   APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \   000061                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000061   740D         MOV       A,#0xd
   \   000063   12....       LCALL     ?XSTACK_DISP102_8
   \   000066   12....       LCALL     ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000069   12....       LCALL     `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00006C   E9           MOV       A,R1
   \   00006D   700B         JNZ       ??APSME_TCLinkKeyLoad_1
   \   00006F                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00006F   740D         MOV       A,#0xd
   \   000071   12....       LCALL     ?XSTACK_DISP101_8
   \   000074   12....       LCALL     `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000077   E9           MOV       A,R1
   \   000078   6029         JZ        ??APSME_TCLinkKeyLoad_0
   4012                {
   4013                  tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4014                  
   4015                  // set the keyNvId to use
   4016                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00007A   12....       LCALL     ?Subroutine54 & 0xFFFF
   4017                  
   4018                  // update link key related fields
   4019                  si->keyID   = SEC_KEYID_LINK;
   \                     ??CrossCallReturnLabel_62:
   \   00007D   12....       LCALL     ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000080   E4           CLR       A
   \   000081   F0           MOVX      @DPTR,A
   4020                  si->frmCntr = *tclkTxFrmCntr;
   \   000082   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   000085   12....       LCALL     ?XLOAD_R0123
   \   000088   EE           MOV       A,R6
   \   000089   12....       LCALL     ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00008C   12....       LCALL     ?XSTORE_R0123
   4021                
   4022                  // update outgoing frame counter
   4023                  (*tclkTxFrmCntr)++;
   \   00008F   90....       MOV       DPTR,#__Constant_1
   \   000092   78..         MOV       R0,#?V0
   \   000094   12....       LCALL     ?L_MOV_X
   \   000097   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   00009A   78..         MOV       R0,#?V0
   \   00009C   12....       LCALL     ?L_ADD_TO_X
   4024                  
   4025          #if defined ( NV_RESTORE )
   4026                  // write periodically to NV
   4027                  if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4028                  {
   4029                    // set the flag to write key to NV
   4030                    TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4031                    
   4032                    // Notify the ZDApp that the frame counter has changed.
   4033                    osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4034                  }        
   4035          #endif
   4036                  
   4037                  return ZSuccess;
   \   00009F   7900         MOV       R1,#0x0
   \   0000A1   8023         SJMP      ??APSME_TCLinkKeyLoad_2
   4038                }
   4039              }
   4040            }
   4041              
   4042            // If no TC link key found, remove the device from the address manager
   4043            if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   0000A3                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   0000A3   AA..         MOV       R2,?XSP + 0
   \   0000A5   AB..         MOV       R3,?XSP + 1
   \   0000A7   12....       LCALL     `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0000AA   E9           MOV       A,R1
   \   0000AB   6401         XRL       A,#0x1
   \   0000AD   7007         JNZ       ??APSME_TCLinkKeyLoad_3
   4044            {
   4045              AddrMgrEntryRelease( &addrEntry );
   \   0000AF                ; Setup parameters for call to function AddrMgrEntryRelease
   \   0000AF   AA..         MOV       R2,?XSP + 0
   \   0000B1   AB..         MOV       R3,?XSP + 1
   \   0000B3   12....       LCALL     `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   4046            }
   4047            
   4048              // clear copy of key in RAM 
   4049            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000B6                ; Setup parameters for call to function osal_memset
   \   0000B6   7C20         MOV       R4,#0x20
   \   0000B8   7D00         MOV       R5,#0x0
   \   0000BA   7900         MOV       R1,#0x0
   \   0000BC   740D         MOV       A,#0xd
   \   0000BE   12....       LCALL     ?XSTACK_DISP101_8
   \   0000C1   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4050          
   4051            return ZSecNoKey;
   \   0000C4   79A1         MOV       R1,#-0x5f
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000C6   742D         MOV       A,#0x2d
   \   0000C8   02....       LJMP      ?Subroutine4 & 0xFFFF
   4052          }
   4053          
   4054          /******************************************************************************
   4055           * @fn          APSME_IsDefaultTCLK
   4056           *
   4057           * @brief       Return true or false based on the extended address.  If the 
   4058           *              input ext address is all FFs, it means the trust center link
   4059           *              assoiciated with the address is the default trust center link key
   4060           *
   4061           * @param       extAddr - [in] extended address
   4062           *
   4063           * @return      uint8 TRUE/FALSE
   4064           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4065          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4066          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   4067            uint8 i = 0;
   \   000005   7C00         MOV       R4,#0x0
   4068            
   4069            if( extAddr == NULL )
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   6021         JZ        ??APSME_IsDefaultTCLK_0
   4070            {
   4071              return FALSE;
   4072            }
   4073            
   4074            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_1:
   \   00000B   EC           MOV       A,R4
   \   00000C   FD           MOV       R5,A
   \   00000D   7401         MOV       A,#0x1
   \   00000F   2D           ADD       A,R5
   \   000010   FC           MOV       R4,A
   \   000011   ED           MOV       A,R5
   \   000012   C3           CLR       C
   \   000013   9408         SUBB      A,#0x8
   \   000015   5019         JNC       ??APSME_IsDefaultTCLK_2
   4075            {
   4076              if( *extAddr++ != 0xFF )
   \   000017   EA           MOV       A,R2
   \   000018   F8           MOV       R0,A
   \   000019   EB           MOV       A,R3
   \   00001A   F9           MOV       R1,A
   \   00001B   8882         MOV       DPL,R0
   \   00001D   8983         MOV       DPH,R1
   \   00001F   A3           INC       DPTR
   \   000020   AA82         MOV       R2,DPL
   \   000022   AB83         MOV       R3,DPH
   \   000024   8882         MOV       DPL,R0
   \   000026   8983         MOV       DPH,R1
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F4           CPL       A
   \   00002A   60DF         JZ        ??APSME_IsDefaultTCLK_1
   4077              {
   4078                return FALSE;
   \                     ??APSME_IsDefaultTCLK_0:
   \   00002C   7900         MOV       R1,#0x0
   \   00002E   8002         SJMP      ??APSME_IsDefaultTCLK_3
   4079              }
   4080            }
   4081            
   4082            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000030   7901         MOV       R1,#0x1
   \                     ??APSME_IsDefaultTCLK_3:
   \   000032   02....       LJMP      ??Subroutine93_0 & 0xFFFF
   4083          }
   4084          
   4085          /******************************************************************************
   4086           * @fn          ZDSecMgrNwkKeyInit
   4087           *
   4088           * @brief       Initialize the NV items for 
   4089           *                  ZCD_NV_NWKKEY, 
   4090           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and 
   4091           *                  ZCD_NV_NWK_ALTERN_KEY_INFO 
   4092           *               
   4093           * @param       setDefault
   4094           *
   4095           * @return      none
   4096           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4097          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4098          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV       A,#-0x26
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4099            uint8 status;
   4100            nwkKeyDesc nwkKey;
   4101          
   4102            // Initialize NV items for NWK key, this structure contains the frame counter
   4103            // and is only used when NV_RESTORE is enabled
   4104            nwkActiveKeyItems keyItems;  
   4105              
   4106            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV       R4,#0x15
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   7411         MOV       A,#0x11
   \   000012   12....       LCALL     ?XSTACK_DISP101_8
   \   000015   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4107            
   4108            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4109          
   4110          #if defined ( NV_RESTORE )
   4111            // reset the values of NV items if NV_RESTORE is not enabled
   4112            if ((status == SUCCESS) && (setDefault == TRUE))
   4113            {
   4114              // clear NV data to default values
   4115              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4116            }
   4117          #else
   4118            (void)setDefault;   // to eliminate compiler warning
   4119            
   4120            // reset the values of NV items if NV_RESTORE is not enabled
   4121            if (status == SUCCESS)
   \   000018                ; Setup parameters for call to function osal_nv_item_init
   \   000018   7411         MOV       A,#0x11
   \   00001A   12....       LCALL     ?XSTACK_DISP100_8
   \   00001D   88..         MOV       ?V0,R0
   \   00001F   89..         MOV       ?V1,R1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C15         MOV       R4,#0x15
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   7A82         MOV       R2,#-0x7e
   \   00002C   7B00         MOV       R3,#0x0
   \   00002E   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000031   7402         MOV       A,#0x2
   \   000033   12....       LCALL     ?DEALLOC_XSTACK8
   \   000036   E9           MOV       A,R1
   \   000037   7020         JNZ       ??ZDSecMgrNwkKeyInit_0
   4122            {
   4123              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000039                ; Setup parameters for call to function osal_nv_write
   \   000039   78..         MOV       R0,#?V0
   \   00003B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003E   75..15       MOV       ?V0,#0x15
   \   000041   75..00       MOV       ?V1,#0x0
   \   000044   78..         MOV       R0,#?V0
   \   000046   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000049   7C00         MOV       R4,#0x0
   \   00004B   7D00         MOV       R5,#0x0
   \   00004D   7A82         MOV       R2,#-0x7e
   \   00004F   7B00         MOV       R3,#0x0
   \   000051   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000054   7404         MOV       A,#0x4
   \   000056   12....       LCALL     ?DEALLOC_XSTACK8
   4124            }
   4125          #endif // defined (NV_RESTORE)    
   4126          
   4127            // Initialize NV items for NWK Active and Alternate keys. These items are used 
   4128            // all the time, independently of NV_RESTORE being set or not
   4129            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000059                ; Setup parameters for call to function osal_memset
   \   000059   7C11         MOV       R4,#0x11
   \   00005B   7D00         MOV       R5,#0x0
   \   00005D   7900         MOV       R1,#0x0
   \   00005F   AA..         MOV       R2,?XSP + 0
   \   000061   AB..         MOV       R3,?XSP + 1
   \   000063   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4130          
   4131            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4132            
   4133          #if defined ( NV_RESTORE )
   4134            // reset the values of NV items if NV_RESTORE is not enabled
   4135            if ((status == SUCCESS) && (setDefault == TRUE))
   4136            {
   4137              // clear NV data to default values
   4138              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4139            }
   4140          #else
   4141            // reset the values of NV items if NV_RESTORE is not enabled
   4142            if (status == SUCCESS)
   \   000066                ; Setup parameters for call to function osal_nv_item_init
   \   000066   A8..         MOV       R0,?XSP + 0
   \   000068   A9..         MOV       R1,?XSP + 1
   \   00006A   88..         MOV       ?V0,R0
   \   00006C   89..         MOV       ?V1,R1
   \   00006E   78..         MOV       R0,#?V0
   \   000070   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000073   7C11         MOV       R4,#0x11
   \   000075   7D00         MOV       R5,#0x0
   \   000077   7A3A         MOV       R2,#0x3a
   \   000079   7B00         MOV       R3,#0x0
   \   00007B   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00007E   7402         MOV       A,#0x2
   \   000080   12....       LCALL     ?DEALLOC_XSTACK8
   \   000083   E9           MOV       A,R1
   \   000084   7020         JNZ       ??ZDSecMgrNwkKeyInit_1
   4143            {
   4144              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000086                ; Setup parameters for call to function osal_nv_write
   \   000086   78..         MOV       R0,#?V0
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008B   75..11       MOV       ?V0,#0x11
   \   00008E   75..00       MOV       ?V1,#0x0
   \   000091   78..         MOV       R0,#?V0
   \   000093   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000096   7C00         MOV       R4,#0x0
   \   000098   7D00         MOV       R5,#0x0
   \   00009A   7A3A         MOV       R2,#0x3a
   \   00009C   7B00         MOV       R3,#0x0
   \   00009E   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000A1   7404         MOV       A,#0x4
   \   0000A3   12....       LCALL     ?DEALLOC_XSTACK8
   4145            }
   4146          #endif // defined (NV_RESTORE)    
   4147            
   4148            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4149            
   4150          #if defined ( NV_RESTORE )
   4151            // reset the values of NV items if NV_RESTORE is not enabled
   4152            if ((status == SUCCESS) && (setDefault == TRUE))
   4153            {
   4154              // clear NV data to default values
   4155              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4156            }
   4157          #else
   4158            // reset the values of NV items if NV_RESTORE is not enabled
   4159            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000A6                ; Setup parameters for call to function osal_nv_item_init
   \   0000A6   A8..         MOV       R0,?XSP + 0
   \   0000A8   A9..         MOV       R1,?XSP + 1
   \   0000AA   88..         MOV       ?V0,R0
   \   0000AC   89..         MOV       ?V1,R1
   \   0000AE   78..         MOV       R0,#?V0
   \   0000B0   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B3   7C11         MOV       R4,#0x11
   \   0000B5   7D00         MOV       R5,#0x0
   \   0000B7   7A3B         MOV       R2,#0x3b
   \   0000B9   7B00         MOV       R3,#0x0
   \   0000BB   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   0000BE   7402         MOV       A,#0x2
   \   0000C0   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000C3   E9           MOV       A,R1
   \   0000C4   7020         JNZ       ??ZDSecMgrNwkKeyInit_2
   4160            {
   4161              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000C6                ; Setup parameters for call to function osal_nv_write
   \   0000C6   78..         MOV       R0,#?V0
   \   0000C8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000CB   75..11       MOV       ?V0,#0x11
   \   0000CE   75..00       MOV       ?V1,#0x0
   \   0000D1   78..         MOV       R0,#?V0
   \   0000D3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D6   7C00         MOV       R4,#0x0
   \   0000D8   7D00         MOV       R5,#0x0
   \   0000DA   7A3B         MOV       R2,#0x3b
   \   0000DC   7B00         MOV       R3,#0x0
   \   0000DE   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000E1   7404         MOV       A,#0x4
   \   0000E3   12....       LCALL     ?DEALLOC_XSTACK8
   4162            }
   4163          #endif // defined (NV_RESTORE)
   4164          
   4165          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   0000E6   7426         MOV       A,#0x26
   \   0000E8   02....       LJMP      ??Subroutine85_0 & 0xFFFF
   4166          
   4167          /*********************************************************************
   4168           * @fn          ZDSecMgrReadKeyFromNv
   4169           *
   4170           * @brief       Looks for a specific key in NV based on Index value
   4171           *
   4172           * @param   keyNvId - Index of key to look in NV
   4173           *                    valid values are:
   4174           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO    
   4175           *                    ZCD_NV_NWK_ALTERN_KEY_INFO 
   4176           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4177           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4178           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4179           *                    ZCD_NV_PRECFGKEY
   4180           *
   4181           * @param  *keyinfo - Data is read into this buffer.
   4182           *
   4183           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4184           *          Otherwise, NV_OPER_FAILED for failure.
   4185           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4186          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4187          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   4188            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4189                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV       A,#0x3a
   \   000007   6A           XRL       A,R2
   \   000008   7001         JNZ       ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV       A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6006         JZ        ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV       A,#0x3b
   \   00000F   6A           XRL       A,R2
   \   000010   4B           ORL       A,R3
   \   000011   7018         JNZ       ??ZDSecMgrReadKeyFromNv_2
   4190            {
   4191              // get NWK active or alternate key from NV
   4192              return (osal_nv_read(keyNvId, 
   4193                                   osal_offsetof(nwkKeyDesc, key), 
   4194                                   SEC_KEY_LEN, 
   4195                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000013                ; Setup parameters for call to function osal_nv_read
   \   000013   8C..         MOV       ?V0,R4
   \   000015   8D..         MOV       ?V1,R5
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001C   75..10       MOV       ?V0,#0x10
   \   00001F   75..00       MOV       ?V1,#0x0
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000027   7C01         MOV       R4,#0x1
   \   000029   8062         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4196            }
   4197            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4198                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00002B   EA           MOV       A,R2
   \   00002C   24FF         ADD       A,#-0x1
   \   00002E   F8           MOV       R0,A
   \   00002F   EB           MOV       A,R3
   \   000030   34FE         ADDC      A,#-0x2
   \   000032   F9           MOV       R1,A
   \   000033   E8           MOV       A,R0
   \   000034   49           ORL       A,R1
   \   000035   7018         JNZ       ??ZDSecMgrReadKeyFromNv_4
   4199            {
   4200              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4201              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4202              return (osal_nv_read(keyNvId, 
   4203                                   osal_offsetof(APSME_TCLinkKey_t, key), 
   4204                                   SEC_KEY_LEN, 
   4205                                   keyinfo));
   \   000037                ; Setup parameters for call to function osal_nv_read
   \   000037   8C..         MOV       ?V0,R4
   \   000039   8D..         MOV       ?V1,R5
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000040   75..10       MOV       ?V0,#0x10
   \   000043   75..00       MOV       ?V1,#0x0
   \   000046   78..         MOV       R0,#?V0
   \   000048   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004B   7C08         MOV       R4,#0x8
   \   00004D   803E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4206            }
   4207            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4208                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00004F   19           DEC       R1
   \   000050   C3           CLR       C
   \   000051   E8           MOV       A,R0
   \   000052   12....       LCALL     ??Subroutine78_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   000055   5018         JNC       ??ZDSecMgrReadKeyFromNv_5
   4209            {
   4210              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4211              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4212              return (osal_nv_read(keyNvId, 
   4213                                   osal_offsetof(APSME_LinkKeyData_t, key), 
   4214                                   SEC_KEY_LEN, 
   4215                                   keyinfo));
   \   000057                ; Setup parameters for call to function osal_nv_read
   \   000057   8C..         MOV       ?V0,R4
   \   000059   8D..         MOV       ?V1,R5
   \   00005B   78..         MOV       R0,#?V0
   \   00005D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000060   75..10       MOV       ?V0,#0x10
   \   000063   75..00       MOV       ?V1,#0x0
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV       R4,#0x0
   \   00006D   801E         SJMP      ??ZDSecMgrReadKeyFromNv_3
   4216            }
   4217            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4218                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   00006F   19           DEC       R1
   \   000070   C3           CLR       C
   \   000071   E8           MOV       A,R0
   \   000072   12....       LCALL     ??Subroutine78_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000075   501A         JNC       ??ZDSecMgrReadKeyFromNv_6
   4219            {
   4220              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4221              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4222              return (osal_nv_read(keyNvId, 
   4223                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key), 
   4224                                   SEC_KEY_LEN, 
   4225                                   keyinfo));
   \   000077                ; Setup parameters for call to function osal_nv_read
   \   000077   8C..         MOV       ?V0,R4
   \   000079   8D..         MOV       ?V1,R5
   \   00007B   78..         MOV       R0,#?V0
   \   00007D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000080   75..10       MOV       ?V0,#0x10
   \   000083   75..00       MOV       ?V1,#0x0
   \   000086   78..         MOV       R0,#?V0
   \   000088   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00008B   7C02         MOV       R4,#0x2
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00008D   7D00         MOV       R5,#0x0
   \   00008F   8022         SJMP      ??ZDSecMgrReadKeyFromNv_7
   4226            }
   4227            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   000091   7462         MOV       A,#0x62
   \   000093   6A           XRL       A,R2
   \   000094   4B           ORL       A,R3
   \   000095   7026         JNZ       ??ZDSecMgrReadKeyFromNv_8
   4228            {
   4229              // Read entry keyNvId of the Preconfig key from NV. 
   4230              return (osal_nv_read(keyNvId, 
   4231                                   0, 
   4232                                   SEC_KEY_LEN, 
   4233                                   keyinfo));
   \   000097                ; Setup parameters for call to function osal_nv_read
   \   000097   8C..         MOV       ?V0,R4
   \   000099   8D..         MOV       ?V1,R5
   \   00009B   78..         MOV       R0,#?V0
   \   00009D   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A0   75..10       MOV       ?V0,#0x10
   \   0000A3   75..00       MOV       ?V1,#0x0
   \   0000A6   78..         MOV       R0,#?V0
   \   0000A8   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AB   7C00         MOV       R4,#0x0
   \   0000AD   7D00         MOV       R5,#0x0
   \   0000AF   7A62         MOV       R2,#0x62
   \   0000B1   7B00         MOV       R3,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000B3   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000B6   7404         MOV       A,#0x4
   \   0000B8   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BB   8002         SJMP      ??ZDSecMgrReadKeyFromNv_9
   4234            }
   4235            
   4236            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000BD   790A         MOV       R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_9:
   \   0000BF   02....       LJMP      ??Subroutine86_0 & 0xFFFF
   4237          }
   4238          
   4239          /******************************************************************************
   4240           * @fn          ZDSecMgrApsLinkKeyInit
   4241           *
   4242           * @brief       Initialize the NV table for Application link keys
   4243           *           
   4244           * @param       none
   4245           *
   4246           * @return      none
   4247           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4248          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4249          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV       A,#-0x18
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   4250            APSME_LinkKeyData_t pApsLinkKey;
   4251            uint8 i;
   4252            uint8 status;
   4253            
   4254            // Initialize all NV items for APS link key, if not exist already.
   4255            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV       R4,#0x18
   \   00000C   7D00         MOV       R5,#0x0
   \   00000E   7900         MOV       R1,#0x0
   \   000010   AA..         MOV       R2,?XSP + 0
   \   000012   AB..         MOV       R3,?XSP + 1
   \   000014   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4256            
   4257            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   7E00         MOV       R6,#0x0
   4258            {
   4259              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 
   4260                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4261              
   4262          #if defined ( NV_RESTORE )
   4263              (void)status;   // to eliminate compiler warning
   4264          #else
   4265              // reset the values of NV items if NV_RESTORE is not enabled
   4266              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000019                ; Setup parameters for call to function osal_nv_item_init
   \   000019   A8..         MOV       R0,?XSP + 0
   \   00001B   A9..         MOV       R1,?XSP + 1
   \   00001D   88..         MOV       ?V0,R0
   \   00001F   89..         MOV       ?V1,R1
   \   000021   78..         MOV       R0,#?V0
   \   000023   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000026   7C18         MOV       R4,#0x18
   \   000028   7D00         MOV       R5,#0x0
   \   00002A   EE           MOV       A,R6
   \   00002B   2401         ADD       A,#0x1
   \   00002D   FA           MOV       R2,A
   \   00002E   E4           CLR       A
   \   00002F   3402         ADDC      A,#0x2
   \   000031   FB           MOV       R3,A
   \   000032   12....       LCALL     `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000035   7402         MOV       A,#0x2
   \   000037   12....       LCALL     ?DEALLOC_XSTACK8
   \   00003A   E9           MOV       A,R1
   \   00003B   7024         JNZ       ??ZDSecMgrApsLinkKeyInit_1
   4267              {
   4268                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0, 
   4269                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00003D                ; Setup parameters for call to function osal_nv_write
   \   00003D   78..         MOV       R0,#?V0
   \   00003F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000042   75..18       MOV       ?V0,#0x18
   \   000045   75..00       MOV       ?V1,#0x0
   \   000048   78..         MOV       R0,#?V0
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00004D   7C00         MOV       R4,#0x0
   \   00004F   7D00         MOV       R5,#0x0
   \   000051   EE           MOV       A,R6
   \   000052   2401         ADD       A,#0x1
   \   000054   FA           MOV       R2,A
   \   000055   E4           CLR       A
   \   000056   3402         ADDC      A,#0x2
   \   000058   FB           MOV       R3,A
   \   000059   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005C   7404         MOV       A,#0x4
   \   00005E   12....       LCALL     ?DEALLOC_XSTACK8
   4270                
   4271              }
   4272          #endif // defined (NV_RESTORE)
   4273            }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000061   0E           INC       R6
   \   000062   EE           MOV       A,R6
   \   000063   C3           CLR       C
   \   000064   9403         SUBB      A,#0x3
   \   000066   40B1         JC        ??ZDSecMgrApsLinkKeyInit_0
   4274          }
   \   000068   7418         MOV       A,#0x18
   \   00006A   02....       LJMP      ??Subroutine85_0 & 0xFFFF
   4275          
   4276          /******************************************************************************
   4277           * @fn          ZDSecMgrInitNVKeyTables
   4278           *
   4279           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4280           *           
   4281           * @param       setDefault - TRUE to set default values 
   4282           *
   4283           * @return      none
   4284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4285          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4286          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   4287            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL     `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   4288            ZDSecMgrMasterKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrMasterKeyInit
   \   00000A   12....       LCALL     `??ZDSecMgrMasterKeyInit::?relay`; Banked call to: ZDSecMgrMasterKeyInit
   4289            ZDSecMgrApsLinkKeyInit();
   \   00000D                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000D   12....       LCALL     `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   4290            APSME_TCLinkKeyInit(setDefault);
   \   000010                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   000010   EE           MOV       A,R6
   \   000011   F9           MOV       R1,A
   \   000012   12....       LCALL     `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   4291          }
   \   000015   02....       LJMP      ??Subroutine93_0 & 0xFFFF
   4292          
   4293          /******************************************************************************
   4294           * @fn          ZDSecMgrSaveApsLinkKey
   4295           *
   4296           * @brief       Save APS Link Key to NV. It will loop through all the keys  
   4297           *              to see which one to save.
   4298           *           
   4299           * @param       none
   4300           *
   4301           * @return      none
   4302           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4303          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4304          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   4305            APSME_LinkKeyData_t *pKeyData = NULL;
   4306            int i;
   4307            
   4308            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A18         MOV       R2,#0x18
   \   000007   7B00         MOV       R3,#0x0
   \   000009   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   4309            
   4310            if (pKeyData != NULL)
   \   000010   EA           MOV       A,R2
   \   000011   45..         ORL       A,?V3
   \   000013   7003         JNZ       $+5
   \   000015   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   4311            {          
   4312              // checks all pending flags to know which one to save
   4313              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000018   7E00         MOV       R6,#0x0
   \   00001A   7F00         MOV       R7,#0x0
   4314              {
   4315                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   00001C   EE           MOV       A,R6
   \   00001D   F8           MOV       R0,A
   \   00001E   EF           MOV       A,R7
   \   00001F   F9           MOV       R1,A
   \   000020   E8           MOV       A,R0
   \   000021   75F009       MOV       B,#0x9
   \   000024   A4           MUL       AB
   \   000025   F8           MOV       R0,A
   \   000026   AAF0         MOV       R2,B
   \   000028   75F009       MOV       B,#0x9
   \   00002B   E9           MOV       A,R1
   \   00002C   A4           MUL       AB
   \   00002D   2A           ADD       A,R2
   \   00002E   F9           MOV       R1,A
   \   00002F   74..         MOV       A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000031   28           ADD       A,R0
   \   000032   F582         MOV       DPL,A
   \   000034   74..         MOV       A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000036   39           ADDC      A,R1
   \   000037   F583         MOV       DPH,A
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   6401         XRL       A,#0x1
   \   00003C   6003         JZ        $+5
   \   00003E   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   4316                {
   4317                  // retrieve key from NV
   4318                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4319                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000041                ; Setup parameters for call to function osal_nv_read
   \   000041   78..         MOV       R0,#?V2
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   75..18       MOV       ?V0,#0x18
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000054   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000057   7404         MOV       A,#0x4
   \   000059   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005C   E9           MOV       A,R1
   \   00005D   7074         JNZ       ??ZDSecMgrSaveApsLinkKey_2
   4320                  {                
   4321                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00005F   EE           MOV       A,R6
   \   000060   F8           MOV       R0,A
   \   000061   EF           MOV       A,R7
   \   000062   F9           MOV       R1,A
   \   000063   E8           MOV       A,R0
   \   000064   75F009       MOV       B,#0x9
   \   000067   A4           MUL       AB
   \   000068   F8           MOV       R0,A
   \   000069   AAF0         MOV       R2,B
   \   00006B   75F009       MOV       B,#0x9
   \   00006E   E9           MOV       A,R1
   \   00006F   A4           MUL       AB
   \   000070   2A           ADD       A,R2
   \   000071   F9           MOV       R1,A
   \   000072   74..         MOV       A,#ApsLinkKeyFrmCntr & 0xff
   \   000074   28           ADD       A,R0
   \   000075   F5..         MOV       ?V0,A
   \   000077   74..         MOV       A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000079   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00007C   12....       LCALL     ?XLOAD_R0123
   \   00007F   E5..         MOV       A,?V2
   \   000081   2410         ADD       A,#0x10
   \   000083   F582         MOV       DPL,A
   \   000085   E4           CLR       A
   \   000086   35..         ADDC      A,?V3
   \   000088   F583         MOV       DPH,A
   \   00008A   12....       LCALL     ?XSTORE_R0123
   4322                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   00008D   85..82       MOV       DPL,?V0
   \   000090   85..83       MOV       DPH,?V1
   \   000093   A3           INC       DPTR
   \   000094   A3           INC       DPTR
   \   000095   A3           INC       DPTR
   \   000096   A3           INC       DPTR
   \   000097   12....       LCALL     ?XLOAD_R0123
   \   00009A   E5..         MOV       A,?V2
   \   00009C   2414         ADD       A,#0x14
   \   00009E   F582         MOV       DPL,A
   \   0000A0   E4           CLR       A
   \   0000A1   35..         ADDC      A,?V3
   \   0000A3   F583         MOV       DPH,A
   \   0000A5   12....       LCALL     ?XSTORE_R0123
   4323                    
   4324                    // Write the APS link key back to the NV
   4325                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0, 
   4326                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000A8                ; Setup parameters for call to function osal_nv_write
   \   0000A8   78..         MOV       R0,#?V2
   \   0000AA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000AD   75..18       MOV       ?V4,#0x18
   \   0000B0   75..00       MOV       ?V5,#0x0
   \   0000B3   78..         MOV       R0,#?V4
   \   0000B5   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B8   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000BB   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000BE   7404         MOV       A,#0x4
   \   0000C0   12....       LCALL     ?DEALLOC_XSTACK8
   4327                    
   4328                    // clear the pending write flag
   4329                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000C3   85..82       MOV       DPL,?V0
   \   0000C6   85..83       MOV       DPH,?V1
   \   0000C9   A3           INC       DPTR
   \   0000CA   A3           INC       DPTR
   \   0000CB   A3           INC       DPTR
   \   0000CC   A3           INC       DPTR
   \   0000CD   A3           INC       DPTR
   \   0000CE   A3           INC       DPTR
   \   0000CF   A3           INC       DPTR
   \   0000D0   A3           INC       DPTR
   \   0000D1   E4           CLR       A
   \   0000D2   F0           MOVX      @DPTR,A
   4330                  }
   4331                }
   4332              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000D3   0E           INC       R6
   \   0000D4   EE           MOV       A,R6
   \   0000D5   7001         JNZ       ??ZDSecMgrSaveApsLinkKey_3
   \   0000D7   0F           INC       R7
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   0000D8   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0000DB   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000DD   65D0         XRL       A,PSW
   \   0000DF   33           RLC       A
   \   0000E0   5003         JNC       $+5
   \   0000E2   02....       LJMP      ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   4333              
   4334              // clear copy of key in RAM 
   4335              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000E5                ; Setup parameters for call to function osal_memset
   \   0000E5   7C18         MOV       R4,#0x18
   \   0000E7   7D00         MOV       R5,#0x0
   \   0000E9   7900         MOV       R1,#0x0
   \   0000EB   AA..         MOV       R2,?V2
   \   0000ED   AB..         MOV       R3,?V3
   \   0000EF   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4336              
   4337              osal_mem_free(pKeyData);
   \   0000F2                ; Setup parameters for call to function osal_mem_free
   \   0000F2   AA..         MOV       R2,?V2
   \   0000F4   AB..         MOV       R3,?V3
   \   0000F6   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4338            }  
   4339          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   0000F9   02....       LJMP      ??Subroutine79_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   39           ADDC      A,R1
   \   000001   F5..         MOV       ?V1,A
   \   000003   85..82       MOV       DPL,?V0
   \   000006   F583         MOV       DPH,A
   \   000008   22           RET
   4340          
   4341          /******************************************************************************
   4342           * @fn          ZDSecMgrSaveTCLinkKey
   4343           *
   4344           * @brief       Save TC Link Key to NV. It will loop through all the keys 
   4345           *              to see which one to save.
   4346           *           
   4347           * @param       none
   4348           *
   4349           * @return      none
   4350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4351          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4352          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   4353            APSME_TCLinkKey_t *pKeyData = NULL;
   4354            int i;
   4355            
   4356            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV       R2,#0x20
   \   000007   7B00         MOV       R3,#0x0
   \   000009   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV       ?V2,R2
   \   00000E   8B..         MOV       ?V3,R3
   4357            
   4358            if (pKeyData != NULL)
   \   000010   EA           MOV       A,R2
   \   000011   45..         ORL       A,?V3
   \   000013   7003         JNZ       $+5
   \   000015   02....       LJMP      ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   4359            {          
   4360              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000018   7E00         MOV       R6,#0x0
   \   00001A   7F00         MOV       R7,#0x0
   4361              {
   4362                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00001C   EE           MOV       A,R6
   \   00001D   F8           MOV       R0,A
   \   00001E   EF           MOV       A,R7
   \   00001F   F9           MOV       R1,A
   \   000020   E8           MOV       A,R0
   \   000021   75F009       MOV       B,#0x9
   \   000024   A4           MUL       AB
   \   000025   F8           MOV       R0,A
   \   000026   AAF0         MOV       R2,B
   \   000028   75F009       MOV       B,#0x9
   \   00002B   E9           MOV       A,R1
   \   00002C   A4           MUL       AB
   \   00002D   2A           ADD       A,R2
   \   00002E   F9           MOV       R1,A
   \   00002F   74..         MOV       A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   000031   28           ADD       A,R0
   \   000032   F582         MOV       DPL,A
   \   000034   74..         MOV       A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000036   39           ADDC      A,R1
   \   000037   F583         MOV       DPH,A
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   6401         XRL       A,#0x1
   \   00003C   6003         JZ        $+5
   \   00003E   02....       LJMP      ??ZDSecMgrSaveTCLinkKey_2 & 0xFFFF
   4363                {
   4364                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4365                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000041                ; Setup parameters for call to function osal_nv_read
   \   000041   78..         MOV       R0,#?V2
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000046   75..20       MOV       ?V0,#0x20
   \   000049   75..00       MOV       ?V1,#0x0
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   7C00         MOV       R4,#0x0
   \   000053   7D00         MOV       R5,#0x0
   \   000055   EE           MOV       A,R6
   \   000056   2401         ADD       A,#0x1
   \   000058   FA           MOV       R2,A
   \   000059   EF           MOV       A,R7
   \   00005A   3401         ADDC      A,#0x1
   \   00005C   FB           MOV       R3,A
   \   00005D   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000060   7404         MOV       A,#0x4
   \   000062   12....       LCALL     ?DEALLOC_XSTACK8
   \   000065   E9           MOV       A,R1
   \   000066   707D         JNZ       ??ZDSecMgrSaveTCLinkKey_2
   4366                  {                
   4367                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000068   EE           MOV       A,R6
   \   000069   F8           MOV       R0,A
   \   00006A   EF           MOV       A,R7
   \   00006B   F9           MOV       R1,A
   \   00006C   E8           MOV       A,R0
   \   00006D   75F009       MOV       B,#0x9
   \   000070   A4           MUL       AB
   \   000071   F8           MOV       R0,A
   \   000072   AAF0         MOV       R2,B
   \   000074   75F009       MOV       B,#0x9
   \   000077   E9           MOV       A,R1
   \   000078   A4           MUL       AB
   \   000079   2A           ADD       A,R2
   \   00007A   F9           MOV       R1,A
   \   00007B   74..         MOV       A,#TCLinkKeyFrmCntr & 0xff
   \   00007D   28           ADD       A,R0
   \   00007E   F5..         MOV       ?V0,A
   \   000080   74..         MOV       A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000082   12....       LCALL     ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000085   12....       LCALL     ?XLOAD_R0123
   \   000088   E5..         MOV       A,?V2
   \   00008A   2418         ADD       A,#0x18
   \   00008C   F582         MOV       DPL,A
   \   00008E   E4           CLR       A
   \   00008F   35..         ADDC      A,?V3
   \   000091   F583         MOV       DPH,A
   \   000093   12....       LCALL     ?XSTORE_R0123
   4368                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000096   85..82       MOV       DPL,?V0
   \   000099   85..83       MOV       DPH,?V1
   \   00009C   A3           INC       DPTR
   \   00009D   A3           INC       DPTR
   \   00009E   A3           INC       DPTR
   \   00009F   A3           INC       DPTR
   \   0000A0   12....       LCALL     ?XLOAD_R0123
   \   0000A3   E5..         MOV       A,?V2
   \   0000A5   241C         ADD       A,#0x1c
   \   0000A7   F582         MOV       DPL,A
   \   0000A9   E4           CLR       A
   \   0000AA   35..         ADDC      A,?V3
   \   0000AC   F583         MOV       DPH,A
   \   0000AE   12....       LCALL     ?XSTORE_R0123
   4369                    
   4370                    // Write the TC link key back to the NV
   4371                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0, 
   4372                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   0000B1                ; Setup parameters for call to function osal_nv_write
   \   0000B1   78..         MOV       R0,#?V2
   \   0000B3   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000B6   75..20       MOV       ?V4,#0x20
   \   0000B9   75..00       MOV       ?V5,#0x0
   \   0000BC   78..         MOV       R0,#?V4
   \   0000BE   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C1   7C00         MOV       R4,#0x0
   \   0000C3   7D00         MOV       R5,#0x0
   \   0000C5   EE           MOV       A,R6
   \   0000C6   2401         ADD       A,#0x1
   \   0000C8   FA           MOV       R2,A
   \   0000C9   EF           MOV       A,R7
   \   0000CA   3401         ADDC      A,#0x1
   \   0000CC   FB           MOV       R3,A
   \   0000CD   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000D0   7404         MOV       A,#0x4
   \   0000D2   12....       LCALL     ?DEALLOC_XSTACK8
   4373                    
   4374                    // clear the pending write flag
   4375                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000D5   85..82       MOV       DPL,?V0
   \   0000D8   85..83       MOV       DPH,?V1
   \   0000DB   A3           INC       DPTR
   \   0000DC   A3           INC       DPTR
   \   0000DD   A3           INC       DPTR
   \   0000DE   A3           INC       DPTR
   \   0000DF   A3           INC       DPTR
   \   0000E0   A3           INC       DPTR
   \   0000E1   A3           INC       DPTR
   \   0000E2   A3           INC       DPTR
   \   0000E3   E4           CLR       A
   \   0000E4   F0           MOVX      @DPTR,A
   4376                  }
   4377                }
   4378              }
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   0000E5   0E           INC       R6
   \   0000E6   EE           MOV       A,R6
   \   0000E7   7001         JNZ       ??ZDSecMgrSaveTCLinkKey_3
   \   0000E9   0F           INC       R7
   \                     ??ZDSecMgrSaveTCLinkKey_3:
   \   0000EA   C3           CLR       C
   \   0000EB   9401         SUBB      A,#0x1
   \   0000ED   EF           MOV       A,R7
   \   0000EE   9400         SUBB      A,#0x0
   \   0000F0   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000F2   65D0         XRL       A,PSW
   \   0000F4   33           RLC       A
   \   0000F5   5003         JNC       $+5
   \   0000F7   02....       LJMP      ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   4379                // clear copy of key in RAM 
   4380              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   0000FA                ; Setup parameters for call to function osal_memset
   \   0000FA   7C20         MOV       R4,#0x20
   \   0000FC   7D00         MOV       R5,#0x0
   \   0000FE   7900         MOV       R1,#0x0
   \   000100   AA..         MOV       R2,?V2
   \   000102   AB..         MOV       R3,?V3
   \   000104   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   4381              
   4382              osal_mem_free(pKeyData);
   \   000107                ; Setup parameters for call to function osal_mem_free
   \   000107   AA..         MOV       R2,?V2
   \   000109   AB..         MOV       R3,?V3
   \   00010B   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   4383            }
   4384          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   00010E   02....       LJMP      ??Subroutine79_0 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExtGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlRelease::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlTerm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrCtrlReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrMasterKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendMasterKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrMgrUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceEntryAdd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlHandler::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlSetup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceCtrlUpdate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_SKA_TimerExpired::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateSKKE::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateCM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthInitiate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEstablishKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticateCfm::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetupPartner::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_MasterKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyNVIdGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsLinkKeyValid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNwkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrReadKeyFromNv::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrApsLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNVKeyTables::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveApsLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveTCLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey
   4385          
   4386          #if defined ( NV_RESTORE )
   4387          /******************************************************************************
   4388           * @fn          ZDSecMgrClearNVKeyValues
   4389           *
   4390           * @brief       If NV_RESTORE is enabled and the status of the network needs 
   4391           *              default values this fuction clears ZCD_NV_NWKKEY, 
   4392           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link 
   4393           *           
   4394           * @param       none
   4395           *
   4396           * @return      none
   4397           */
   4398          void ZDSecMgrClearNVKeyValues(void)
   4399          {
   4400            nwkActiveKeyItems keyItems;
   4401            nwkKeyDesc nwkKey;
   4402          
   4403            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4404          
   4405            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4406          
   4407            // Initialize NV items for NWK Active and Alternate keys. 
   4408            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4409          
   4410            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4411          
   4412            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4413          }
   4414          #endif // defined ( NV_RESTORE )
   4415          
   4416          /******************************************************************************
   4417          ******************************************************************************/
   4418          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     66   APSME_IsDefaultTCLK
      0     36   APSME_IsLinkKeyValid
        0     32   -> APSME_LinkKeyNVIdGet
        0     32   -> osal_mem_alloc
        0     35   -> osal_memcmp
        0     32   -> osal_memset
        0     36   -> osal_nv_read
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     43   APSME_LinkKeyNVIdGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     37   APSME_LinkKeySet
        0     21   -> ZDSecMgrEntryLookupExtGetIndex
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     22   -> osal_memcpy
        0     19   -> osal_memset
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
      0     11   APSME_MasterKeyGet
        0     11   -> ZDSecMgrExtAddrLookup
        0     11   -> ZDSecMgrMasterKeyLookup
      0      0   APSME_SKA_TimerExpired
      0     56   APSME_TCLinkKeyInit
        0     46   -> osal_memcpy
        0     43   -> osal_memset
        0     45   -> osal_nv_item_init
        0     47   -> osal_nv_read
        0     47   -> osal_nv_write
      0     61   APSME_TCLinkKeyLoad
        0     57   -> APSME_IsDefaultTCLK
        0     57   -> APSME_LookupExtAddr
        0     57   -> AddrMgrEntryLookupNwk
        0     57   -> AddrMgrEntryRelease
        0     57   -> AddrMgrExtAddrEqual
        0     57   -> AddrMgrExtAddrValid
        0     57   -> osal_memset
        0     61   -> osal_nv_read
      0     48   APSME_TCLinkKeySync
        0     44   -> APSME_IsDefaultTCLK
        0     44   -> APSME_LookupExtAddr
        0     44   -> AddrMgrExtAddrEqual
        0     44   -> AddrMgrExtAddrValid
        0     44   -> osal_memset
        0     48   -> osal_nv_read
      2     12   ZDSecMgrAPSRemove
        2     10   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     36   ZDSecMgrAddrMgrUpdate
        0     22   -> AddrMgrEntryGet
        0     22   -> AddrMgrEntryUpdate
      0     55   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     57   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     57   ZDSecMgrAppKeyReq
        0     49   -> APSME_LookupExtAddr
        0     49   -> APSME_LookupNwkAddr
        0     49   -> APSME_TransportKeyReq
        0     57   -> ZDSecMgrAppKeyGet
        0     49   -> osal_memset
      0     47   ZDSecMgrApsLinkKeyInit
        0     34   -> osal_memset
        0     36   -> osal_nv_item_init
        0     38   -> osal_nv_write
      2     35   ZDSecMgrAssocDeviceAuth
      0     16   ZDSecMgrAuthInitiate
        0     16   -> APSME_AuthenticateReq
        0     16   -> APSME_LookupNwkAddr
      2     25   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      2      0   ZDSecMgrAuthenticateCfm
        2      0   -> osal_set_event
      0     29   ZDSecMgrAuthenticateInd
        0     29   -> APSME_AuthenticateReq
        0     29   -> AddrMgrEntryUpdate
        0     29   -> AddrMgrExtAddrSet
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityNM
      0     26   ZDSecMgrCtrlAdd
        0     14   -> ZDSecMgrCtrlSet
      2      0   ZDSecMgrCtrlInit
        2      0   -> osal_mem_alloc
      0     22   ZDSecMgrCtrlLookup
      2      0   ZDSecMgrCtrlRelease
      0     14   ZDSecMgrCtrlReset
        0     12   -> ZDSecMgrCtrlAdd
        0     12   -> ZDSecMgrCtrlLookup
        0     14   -> ZDSecMgrCtrlSet
      1     23   ZDSecMgrCtrlSet
      2      2   ZDSecMgrCtrlTerm
        2      2   -> ZDSecMgrCtrlLookup
      1     42   ZDSecMgrDeviceCtrlHandler
        0      9   -> ZDSecMgrEstablishKey
        0      9   -> ZDSecMgrSendMasterKey
        0      9   -> ZDSecMgrSendNwkKey
        0      9   -> osal_start_timerEx
      2      0   ZDSecMgrDeviceCtrlSetup
        2      0   -> ZDSecMgrDeviceCtrlHandler
      0     13   ZDSecMgrDeviceCtrlUpdate
        0     13   -> ZDSecMgrCtrlLookup
        0     13   -> ZDSecMgrEntryLookupExt
      0     44   ZDSecMgrDeviceEntryAdd
        0     14   -> ZDSecMgrAddrMgrUpdate
        0     14   -> ZDSecMgrEntryFree
        0     14   -> ZDSecMgrEntryLookup
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      2      0   ZDSecMgrDeviceEntryRemove
        2      0   -> ZDSecMgrEntryFree
      0     24   ZDSecMgrDeviceJoin
        0     14   -> ZDSecMgrAddrStore
        0     12   -> ZDSecMgrDeviceRemove
        0     12   -> ZDSecMgrDeviceValidate
        0     12   -> ZDSecMgrSendNwkKey
      0      9   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      2      8   ZDSecMgrDeviceJoinFwd
        2      8   -> APSME_UpdateDeviceReq
      2     35   ZDSecMgrDeviceNew
        2      0   -> ZDSecMgrDeviceJoinFwd
      0     38   ZDSecMgrDeviceRemove
        0     19   -> APSME_RemoveDeviceReq
        0     19   -> AssocGetWithExt
        0     19   -> NLME_GetShortAddr
        0     19   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      2     12   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      0     33   ZDSecMgrDeviceValidateCM
        0     32   -> ZDSecMgrAddrStore
        0     30   -> ZDSecMgrDeviceEntryAdd
        0     30   -> ZDSecMgrMasterKeyLoad
        0     33   -> osal_memcpy
        0     30   -> osal_memset
      2      0   ZDSecMgrDeviceValidateRM
      0     40   ZDSecMgrDeviceValidateSKKE
        0     13   -> ZDSecMgrDeviceEntryAdd
        0     13   -> ZDSecMgrExtAddrLookup
        0     13   -> ZDSecMgrMasterKeyLookup
      0     32   ZDSecMgrEntryFree
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_write
      2      0   ZDSecMgrEntryInit
        2      0   -> osal_mem_alloc
      0     36   ZDSecMgrEntryLookup
        0     22   -> AddrMgrEntryLookupNwk
      0     23   ZDSecMgrEntryLookupAMI
      0     24   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     32   ZDSecMgrEntryLookupExtGetIndex
        0     11   -> ZDSecMgrExtAddrLookup
      0     23   ZDSecMgrEntryNew
      0     26   ZDSecMgrEstablishKey
        0     17   -> APSME_EstablishKeyReq
        0     17   -> NLME_GetShortAddr
      0      0   ZDSecMgrEstablishKeyCfm
      1     27   ZDSecMgrEstablishKeyInd
        0     27   -> APSME_EstablishKeyRsp
        0     27   -> ZDSecMgrDeviceValidateSKKE
        0     27   -> ZDSecMgrTCDataLoad
        0     27   -> ZDSecMgrTCExtAddrCheck
      1     33   ZDSecMgrEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> ZDSecMgrDeviceCtrlHandler
        0     33   -> osal_start_timerEx
      0     36   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_SecurityNM
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrMasterKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      0     41   ZDSecMgrMasterKeyInit
        0     28   -> osal_memset
        0     30   -> osal_nv_item_init
        0     32   -> osal_nv_write
      0     48   ZDSecMgrMasterKeyLoad
        0     14   -> ZDSecMgrExtAddrLookup
        0     14   -> ZDSecMgrMasterKeyLookup
        0     14   -> ZDSecMgrMasterKeyStore
        0     18   -> osal_nv_write
      0     77   ZDSecMgrMasterKeyLookup
        0     32   -> osal_memset
        0     36   -> osal_nv_read
      0     67   ZDSecMgrMasterKeyStore
        0     35   -> osal_memcpy
        0     32   -> osal_memset
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocMatchDeviceStatus
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     39   ZDSecMgrReadKeyFromNv
        0     14   -> osal_nv_read
      0     19   ZDSecMgrRemoveDeviceInd
        0     19   -> APSME_LookupNwkAddr
        0     19   -> NLME_GetShortAddr
        0     19   -> ZDSecMgrDeviceRemove
      2     12   ZDSecMgrRequestAppKey
        2     12   -> APSME_RequestKeyReq
        2     12   -> AddrMgrExtAddrLookup
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     18   ZDSecMgrSaveApsLinkKey
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_read
        0     18   -> osal_nv_write
      0     18   ZDSecMgrSaveTCLinkKey
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_read
        0     18   -> osal_nv_write
      0     54   ZDSecMgrSendMasterKey
        0     41   -> APSME_TransportKeyReq
        0     41   -> NLME_GetShortAddr
        0     41   -> ZDSecMgrMasterKeyLookup
        0     41   -> osal_memset
        0     45   -> osal_nv_read
      1     56   ZDSecMgrSendNwkKey
        0     40   -> APSME_TransportKeyReq
        0     40   -> NLME_GetShortAddr
        0     44   -> NLME_ReadNwkKeyInfo
        0     40   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0     24   ZDSecMgrSetupPartner
        0     24   -> AddrMgrEntryUpdate
        0     24   -> AddrMgrExtAddrSet
        0     24   -> AddrMgrExtAddrValid
        0     24   -> ZDP_IEEEAddrReq
        0     24   -> ZDP_NwkAddrReq
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      0     61   ZDSecMgrTCDataLoad
        0     33   -> ZDSecMgrAddrStore
        0     31   -> ZDSecMgrMasterKeyLookup
        0     31   -> ZDSecMgrMasterKeyStore
        0     34   -> osal_memcpy
        0     31   -> osal_memset
      0     44   ZDSecMgrTCExtAddrCheck
        0     17   -> AddrMgrExtAddrEqual
        0     17   -> AddrMgrExtAddrLookup
      0     25   ZDSecMgrTransportKeyInd
        0     25   -> SSP_SwitchNwkKey
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDSecMgrAuthNwkKey
        0     25   -> ZDSecMgrReadKeyFromNv
        0     25   -> ZDSecMgrTCDataLoad
        0     25   -> osal_memset
      2     10   ZDSecMgrUpdateDeviceInd
        2     10   -> ZDSecMgrDeviceJoin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
       9  ??Subroutine100_0
       4  ??Subroutine101_0
      10  ??Subroutine102_0
       5  ??Subroutine103_0
       2  ??Subroutine104_0
       4  ??Subroutine105_0
       5  ??Subroutine74_0
       6  ??Subroutine75_0
      11  ??Subroutine76_0
      10  ??Subroutine77_0
       6  ??Subroutine78_0
       5  ??Subroutine79_0
      11  ??Subroutine80_0
       6  ??Subroutine81_0
       6  ??Subroutine82_0
       4  ??Subroutine83_0
       4  ??Subroutine84_0
       3  ??Subroutine85_0
       5  ??Subroutine86_0
       6  ??Subroutine87_0
       6  ??Subroutine88_0
       6  ??Subroutine89_0
       7  ??Subroutine90_0
       2  ??Subroutine91_0
       3  ??Subroutine92_0
       5  ??Subroutine93_0
       6  ??Subroutine94_0
       6  ??Subroutine95_0
       6  ??Subroutine96_0
       6  ??Subroutine97_0
       6  ??Subroutine98_0
       2  ??Subroutine99_0
       2  ?Subroutine0
       2  ?Subroutine1
       4  ?Subroutine10
       5  ?Subroutine11
       3  ?Subroutine12
       3  ?Subroutine13
      15  ?Subroutine14
      13  ?Subroutine15
       6  ?Subroutine16
       8  ?Subroutine17
       7  ?Subroutine18
       6  ?Subroutine19
       5  ?Subroutine2
       5  ?Subroutine20
       6  ?Subroutine21
       7  ?Subroutine22
       9  ?Subroutine23
      13  ?Subroutine24
       3  ?Subroutine25
       3  ?Subroutine26
       3  ?Subroutine27
       7  ?Subroutine28
       2  ?Subroutine29
       7  ?Subroutine3
       1  ?Subroutine30
       7  ?Subroutine31
      13  ?Subroutine32
       4  ?Subroutine33
       6  ?Subroutine34
       6  ?Subroutine35
       6  ?Subroutine36
       2  ?Subroutine37
      29  ?Subroutine38
      19  ?Subroutine39
       3  ?Subroutine4
       7  ?Subroutine40
       6  ?Subroutine41
       6  ?Subroutine42
      28  ?Subroutine43
       9  ?Subroutine44
       4  ?Subroutine45
       4  ?Subroutine46
      11  ?Subroutine47
       6  ?Subroutine48
      10  ?Subroutine49
       8  ?Subroutine5
      10  ?Subroutine50
       4  ?Subroutine51
      30  ?Subroutine52
       9  ?Subroutine53
      16  ?Subroutine54
       8  ?Subroutine55
      13  ?Subroutine56
       6  ?Subroutine57
      12  ?Subroutine58
      12  ?Subroutine59
       5  ?Subroutine6
       6  ?Subroutine60
       6  ?Subroutine61
       9  ?Subroutine62
      11  ?Subroutine63
      38  ?Subroutine64
       5  ?Subroutine65
      13  ?Subroutine66
       6  ?Subroutine67
       7  ?Subroutine68
       9  ?Subroutine69
       5  ?Subroutine7
       9  ?Subroutine70
       9  ?Subroutine71
       9  ?Subroutine72
       5  ?Subroutine73
       5  ?Subroutine8
       2  ?Subroutine9
      53  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
     150  APSME_IsLinkKeyValid
       6  APSME_IsLinkKeyValid::?relay
      75  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      52  APSME_LinkKeyNVIdGet
       6  APSME_LinkKeyNVIdGet::?relay
     298  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
      45  APSME_MasterKeyGet
       6  APSME_MasterKeyGet::?relay
       3  APSME_SKA_TimerExpired
       6  APSME_SKA_TimerExpired::?relay
     245  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     203  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     174  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      74  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     107  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      70  ZDSecMgrAddrMgrUpdate
       6  ZDSecMgrAddrMgrUpdate::?relay
      75  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      42  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     273  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
     109  ZDSecMgrApsLinkKeyInit
       6  ZDSecMgrApsLinkKeyInit::?relay
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      59  ZDSecMgrAuthInitiate
       6  ZDSecMgrAuthInitiate::?relay
      27  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
      50  ZDSecMgrAuthenticateCfm
       6  ZDSecMgrAuthenticateCfm::?relay
     102  ZDSecMgrAuthenticateInd
       6  ZDSecMgrAuthenticateInd::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      33  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
       3  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
     138  ZDSecMgrCtrlAdd
       6  ZDSecMgrCtrlAdd::?relay
       2  ZDSecMgrCtrlData
      74  ZDSecMgrCtrlInit
       6  ZDSecMgrCtrlInit::?relay
      95  ZDSecMgrCtrlLookup
       6  ZDSecMgrCtrlLookup::?relay
      18  ZDSecMgrCtrlRelease
       6  ZDSecMgrCtrlRelease::?relay
      79  ZDSecMgrCtrlReset
       6  ZDSecMgrCtrlReset::?relay
      75  ZDSecMgrCtrlSet
       6  ZDSecMgrCtrlSet::?relay
      30  ZDSecMgrCtrlTerm
       6  ZDSecMgrCtrlTerm::?relay
     109  ZDSecMgrDeviceCtrlHandler
       6  ZDSecMgrDeviceCtrlHandler::?relay
      66  ZDSecMgrDeviceCtrlSetup
       6  ZDSecMgrDeviceCtrlSetup::?relay
      93  ZDSecMgrDeviceCtrlUpdate
       6  ZDSecMgrDeviceCtrlUpdate::?relay
     147  ZDSecMgrDeviceEntryAdd
       6  ZDSecMgrDeviceEntryAdd::?relay
      10  ZDSecMgrDeviceEntryRemove
       6  ZDSecMgrDeviceEntryRemove::?relay
      79  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      35  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     154  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
       9  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     180  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      32  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      48  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
     147  ZDSecMgrDeviceValidateCM
       6  ZDSecMgrDeviceValidateCM::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
      66  ZDSecMgrDeviceValidateSKKE
       6  ZDSecMgrDeviceValidateSKKE::?relay
       2  ZDSecMgrEntries
     107  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      71  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
     117  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      74  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      47  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     117  ZDSecMgrEntryLookupExtGetIndex
       6  ZDSecMgrEntryLookupExtGetIndex::?relay
     142  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
     113  ZDSecMgrEstablishKey
       6  ZDSecMgrEstablishKey::?relay
       3  ZDSecMgrEstablishKeyCfm
       6  ZDSecMgrEstablishKeyCfm::?relay
     182  ZDSecMgrEstablishKeyInd
       6  ZDSecMgrEstablishKeyInd::?relay
     240  ZDSecMgrEvent
       6  ZDSecMgrEvent::?relay
      69  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      74  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
       3  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
      24  ZDSecMgrInitNVKeyTables
       6  ZDSecMgrInitNVKeyTables::?relay
     115  ZDSecMgrMasterKeyInit
       6  ZDSecMgrMasterKeyInit::?relay
      91  ZDSecMgrMasterKeyLoad
       6  ZDSecMgrMasterKeyLoad::?relay
     144  ZDSecMgrMasterKeyLookup
       6  ZDSecMgrMasterKeyLookup::?relay
     224  ZDSecMgrMasterKeyStore
       6  ZDSecMgrMasterKeyStore::?relay
     179  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
     235  ZDSecMgrNwkKeyInit
       6  ZDSecMgrNwkKeyInit::?relay
      39  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      24  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
     194  ZDSecMgrReadKeyFromNv
       6  ZDSecMgrReadKeyFromNv::?relay
      73  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      62  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      36  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     252  ZDSecMgrSaveApsLinkKey
       6  ZDSecMgrSaveApsLinkKey::?relay
     273  ZDSecMgrSaveTCLinkKey
       6  ZDSecMgrSaveTCLinkKey::?relay
     255  ZDSecMgrSendMasterKey
       6  ZDSecMgrSendMasterKey::?relay
     284  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     226  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
     124  ZDSecMgrSetupPartner
       6  ZDSecMgrSetupPartner::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
       1  ZDSecMgrTCAuthenticated
     134  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       1  ZDSecMgrTCDataLoaded
       8  ZDSecMgrTCExtAddr
      52  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
      16  ZDSecMgrTCMasterKey
     192  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
      48  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
       4  __Constant_1

 
 9 514 bytes in segment BANKED_CODE
   510 bytes in segment BANK_RELAYS
    16 bytes in segment CODE_C
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
     4 bytes in segment XDATA_ROM_C
    84 bytes in segment XDATA_Z
 
   527 bytes of CODE     memory
     0 bytes of CONST    memory (+ 4 bytes shared)
 9 514 bytes of HUGECODE memory
    85 bytes of XDATA    memory

Errors: none
Warnings: none
